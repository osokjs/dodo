(Do it) 플러터 앱 프로그래밍 : 실전 코드로 배우는 플러터 기본과 활용법 : 오픈 API활용 + 파이어베이스 + 구글 맵 + 광고 수익까지 : 크로스 플랫폼 모바일 앱 개발 입문하기
조준수 지음
표지
세상의 속도를 따라잡고 싶다면 Do it!
실전 코드로 배우는 플러터 기본과 활용법
플러터 앱 프로그래밍
‘모두의 여행’ 앱 전체 소스 수록!
오픈 API활용 + 파이어베이스 + 구글 맵 + 광고 수익까지
크로스 플랫폼 모바일 앱 개발 입문하기
조준수 지음
이지스퍼블리싱
[제작 정보]
제작연도: 2021년
교열·검사: 실로암시각장애인복지회
검수: 국립장애인도서관
이 자료는 국립장애인도서관에서 시각장애인 등의 이용을 위해 데이지자료로 제작한 것입니다. 국립장애인도서관의 허락 없이 이 자료를 무단 복제, 배포 및 전송하거나 영리를 목적으로 사용할 경우 저작권법에 의하여 처벌 받습니다.
앞날개
오픈 API와 파이어베이스를 이용한 앱 개발부터 배포까지
이 책을 마치면 관광 정보 앱이 만들어져요!
지은이 조준수
조준수 님은 컴퓨터공학과를 졸업한 뒤 헬스케어, 보안, 엔터테인먼트 등 다양한 분야에서 모바일 앱을 개발했다. 지금은 캐롯 손해보험에서 안드로이드와 iOS 앱을 개발하며 신규 서비스 기획 및 개발도 담당하고 있다. 신기술을 적용해 보고 공유하는 것을 즐겨 시간이 날 때마다 스택오버플로에서 개발 이슈에 답변을 달고 있다. 플러터로 다양한 플랫폼의 서비스를 시험해 보고 만드는 데 관심이 많다.
? 깃허브: github.com/rollcake86
? 이메일: rollcakeflutter@gmail.com
이지스퍼블리싱은 사람들에게 ‘구체적으로 도움이 되는 책’을 만듭니다.
? 홈페이지 www.easyspub.co.kr
? 페이스북 www.facebook.com/easyspub
? Do it! 스터디룸 cafe.naver.com/doitstudyroom
표지디자인 트인글터
1
세상의 속도를 따라잡고 싶다면 Do it!
실전 코드로 배우는 플러터 기본과 활용법
플러터 앱 프로그래밍
‘모두의 여행’ 앱 전체 소스 수록!
오픈 API활용 + 파이어베이스 + 구글 맵 + 광고 수익까지
크로스 플랫폼 모바일 앱 개발 입문하기
조준수 지음
이지스퍼블리싱
2
판권지
오픈 API와 파이어베이스를 이용한 앱 개발부터 배포까지
이 책을 마치면 관광 정보 앱이 만들어져요!
지은이 조준수(rollcakeflutter@gmail.com)
조준수 님은 컴퓨터공학과를 졸업한 뒤 헬스케어, 보안, 엔터테인먼트 등 다양한 분야에서 모바일 앱을 개발했다. 지금은 캐롯손해보험에서 안드로이드와 iOS 앱을 개발하며 신규 서비스 기획 및 개발도 담당하고 있다. 신기술을 적용해 보고 공유하는 것을 즐겨 시간이 날 때마다 스택오버플로에서 개발 이슈에 답변을 달고 있다. 플러터로 다양한 플랫폼의 서비스를 시험해 보고 만드는 데 관심이 많다.
? 깃허브: github.com/rollcake86
? 이메일: rollcakeflutter@gmail.com

Do it!
실전 코드로 배우는 플러터 기본과 활용법!
플러터 앱 프로그래밍
오픈 API 활용 + 파이어베이스 + 구글 맵 + 광고 수익까지
전자책 1쇄 발행 2021년 02월 23일 (종이책 초판 1쇄 기준)
지은이: 조준수
펴낸이: 이지연
펴낸곳: 이지스퍼블리싱(주)
출판사: 등록번호 제313-2010-123호
주소: 서울특별시 마포구 잔다리로 109 이지스빌딩 4층(우편번호 04003)
대표전화: 02-325-1722
팩스: 02-326-1723
홈페이지: www.easyspub.co.kr
페이스북: www.facebook.com/easyspub
Do it! 스터디룸 카페: cafe.naver.com/doitstudyroom
이메일: service@easyspub.co.kr
기획 및 편집: 이인호(inho@easyspub.co.kr), 김영준
교정교열: 안동현, 박명희
베타테스터: 김은숙, 안동현
표지 및 본문 디자인: 트인글터
인쇄: 보광문화사
마케팅: 박정현, 한송이
독자지원: 오경신
영업 및 교재 문의: 이주동, 이나리(ri7951@easyspub.co.kr)
? 잘못된 책은 구입한 서점에서 바꿔 드립니다.
? 이 책에 실린 모든 내용, 디자인, 이미지, 편집 구성의 저작권은 이지스퍼블리싱(주)와 지은이에게 있습니다.
? 이 책은 허락 없이 복제할 수 없습니다. 혹시 이 책이 무단 게재되거나 스캔본이 유통되는 경우 출판사나 한국저작권보호원에 신고해 저작권자과 출판권자를 보호해 주십시오.
(한국저작권보호원 불법복제 신고 전화 1588-0910, https://www.copy112.or.kr)
전자책 ISBN 979-11-6303-227-4 15000
전자책 가격 20,000원 (종이책 가격 30,000원)
3
오랫동안 꿈을 그리는 사람은 마침내 그 꿈을 닮아 간다.(Man who has had a dream for a long time will finally get looked like the dream.) - 앙드레 말로(Andre Malraux)
4
머리말
‘내 생애 첫 번째 앱 만들기’에 도전해 보세요!
복잡한 설정, 어려운 코딩, 화려한 디자인이 없어도 앱을 만들 수 있어요
스마트폰이 세상에 나온 지 10년이 훌쩍 넘었습니다. 그동안 개발자들은 안드로이드폰과 아이폰이라는 두 플랫폼에서 서로 다른 방식으로 앱을 만들어 출시해 왔죠. 그런데 플러터가 등장하면서 이제는 다양한 플랫폼에서 실행되는 앱을 더 간편하게 개발할 수 있게 되었습니다. 개발과 유지·보수에 드는 비용을 절감할 수 있는 획기적인 변화가 시작된 것이죠.
플러터의 등장은 기존의 앱 개발자뿐만 아니라 기획자나 디자이너, 학생과 일반인도 “나도 앱을 만들 수 있겠구나!”라는 희망을 품게 해주었습니다. 그러나 플러터는 발표된 지 얼마 안 된 새내기 프레임워크라서 국내에는 아직 자료와 도움말이 충분하지 않습니다. 이러한 상황에서 누구나 쉽게 플러터를 즐길 수 있고 책을 마칠 때쯤엔 제법 그럴싸한 앱을 만들어 볼 수 있었으면 좋겠다는 바람으로 이 책을 집필했습니다.
책을 마치면 관광 정보 앱이 만들어지는 플러터 실습서
이 책은 플러터의 기초부터 고급 활용법까지 다루어 다양한 영역에서 실용적으로 앱을 만드는 방법을 소개합니다. 특별히 HTTP 통신이나 네이티브 소스와 연동하는 방법, 파이어베이스를 이용해 서버 없이 데이터를 저장하거나 불러오고, 앱 사용자 분석, 푸시 알림을 보내는 방법도 다룹니다. 그뿐만 아니라 내가 만든 앱에 광고를 삽입해 수익을 얻을 수 있는 방법까지 소개합니다. 그리고 마지막에는 이 책에서 다룬 기술을 응용해 ‘모두의 여행’이라는 관광 정보 앱을 만듭니다. 이때 한국관광공사가 제공하는 공공 데이터를 이용하는 법까지 다뤄 누구나 양질의 데이터로 쓸 만한 앱을 만들어 볼 수 있도록 했습니다.
복잡한 코딩 없이 고급 기능을 이용해 보세요
이 책에서는 플러터가 제공하는 공식 라이브러리뿐만 아니라 플러터 개발자들이 많이 사용하는 패키지를 이용해 앱을 만듭니다. 훌륭한 개발자들이 미리 만들어 놓은 패키지를 이용하면 복잡한 로직을 신경 쓸 필요 없이 안정되고 고급스러운 기술을 빠르게 구현할 수 있습니다. 패키지 사용법은 한번 배워 두면 이후에 플러터 생태계가 지금보다 확장했을 때 새로운 패키지를 적용해 더 멋진 앱을 만들 수도 있습니다.
누구나 모바일 앱을 만드는 세상을 꿈꾸며
이 책은 프로그래밍 지식이 없어도 주어진 소스와 해설만으로 앱을 쉽게 만들 수 있도록 구성했습니다. 만약 프로그래밍 기초 지식이 있다면 이 책의 소스를 응용해 자신이 원하는 앱을 완성할 수도 있습니다.
5
이 책에서 요구하는 프로그래밍 지식은 이전에 프로그래밍 언어를 배운 적이 있거나 관련 서적을 1권 정도 읽어 보았다면 충분합니다. 만약, 프로그래밍 언어를 한번도 배운 적이 없거나 기초 지식이 부족하다고 생각한다면 자바나 앱 개발 입문서를 함께 보는 것도 좋습니다.
Do it! 시리즈로 개발자가 된 저처럼 여러분도 개발자가 될 수 있어요
학창 시절 저는 만들기를 좋아해 컴퓨터공학과에 진학했지만 졸업 때까지 아무런 준비 없이 지내다가 지인과 함께 작은 사업을 시작했습니다. 개발과는 동떨어진 일을 하면서 학생 때 공부하지 않은 것을 후회하며 열심히 일만 했죠. 그러던 어느 날 회사가 망하고 생각할 여유가 생겼을 때 처진 달팽이의 〈말하는 대로〉를 듣게 되었습니다.
그때 내가 진짜로 좋아하는 게 무엇인지 다시 생각해 보았습니다. 무엇인가를 만들어서 사람들에게 보여 주고, 내가 만든 것을 사람들이 사용하는 것에 기쁨을 느끼는 자신을 발견했습니다. 그래서 다시 프로그래밍을 시작했습니다. 하지만 처음에는 저를 뽑아 주는 곳이 없어서 책 한 권을 완독하고 다시 도전해 보기로 마음먹었죠. 그때 처음 본 책이 이지스퍼블리싱의 Do it! 시리즈였습니다. 몇 권의 책을 완독하고 열심히 이력서를 작성했던 기억이 납니다. 이후로 여러 회사에서 헬스케어, 엔터테인먼트, 뉴스, 블루투스, 블록체인 관련 앱까지 만들면서 점점 더 모바일 앱 개발에 흥미를 느끼게 되었습니다. 독자 여러분 중에도 지금 무엇을 해야 할지, 어떻게 해야 할지 고민하는 분도 있겠지요. 그런 분들에게 이 책이 모바일 앱 개발이라는 새로운 도전에 용기를 줄 수 있었으면 좋겠습니다.
방황할 때 마음을 위로해 주신 하나님께 감사를 드립니다. 그리고 사랑하는 아내와 항상 힘이 되어 준 아들 윤이에게 감사합니다. 또한 독자의 시선으로 피드백을 해준 이인호, 김영준 편집자와 이지스퍼블리싱 출판사에 감사의 마음을 전합니다. 마지막으로 이 책의 모든 독자 여러분께 감사드리고 따뜻한 응원을 보냅니다. 이 책과 함께할 새로운 걸음에 행복한 일이 가득하길 기도합니다.
조준수 드림(rollcakeflutter@gmail.com)
6
이 책의 구성
이 책은 다음 순서로 구성돼 있어요
[첫째마당: 헬로 플러터]
플러터가 무엇인지 알아보고 개발 환경을 준비합니다. 다트 언어는 핵심 내용만 빠르게 살펴보고 플러터 프로젝트의 구조와 모바일 앱 개발을 이해하는 데 필수인 생명주기를 다룹니다.
[둘째마당: 플러터 핵심 기능 배우기]
플러터가 제공하는 기본적인 위젯을 다룹니다. 이 위젯들을 조립함으로써 앱을 개발할 수 있습니다. 이때 구글의 머티리얼 스타일과 애플의 쿠퍼티노 스타일로 앱을 만들어 봅니다. 또한, 네트워크 통신과 화면 이동을 알아봅니다.
[셋째마당: 플러터 고급 기능 배우기]
데이터가 사라지지 않도록 내부 저장소, 데이터베이스 등에 저장하고 불러오는 방법을 다룹니다. 또한, 애니메이션으로 역동적인 앱을 만들고 네이티브 소스와 통신하는 법, 파이어베이스와 광고를 넣는 법도 다룹니다.
[넷째마당: 플러터 앱 만들고 출시하기]
여행 정보를 제공하는 공공 데이터를 이용해 ‘모두의 여행’ 앱을 만듭니다. 그리고 구글 플레이 스토어에 앱을 출시하는 과정을 살펴봅니다.
이 책에서 만드는 앱 미리 보기
[그림]


계산기, 동물 목록, 도서 목록(카카오 API 활용), 모두의 여행(공공 데이터, 구글 맵 활용) 외에 다양한 앱을 만들어요
[그림 끝]
7
실습하는 방법
QR코드로 소스 파일을 확인하거나 저장소에서 내려받을 수 있어요
이 책에서는 90개가 넘는 실습을 통해 플러터의 다양한 기능을 체험할 수 있습니다. 각 실습은 책에서 소개하는 단계에 따라 소스를 직접 작성해 보면서 진행하는 것이 좋습니다. 다만, 소스의 전체 구조를 파악하고 싶거나 작성된 소스를 활용하고 싶다면 필자가 제공하는 프로젝트별 소스 파일을 참고하기 바랍니다.
프로젝트별 소스 파일은 각 프로젝트를 시작하는 위치에 QR코드로 제공하므로 모바일을 이용해서 볼 수 있으며, 이 책에서 안내하는 저장소에서 전체를 내려받을 수도 있습니다. 이때 내려받은 소스 파일의 압축을 해제하면 장별로 폴더가 보입니다. 여기서 각 장의 폴더 안에 프로젝트 폴더를 열면 오른쪽 그림처럼 구성돼 있습니다. 이 책에서 작성하는 대부분의 다트 소스 파일은 lib 폴더에 있습니다.
[그림]


대부분의 다트 파일은 lib 폴더에 있어요.
[그림 끝]
내려받은 프로젝트를 실행할 때는 Pub get을 잊지 마세요
만약 내려받은 프로젝트를 바로 실행해 보고 싶다면 먼저 01장에서 소개하는 플러터 개발 환경을 준비해야 합니다. 그리고 안드로이드 스튜디오에서 해당 프로젝트 폴더를 열고 pubspec.yaml 파일을 연 다음, 반드시 편집 창 위에 보이는 <Pub get>을 눌러서 프로젝트에서 사용하는 패키지를 내려받아야 합니다. 또는 [Tools → Flutter → Flutter Pub Get] 메뉴를 실행해도 됩니다. 그다음 실행 버튼을 눌러야 앱이 제대로 빌드된 후 실행됩니다. 물론 앱을 실행할 에뮬레이터나 실제 기기가 열결되어 있어야 합니다.
[그림]


프로젝트 폴더를 통째로 내려받았다면 먼저 Pub get을 실행하세요.
[그림 끝]
개발 환경이 윈도우인지 맥인지에 따라서 실습 준비가 달라져요
플러터는 크로스 플랫폼 프레임워크이므로 안드로이드 앱과 iOS 앱을 똑같은 소스로 만들 수 있습니다. 그러나 이 책은 지면상 윈도우에서 안드로이드 앱 개발을 기준으로 설명합니다. 만약 맥과 엑스코드를 사용해 본 경험이 있다면 이 책에 담긴 똑같은 소스를 이용해 얼마든지 iOS 앱으로도 개발할 수 있습니다. iOS 앱을 개발하는 과정은 이 책의 학습 사이트인 ‘Do it! 스터디룸’에 올려 두었습니다.
? 윈도우에서 실습하는 경우
→ 안드로이드 앱만 개발 가능
: 안드로이드 스튜디오
: 플러터 SDK
: 안드로이드 스튜디오의 플러터와 다트 플러그인
: 안드로이드 앱 실행용 장치(에뮬레이터 또는 실물 안드로이드 기기)
? macOS에서 실습하는 경우
→ 안드로이드, iOS 앱 모두 개발 가능
: 안드로이드 스튜디오
: 플러터 SDK
: 안드로이드 스튜디오의 플러터와 다트 플러그인
: 안드로이드 앱 실행용 장치(에뮬레이터 또는 실물 안드로이드 기기)
: 엑스코드
: iOS 앱 실행용 장치(에뮬레이터 또는 실물 iOS 기기)
8
이렇게 공부해 보세요
궁금한 내용은 저자에게 질문해 보세요
책을 읽다가 도움이 필요하다면 다음 메일 주소로 저자에게 질문할 수 있습니다. 질문할 때는 책의 몇 쪽에서 어떤 점이 궁금한지 자세히 적어야 빠르게 답변받을 수 있습니다.
? 저자 이메일: rollcakeflutter@gmail.com
이 책의 소스 파일을 내려받으세요
이 책의 전체 실습 파일은 이지스퍼블리싱 홈페이지 자료실이나 저자의 깃허브 저장소에서 내려받을 수 있습니다.
? 이지스퍼블리싱 홈페이지: www.easyspub.co.kr/Main/PUB → [자료실] 클릭 후 도서명으로 검색
? 저자 깃허브: github.com/rollcake86
※ 이지스퍼블리싱 홈페이지에 회원 가입하면 매월 무료 전자책, 베타테스터 모집, 신간 소식 등 다양한 혜택을 누릴 수 있습니다.
[그림]


자료실: 도서를 검색하고 실습 파일을 내려받으세요.
[그림 끝]
‘Do it! 스터디룸’에서 함께 공부하고 책 선물도 받으세요!
이 책을 보는 친구들과 함께 공부해 보세요. 내가 이해하지 못한 내용은 동료들의 도움을 받고 내가 이해한 내용을 바탕으로 동료들을 도와준다면 복습하는 효과도 누릴 수 있습니다.
또 Do it! 스터디룸에서 운영하는 공부단에 지원해 보세요! 이 책의 스터디 노트를 쓰며 책을 완독하면 원하는 이지스퍼블리싱 책 한 권을 선물로 드립니다!
? Do it! 스터디룸 카페: cafe.naver.com/doitstudyroom
? Do it! 공부단 정보 : cafe.naver.com/doitstudyroom/6325
9
강의 진도표
도전! 16주 완성: 한 학기 강의용으로 16주 동안 계획을 세우고 학습을 진행해 보세요. 이전에 앱 개발 경험이 있다면 16일로 빠르게 진행할 수도 있습니다.
[표]
주

진행

완료 날짜

1주 차

01 플러터 시작하기

--/--

2주 차

02 다트를 알면 플러터가 보인다

--/--

3주 차

03 플러터 내부 구조 살펴보기

--/--

4주 차

04 플러터 위젯 사용법

--/--

5주 차

05 탭바와 리스트 만들기

--/--

6주 차

06 iOS 스타일로 플러터 앱 만들기

--/--

7주 차

07 네트워크를 이용해 통신하기

--/--

8주 차

08 내비게이션 활용하기

--/--

9주 차

09 내부 저장소 이용하기

--/--

10주 차

10 데이터베이스에 데이터 저장하기

--/--

11주 차

11 애니메이션 활용하기

--/--

12주 차

12 네이티브 API와 통신하기

--/--

13주 차

13 파이어베이스와 광고 수입 얻기

--/--

14주 차

14 오픈 API를 활용한 여행 정보 앱 만들기

--/--

15주 차

15 여행 정보 앱 완성하고 출시하기

--/--

16주 차

부족한 부분 보충하며 마무리

--/--

10
차례
첫째마당: 헬로 플러터
01 플러터 시작하기 14
01-1 플러터의 등장 배경 15
01-2 플러터가 주목받는 이유 19
01-3 개발 환경 준비하기 22
01-4 플러터 프로젝트 시작하기 29
02 다트를 알면 플러터가 보인다 38
02-1 카멜레온 같은 언어, 다트! 39
02-2 비동기 처리 방식 알아보기 43
02-3 JSON 데이터 주고받기 48
02-4 스트림 통신하기 50
02-5 도전! 다트 프로그램 만들기 53
둘째마당: 플러터 핵심 기능 배우기
03 플러터 내부 구조 살펴보기 57
03-1 플러터 프로젝트 구조 알아보기 58
03-2 위젯의 생명주기 이해하기 78
04 플러터 위젯 사용법 86
04-1 스캐폴드를 이용한 머티리얼 디자인 적용 87
04-2 이미지와 폰트 추가하기 96
04-3 사용자와 상호작용하는 앱 만들기 104
05 탭바와 리스트 만들기 115
05-1 탭바로 화면 이동하기 116
05-2 목록을 보여주는 리스트뷰 만들기 123
11
06 iOS 스타일로 플러터 앱 만들기 144
06-1 쿠퍼티노 위젯으로 동물 소개 앱 만들기 145
06-2 쿠퍼티노 위젯으로 동물 추가 화면 만들기 154
06-3 그 밖의 쿠퍼티노 위젯 163
07 네트워크를 이용해 통신하기 169
07-1 카카오 API를 이용해 책 정보 받아오기 170
07-2 이미지 파일 내려받기 190
08 내비게이션 활용하기 201
08-1 내비게이션 이해하기 202
08-2 할 일을 기록하는 앱 만들기 209
셋째마당: 플러터 고급 기능 배우기
09 내부 저장소 이용하기 224
09-1 공유 환경설정에 데이터 저장하기 225
09-2 파일에 데이터 저장하기 230
10 데이터베이스에 데이터 저장하기 249
10-1 데이터베이스 만들기 250
10-2 데이터베이스에서 데이터 처리하기 257
10-3 질의문으로 추가 기능 만들기 272
11 애니메이션 활용하기 283
11-1 애니메이션 구현하기 284
11-2 나만의 인트로 화면 만들기 296
11-3 스크롤 시 역동적인 앱바 만들기 309
12
12 네이티브 API와 통신하기 319
12-1 안드로이드 네이티브와 통신하기 320
12-2 안드로이드 네이티브와 데이터 주고받기 331
13 파이어베이스와 광고 수입 얻기 343
13-1 파이어베이스 설정하기 344
13-2 애널리틱스 사용하기 351
13-3 데이터베이스를 이용한 메모장 앱 만들기 363
13-4 푸시 알림 보내기 378
13-5 앱에 광고를 넣어 수익화하기 385
넷째마당: 플러터 앱 만들고 출시하기
14 오픈 API를 활용한 여행 정보 앱 만들기 398
14-1 오픈 API 이용하기 399
14-2 여행 정보 앱 스케치하기 405
14-3 여행 정보 앱 프로젝트 시작하기 408
15 여행 정보 앱 완성하고 출시하기 423
15-1 메인 화면 만들기 424
15-2 상세보기 화면 만들기-구글 지도 넣기 439
15-3 즐겨찾기 화면 만들기 460
15-4 설정 화면 만들기 468
15-5 구글 플레이에 앱 출시하기 479
찾아보기 490
* 이 책의 제작자 주: 취소선이 그어진 문장은 벌린 대괄호로 표시함.
13
첫째마당: 헬로 플러터
플러터를 시작한 여러분을 환영합니다. 첫 번째 마당에서는 플러터 앱을 본격적으로 개발하기 전에 알아야 할 기본적인 내용을 다룹니다. 플러터는 어떤 배경에서 등장했는지, 왜 주목받는지, 그리고 실습 환경을 구축하고 플러터 앱을 개발하는 데 사용하는 다트 언어의 기본적인 문법도 다룹니다. 그럼 시작해 볼까요?
01 플러터 시작하기
02 다트를 알면 플러터가 보인다
03 플러터 내부 구조 살펴보기
14
01 플러터 시작하기
플러터는 왜 등장했고 어떤 특징이 있는 걸까요? 다른 프레임워크와 비교하면서 플러터만의 매력을 발견해 봅시다. 플러터가 만들어진 이유와 특징을 살펴본 후 실습을 위한 개발 환경도 준비하겠습니다.
01-1 플러터의 등장 배경
01-2 플러터가 주목받는 이유
01-3 개발 환경 준비하기
01-4 플러터 프로젝트 시작하기
15
01-1 플러터의 등장 배경
2007년 애플의 아이폰이 등장한 이후 스마트폰은 끊임없이 발전하고 있습니다. 애플은 iOS 운영체제를 발표하면서 오브젝티브-C(Objective-C)로 만든 아이폰용 앱을 출시할 수 있는 앱스토어를 만들었습니다. 그로부터 1년 뒤 구글도 안드로이드 운영체제를 발표하면서 자바(Java)를 사용해 안드로이드용 앱을 판매할 수 있는 구글 플레이[각주*]를 만들었습니다.
[각주*] 2008년까지는 ‘안드로이드 마켓’으로 부르다가 2012년에 ‘구글 플레이’로 이름을 바꿨어요.[각주 끝]
다양한 기업이 잇따라 이 싸움에 뛰어들었지만 10년이 훨씬 지난 지금도 안드로이드와 iOS의 점유율이 거의 100%라고 해도 과언이 아닐 정도로 두 플랫폼이 모바일 시장을 장악하고 있습니다.
[그림 1-1] 연도별 모바일 운영체제 시장 점유율(netmarketshare.com)


가로축: 2018-08~2020-07
세로축: 0, 20, 40, 60, 80
2020-07
Android: Share: 70.04%
iOS: Share: 29.73%
Series 40: Share: 0.02%
Unknown: Share: 0.15%
[그림 끝]
애플과 구글은 각자의 앱 개발 생태계를 확장하려는 목적으로 새로운 언어를 내놓았습니다. 애플은 오브젝티브-C 대신에 스위프트(Swift)라는 언어를 만들었고, 구글은 코틀린(Kotlin)이라는 새로운 언어로 자바를 대체하려고 합니다. 새롭게 등장한 두 언어는 지금도 계속 진화하면서 앱 개발 환경을 더 나은 방향으로 이끌고 있습니다. 오브젝티브-C나 스위프트로 iOS 앱을 개발하거나 자바나 코틀린으로 안드로이드 앱을 개발하는 것처럼 각 모바일 운영체제에 맞는 언어로 개발한 앱을 네이티브 앱(native apps)이라고 합니다.
웹앱, 하이브리드 앱의 등장
두 회사가 시장을 나눠 먹는 사이 개발자들은 더 많은 사용자가 앱을 사용하게 하려고 똑같은 앱을 iOS용과 안드로이드용으로 두 번 개발해야 했습니다. 개발자에게는 조금 피곤한 상황이었죠. 그래서 “하나의 소스로 안드로이드와 iOS 모두에서 실행할 수 있는 방법이 없을까?”를 고민했고, 그 결과로 웹앱과 하이브리드 앱이 등장했습니다.
16
웹앱(web apps)은 웹 기술을 이용해서 만든 앱입니다. 앱의 화면을 나타내는 뷰(view)를 모바일용 웹으로 만들어서 다양한 기종과 해상도에 대응하며 빠르게 개발할 수 있습니다. 요즘은 네이티브 앱처럼 알림도 보내고 오프라인에서도 동작하는 프로그레시브 웹앱(progressive web apps, PWA)도 주목받고 있습니다. 그리고 하이브리드 앱(hybride apps)은 웹앱을 만든 후 별도의 프레임워크를 이용해 운영체제별로 동작하는 앱을 만드는 기술입니다.
하지만 이러한 기술로 만든 앱은 네이티브 앱과 비교해 상대적으로 속도가 느리고 애니메이션 사용에도 제약이 있는 등 스마트폰의 성능을 충분히 활용할 수 없었습니다. 이때 리액트 네이티브가 등장했습니다.
리액트 네이티브와 플러터
페이스북에서 만든 리액트 네이티브(React Native)는 여러 운영체제에서 동작하는 앱을 개발할 수 있는 크로스 플랫폼 앱 개발 프레임워크입니다. 특히 웹 개발자에게 익숙한 자바스크립트를 사용하므로 웹 개발자가 새로운 언어를 배우지 않고서도 앱을 개발할 수 있는 길을 터주었습니다. 또한 네이티브 언어로 앱을 개발할 때는 사용자 인터페이스(UI, user interface)를 변경할 때마다 다시 빌드해야 했지만, 리액트 네이티브는 코드를 변경하면 화면에 바로 표시되므로 개발 효율도 좋습니다.
리액트 네이티브에서는 자바스크립트가 다리 역할을 하면서 안드로이드나 iOS의 네이티브 API에 접근합니다. 똑같은 자바스크립트 코드가 안드로이드와 iOS처럼 각기 다른 운영체제에서 실행되게 연결해 주는 거죠. 따라서 웹앱이나 하이브리드 앱보다는 속도가 빠르지만 화면에 표시할 내용이 많으면 느려질 수 있습니다. 그리고 운영체제가 업데이트되면 디자인이 의도한 바와 달라질 수 있습니다. 무엇보다 리액트 네이티브는 스크립트 언어에 익숙하지 않은 안드로이드나 iOS 개발자가 배우려면 시간이 오래 걸릴 수 있습니다.
반면에 플러터(Flutter)는 똑같이 크로스 플랫폼 앱 개발 프레임워크지만 구글에서 만든 다트(Dart)라는 언어를 사용합니다. 따라서 자바나 C# 같은 컴파일 언어가 가진 특징을 활용해 앱을 개발할 수 있습니다.
플러터는 크게 프레임워크와 엔진, 임베더 계층으로 구성돼 있습니다. 프레임워크 계층에는 다트 언어로 개발된 여러 가지 클래스가 있으며 이러한 클래스를 이용해 앱을 개발합니다. 그리고 엔진 계층은 플러터의 코어를 담당하는데 대부분 C와 C++ 언어로 만들어졌습니다. 여기서는 데이터 통신, 다트 컴파일, 렌더링, 그리고 시스템 이벤트 등을 처리합니다.
17
[그림 1-2] 플러터 프레임워크의 계층


프레임워크/Dart: Material, Cupertino, Widgets, Rendering, Animation, Painting, Gestures, Foundation
엔진/C/C++: Service Protocol, Composition, Platform Channels, Dart Isolate Setup, Rendering, System Events, Dart Runtime Mgmt, Frame Scheduling, Asset Resolution, Frame Pipelining, Text Layout
임베더/Platform-specific: Render Surface Setup, Native Plugins, App Packaging, Thread Setup, Event Loop Interop
[그림 끝]
마지막으로 임베더 계층에는 플러터 앱이 크로스 플랫폼에서 동작하도록 플러터 엔진이 렌더링한 결과를 플랫폼별 네이티브 언어로 뷰를 만들어 화면에 보여줍니다. 안드로이드 앱은 자바와 C, C++ 언어로 만들고, iOS 앱은 오브젝티브-C와 오브젝티브-C++ 언어로 만듭니다. 그리고 리눅스와 윈도우 앱은 C++ 언어로 만듭니다. 따라서 다트 언어로 소스 파일만 작성하면 플러터의 각 계층을 거쳐 플랫폼별 앱을 개발할 수 있습니다. 이 가운데 내부적인 처리는 신경 쓰지 않고서 플러터나 다트 언어를 업데이트만 하면 됩니다.
다음 표에서는 리액트 네이티브와 플러터를 비교했습니다.
[표 1-1] 리액트 네이티브와 플러터 비교
구분

리액트 네이티브

플러터

개발 주체

페이스북

구글

언어

자바스크립트

다트

출시

2015년도

2017년도

성능

빠르지만 네이티브 앱만큼은 아님

네이티브 앱에 근접한 속도

학습 곡선

높음(네이티브 앱 개발자 기준)

낮음(네이티브 앱 개발자 기준)

대표 앱

페이스북, 인스타그램, 핀터레스트 등

알리바바, 구글 애드센스, 리플렉틀리 등

장점

? 저변이 넓은 자바스크립트 생태계
? 웹 개발자의 접근성
? npm으로 많은 패키지 이용 가능

? 다양한 위젯
? 강력한 애니메이션 성능
? 블루투스 등 네이티브 하드웨어와의 연결성

단점

? 기본 위젯이 부족해 커스텀해 사용
? 안드로이드/iOS 네이티브 위젯을 이용하기에 OS 판올림에 따른 업데이트 필요
? 블루투스 등 네이티브 커스텀해 통신하는 부분 개발이 어려움

? 플러터 SDK로 앱 크기가 큼(네이티브 대비)
? 아직 개발 생태계가 성숙하지 않아 빠른 피드백 얻기가 어려움
? 업데이트 주기가 빠름(분기별)

최종 목표

자바스크립트로 웹, 앱, 데스크톱 모든 플랫폼을 개발할 수 있는 통합 솔루션 개발

안드로이드, iOS, 웹, 윈도우 10 앱을 같은 코드로 개발할 수 있는 플랫폼 개발

18
플러터로 만들어진 앱 구경하기
플러터 공식 사이트에서는 미국의 부동산 웹 사이트 리얼터닷컴(realtor.com)과 중국의 웹 서비스 회사인 텐센트(Tencent) 등이 플러터로 개발한 앱을 서비스하고 있다고 안내합니다.
[그림 1-3] 플러터로 개발한 앱들(출처: flutter.dev)


[그림 끝]
그리고 국내 사례로는 KMPlayer라는 앱이 있습니다. KMPlayer는 판도라TV가 개발해 전 세계 누적 8억 다운로드를 달성한 동영상 플레이어로, 2020년 2월 5일 플러터로 만든 안드로이드와 iOS용 KMPlayer를 출시했습니다.
[그림 1-4] 플러터로 개발한 동영상 앱 KMPlayer(출처: 판도라TV)


KMPlayer
세상의 모든 동영상을 재생합니다
[그림 끝]
전 세계적으로 플러터 생태계가 계속 확장하고 있는 만큼 이 책이 출간될 즈음이면 더 많은 플러터 앱을 만날 수 있을 것입니다.
19
01-2 플러터가 주목받는 이유
이번 절에서는 플러터를 상징하는 대표적인 특징 3가지를 소개합니다. 이 3가지는 높은 개발 효율, 유연한 사용자 인터페이스, 그리고 네이티브 앱 못지않게 빠른 속도입니다.
하나, 높은 개발 효율
플러터를 이용하면 안드로이드와 iOS 앱을 동시에 개발할 수 있어서 효율적입니다. 이렇게 개발된 앱은 어떤 운영체제에서도 똑같은 사용자 인터페이스와 사용자 경험(UX, user experience)을 제공합니다. 또한, 플러터의 핫 리로드(hot reload) 기능은 소스 수정 후 번거로운 빌드 과정 없이 결과 화면에 바로 표시해 주므로 개발 시간을 줄일 수 있습니다.
둘, 유연한 사용자 인터페이스
역동적이면서도 유연한 사용자 인터페이스는 플러터의 큰 장점입니다. 다양한 위젯(widget)[각주*]을 제공하므로 사용자 맞춤형 앱을 쉽게 만들 수 있습니다. 만약 원하는 위젯이 없으면 선과 도형으로 직접 그려서 만들 수도 있습니다. 또한, 강력한 애니메이션 기능을 제공하여 복잡한 계산식 없이 적은 노력으로 만족스러운 사용자 경험을 줄 수 있습니다. 플러터의 위젯을 활용하면 iOS에서 구글의 머티리얼 디자인이 적용된 앱을 만들거나 반대로 안드로이드에서 iOS 스타일[각주**] 앱을 개발할 수도 있습니다.
[각주*] 위젯이란 앱을 구성하는 데 필요한 재료라고 생각하면 됩니다. 집을 지을 때 벽돌, 철근, 나무가 필요하듯이 앱도 다양한 위젯을 이용해 아름답게 만들 수 있어요.[각주 끝]
[각주**] 플러터에서는 iOS 스타일의 위젯을 쿠퍼티노(cupertino)라고 부릅니다.[각주 끝]
[그림 1-5] 안드로이드 앱에 표시한 iOS 스타일 위젯과 알림 창


Favorite Dessert
Please select the best desert from the options below.
Profiteroles / Cannolis / Trifle / Cancel
Allow “Maps” to access your location while you use the app?
Your current location will be displayed on the map and used for directions, nearby search results, and estimated travel times.
Don't Allow / Allow
[그림 끝]
20
셋, 빠른 속도
플러터는 전체 화면을 그릴 때 스키아(skia)[각주*] 엔진을 이용합니다. 예를 들어 배경은 노란색으로 하고 그 위에 아이콘을 그린다고 했을 때, 플러터는 노란색을 전체 화면에 칠한 다음 아이콘을 그리는 두 번의 작업을 한 번에 해서 초당 60프레임 이상의 속도로 화면을 갱신합니다. 이처럼 빠르고 자연스러운 화면 전환 덕분에 네이티브 앱과 속도 차이를 거의 느낄 수 없습니다.
[각주*] 스키아는 C++로 개발된 오픈소스 2D 그래픽 엔진으로 플러터뿐만 아니라 크롬, 안드로이드, 파이어폭스, 리브레오피스 등 다양한 플랫폼과 제품에서 사용되고 있습니다.[각주 끝]
플러터의 야망, 웹을 품다
구글은 연례 개발자 행사인 구글 I/O 2019에서 다트를 기반으로 만든 차세대 운영체제인 푸크시아(Fuchsia)를 공개적으로 언급했습니다. 그리고 플러터 SDK를 모바일 앱에서 웹으로 더욱 확장한다고 발표했습니다.
[그림 1-6] 플러터의 최종 목표


Flutter: Mobile, Web, Desktop, Embedded
[그림 끝]
플러터의 최종 목표는 플러터를 이용해 웹과 데스크톱 앱까지 만드는 것입니다. 아직 안정화 단계는 아니지만 플러터 깃허브(github.com/flutter)에서 웹과 데스크톱 앱도 테스트할 수 있습니다. 플러터는 리액트 네이티브보다 2년 늦은 2017년에 출시됐지만 성장 속도는 더욱 빠릅니다. 집필 시점에 상용 버전은 1.22.5까지 나왔습니다.
웹 개발자들은 특히 ‘웹을 품은 플러터’에 관심이 높습니다. 허밍버드(hummingbird)라 불리는 이 프로젝트는 플러터의 기본 라이브러리를 사용해 손쉽게 웹을 구현할 수 있습니다. 아직은 베타 버전이지만 정식 버전의 출시를 준비하고 있습니다.
21
[그림 1-7] 허밍버드를 이용해 만든 웹(github.com/GeekyAnts/flutter-web-admin-dashbaord)


[그림 끝]
지금까지 살펴본 바와 같이 플러터는 높은 개발 효율, 유연한 사용자 인터페이스, 그리고 네이티브 못지않게 빠른 속도의 앱을 개발할 수 있다는 매력을 앞세워 전 세계 많은 개발자로부터 주목받고 있습니다. 국내에서는 생소하게 느껴지는 다트라는 언어를 사용한다는 점, 개발을 돕는 플러그인이 아직은 부족하고 저변이 넓지 않다는 단점도 있습니다. 하지만 구글이 여러 가지 행보에서 플러터를 내세우고 있는 만큼 앞으로 더 많은 관심을 받을 것으로 생각합니다.
22
01-3 개발 환경 준비하기
플러터는 크로스 플랫폼 앱 개발 프레임워크인 만큼 같은 코드로 안드로이드와 iOS용 앱을 개발할 수 있습니다. 그러나 iOS용 앱은 애플의 macOS 운영체제에서만 실행할 수 있으므로 이 책은 어느 운영체제에서나 개발할 수 있는 안드로이드용 앱을 기준으로 플러터를 다룹니다. 지면상 macOS에서 엑스코드를 통해 iOS 앱을 개발하는 과정은 다루지 않지만 기존에 엑스코드를 사용해 본 경험이 있다면 이 책에 담긴 다트 소스를 활용해 iOS 앱도 충분히 개발할 수 있습니다.
따라서 이 책의 실습 환경은 윈도우[각주*]에서 안드로이드 앱을 개발하는 것에 맞추겠습니다. 안드로이드 앱을 개발하는 도구는 여러 가지가 있지만 가장 보편적인 안드로이드 스튜디오(Android Studio)에서 진행하겠습니다.
[각주*] macOS에서도 똑같이 안드로이드 스튜디오로 앱을 개발할 수 있지만 이 책에 담긴 실습 단계나 그림 일부가 다를 수 있습니다. 그러나 실습을 진행하는 데는 크게 무리가 없을 것입니다.[각주 끝]
[Do it! 실습] 안드로이드 스튜디오 설치하기
지금부터 안드로이드 스튜디오 설치를 시작으로 플러터 앱 개발 환경을 준비해 보겠습니다. 단계별로 천천히 따라 해보세요. 만약, 이미 안드로이드 스튜디오가 설치된 환경이라면 플러터 SDK를 설치하는 다음 단계로 건너뛰어도 좋습니다.
[1단계] 안드로이드 스튜디오 사이트(developer.android.com/studio)에 접속해서 <DOWNLOAD ANDROID STUDIO>를 클릭합니다. 안내 화면이 나타나면 약관에 동의한 후 설치 파일을 내려받습니다. 내려받기가 완료되면 설치 파일을 실행한 후[각주*] <Next>를 클릭해 설치를 시작합니다. 설치 과정은 모두 기본 사양에서 <Next>와 <Install> 등을 클릭해 진행합니다.
[각주*] 윈도우에서는 실행 과정에서 보완 관련 알림 창이 실행될 수 있으나 모두 <예>를 눌러 진행합니다.[각주 끝]
23
[그림 1-8] 안드로이드 스튜디오 설치


DOWNLOAD ANDROID STUDIO / Next
[그림 끝]
[2단계] 컴포넌트 선택과 설치 경로 등을 확인 후 <Next>를 클릭합니다. 혹시 C 드라이브가 아닌 다른 드라이브에 설치하고 싶다면 <Browse>를 클릭해 설치할 폴더를 변경합니다.
[그림 1-9] 컴포넌트 선택과 설치 경로 설정


Next / Next
[그림 끝]
[3단계] 시작 메뉴 폴더를 선택하고 <Install>을 클릭하면 설치를 시작합니다. 잠시 후 설치가 끝나면 <Next>를 누르고 설치 완료 화면에서 <Finish>를 누릅니다.
[그림 1-10] 폴더 이름 설정과 설치 완료 화면


Install / Finish
[그림 끝]
24
[4단계] 안드로이드 스튜디오를 처음 설치하면 다음과 같은 설정 마법사가 나타납니다. 차례대로 <Next>를 눌러 기본값으로 설정한 후 <Finish>를 눌러 설정을 마칩니다.
[그림 1-11] 안드로이드 스튜디오 설정 마법사


Next
[그림 끝]
[5단계] 잠시 후 다음과 같은 화면이 나오면 설치에 성공한 것입니다. 참고로 안드로이드 스튜디오를 작업 표시줄에 고정하거나 바로 가기를 만들어 바탕화면 등에 놓으면 다음에 편리하게 실행할 수 있습니다.
[그림 1-12] 안드로이드 스튜디오 시작 화면


작업 표시줄에 고정
[그림 끝]
25
[Do it! 실습] 플러터 SDK 설치하기
안드로이드 스튜디오를 설치했으니 이제 플러터 SDK를 설치해 보겠습니다. 플러터 SDK는 안드로이드 스튜디오에서 바로 설치할 수 있지만, 나중에 다른 도구를 이용해 개발하는 경우를 고려해 웹 사이트에서 내려받아 설치하는 방법으로 진행하겠습니다.
[1단계] 플러터 설치 사이트(flutter.dev/docs/get-started/install)에 접속한 후 플러터를 설치하려는 운영체제를 선택합니다. 이 책은 윈도우에서 실습하므로 [Windows]를 선택합니다.
[그림 1-13] 플러터 설치 사이트


Windows
[그림 끝]
[2단계] 이어지는 화면에서 ‘Get the Flutter SDK’라는 영역에 압축 파일을 내려받는 버튼이 보입니다. 이 버튼을 클릭하여 최신 버전의 안전한 플러터 SDK를 내려받습니다.
[그림 1-14] 플러터 SDK 설치 파일 내려받기


flutter_windows_1.22.3-stable.zip
[그림 끝]
26
[3단계] 내려받은 파일의 압축을 해제합니다. 이 책은 D:\에 압축을 해제했습니다. 그러면 flutter라는 디렉터리가 생성되고 그 안에 다음과 같은 파일이 생성됩니다.
[그림 1-15] 플러터 SDK가 설치된 flutter 폴더


[그림 끝]
[4단계] 플러터가 제대로 설치되었는지 확인하기 위해 플러터 SDK가 설치된 곳의 bin 디렉터리로 이동합니다. 명령 프롬프트[각주*]를 열고 다음 명령을 입력합니다.
[각주*] 명령 프롬프트는 윈도우 검색란에 ‘cmd’ 또는 ‘명령 프롬프트’를 입력 후 [Enter]를 눌러 실행합니다.[각주 끝]
[글상자]
> d:
> cd flutter\bin
[글상자 끝]
[5단계] bin 디렉터리에서 flutter doctor 명령을 실행합니다. 이 명령은 플러터 개발 환경을 점검합니다.
[그림 1-16] flutter doctor 실행 결과
명령 프롬프트
D:\flutter\bin>flutter doctor
Doctor summary (to see all details, run flutter doctor -v):
[√] Flutter (Channel stable, 1.20.2, on Microsoft Windows [Version 10.0.18363.1016], locale ko-KR)
[!] Android toolchain - develop for Android devices (Android SDK version 29.0.3)
! Some Android licenses not accepted. To resolve this, run: flutter doctor --android-licenses
[!] Android Studio (version 4.0)
X Flutter plugin not installed; this adds Flutter specific functionality.
X Dart plugin not installed; this adds Dart specific functionality.
[!] Connected device
No devices available
! Doctor found issues in 3 categories.
D:\flutter\bin>
[그림 끝]
27
두 번째 줄 Flutter 항목에 녹색으로 [√] 표시가 있으면 플러터가 제대로 설치된 것입니다. 그 아래는 플러터를 사용하는 데 필요한 도구들의 설치 현황을 나타내는데, 현재는 안드로이드 스튜디오만 설치한 상태이므로 셋 모두 노란색으로 [!]가 표시되었습니다. 이번 장을 마치면 설치한 항목들은 녹색 [√] 표시로 바뀔 것입니다.
[Do it! 실습] 플러터와 다트 플러그인 설치하기
안드로이드 스튜디오와 플러터 SDK를 설치했으면 그다음은 안드로이드 스튜디오에서 플러터 SDK를 인식하고 컴파일 후 실행할 수 있게 해주는 플러그인을 설치해야 합니다.
[1단계] 안드로이드 스튜디오를 실행하고 시작 화면에서 아래쪽에 [Configure]를 클릭한 후 [Plugins]를 선택합니다[각주*].
[각주*] 안드로이드 스튜디오 메뉴에서는 [File → Setting → Plugins]를 선택합니다.[각주 끝]
[그림 1-17] 안드로이드 스튜디오 플러그인 창 열기


Configure → Plugins
[그림 끝]
[2단계] 플러그인 창이 열리면 검색 창에 ‘flutter’를 입력해 플러터
플러그인을 찾은 후 <Install>을 클릭합니다.
[그림 1-18] 안드로이드 스튜디오 플러터 플러그인 설치


flutter, Install
[그림 끝]
28
[3단계] 그러면 다트 플러그인이 필요하다는 알림 창이 나옵니다. <Install>을 클릭해 다트 플러그인도 함께 설치합니다.
[그림 1-19] 플러터 플러그인 설치 시 다트 플러그인도 설치


Install
[그림 끝]
[4단계] 플러터와 다트 플러그인의 설치를 마치면 앞서 플러그인 창의 <Install>이 <Restart IDE>로 바뀝니다. 이 버튼을 클릭해 안드로이드 스튜디오를 다시 실행합니다. 그러면 다음처럼 [Create New Flutter Project] 메뉴가 나타납니다.
[그림 1-20] 플러터 프로젝트 생성 메뉴


[그림 끝]
지금까지 안드로이드 스튜디오에서 플러터 앱을 만드는 데 필요한 기본적인 준비를 마쳤습니다.
29
01-4 플러터 프로젝트 시작하기
이제 첫 번째 플러터 프로젝트를 시작해 봅시다. 플러터는 새 프로젝트를 시작하면 기본 구조를 갖춘 데모 앱을 만들어 줍니다. 이번 절에서는 플러터가 제공하는 데모 앱을 실행하면서 플러터와 친해져 봅시다.
[Do it! 실습] 플러터 프로젝트 만들기
[1단계] 안드로이드 스튜디오를 실행하고 시작 화면에서 [Create New Flutter Project]를 선택하면 다음처럼 4가지 옵션이 나옵니다. 우리는 앱을 만드는 것이 목표이므로 [Flutter Application]을 선택한 후 <Next>를 클릭합니다.
[그림 1-21] 플러터 프로젝트 생성 화면


(1) Fultter Application
(2) Next
[그림 끝]
[2단계] 다음 화면에서 프로젝트 이름(Project name)에 ‘first_flutter_app’이라고 입력합니다. 그리고 플러터 SDK 경로(Flutter SDK path)는 「01-3」절에서 압축 파일을 해제한 D:\flutter로 설정합니다. 그다음 프로젝트가 저장될 위치(Project location)와 간단한 설명(Description)을 적절하게 설정합니다. 필자는 D:\FlutterProject\FirstApp에 저장하도록 설정했으며, 프로젝트 설명은 기본값으로 두었습니다. 모두 입력했으면 <Next>를 클릭합니다.
30
[그림 1-22] 플러터 프로젝트 설정 화면


(1) first_flutter_app
(2) D:\flutter
(3) D:\FlutterProject\FirstApp
(4) A new Flutter application.
(5) Next
[그림 끝]
[3단계] 다음은 패키지 이름을 설정합니다. 패키지 이름은 보통 ‘도메인.회사명.프로젝트명’ 형식으로 작성합니다. 필자는 패키지 이름(Package name)에 ‘com.rollcake.flutterapp’이라고 입력했습니다. 나머지 설정은 그대로 두고 <Finish>를 클릭합니다.
[그림 1-23] 플러터 프로젝트 패키지 이름 설정 화면


(1) com.rollcake.flutterapp
(2) Finish
[그림 끝]
[4단계] 모든 설정을 마쳤으면 잠시 기다려 보세요. 다음과 같은 화면이 나타났나요? 축하합니다. 첫 번째 플러터 프로젝트를 완성했습니다.
31
[그림 1-24] 플러터 데모 프로젝트가 열린 안드로이드 스튜디오


[main.dart]
import 'package:flutter/material.dart';
viod main() {
runApp(MyApp());
}
class MyApp extends StatelessWidget {
// This widget is the root of your application.
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(
// This is the theme of your application.
//
[그림 끝]
안드로이드 스튜디오에서 프로젝트를 처음 열어 본 사람이라면 아직은 낯설고 복잡해 보여서 겁부터 날지도 모릅니다. 하지만 용기를 가지고 이 책을 따라 천천히 학습해 나가면 어느샌가 친근하게 느껴질 것입니다.
[Do it! 실습] 안드로이드 에뮬레이터로 앱 실행하기
에뮬레이터(emulator)란 앱을 실행할 수 있는 가상의 장치라고 생각하면 쉽습니다. 에뮬레이터를 사용하면 실제 스마트폰에서 실행하는 것처럼 컴퓨터에서 앱을 손쉽게 테스트할 수 있습니다. 다만, 안드로이드 스튜디오도 무거운 프로그램이어서 에뮬레이터까지 실행하면 컴퓨터가 꽤 느려질 수 있습니다. 이럴 때는 스마트폰을 USB 케이블로 컴퓨터에 연결해서 직접 테스트하면 됩니다. 이 책은 두 가지 방법을 모두 소개합니다. 먼저 에뮬레이터에서 앱을 실행하는 방법부터 실습하겠습니다.
* 제작자 주: 본문 내용 중 ‘안드로이드 가상 장치 관리자 아이콘’ 그림은 생략하고, [그림 1-25]에 나오는 아이콘 그림으로 대체함.
[1단계] 안드로이드 스튜디오에서 오른쪽 위에 있는 안드로이드 가상 장치 관리자(AVD Manager) 아이콘을 클릭합니다.
[그림 1-25] AVD Manager 아이콘


[그림 끝]
안드로이드 가상 장치 관리 화면이 나오면 중앙에 <Create Virtual Device>를 클릭해 새로운 장치를 생성합니다.
32
[그림 1-26] AVD 관리 화면


Create Virtual Device...
[그림 끝]
* 제작자 주: 본문 내용 중 ‘플레이 스토어 아이콘’ 그림은 생략하고, [그림 1-27]에 나오는 아이콘 그림으로 대체함.
[2단계] 하드웨어 선택 화면이 나타나면 원하는 안드로이드 장치를 선택합니다. 먼저 왼쪽 Category에서 Phone을 선택합니다. 그리고 오른쪽 목록에서 기종을 선택합니다. 이름 옆에 플레이 스토어 아이콘은 플레이 스토어를 이용해 앱을 설치할 수 있다는 의미입니다. 여기서는 최신 기종이면서 플레이 스토어에서 앱을 설치할 수 있는 Pixel 3을 선택합니다. 이어서 <Next>를 클릭합니다.
[그림 1-27] 안드로이드 가상 장치 선택 화면


(1) Phone
(2) Pixel 3 / (플레이 스토어 아이콘 그림) / 5.46" / 1080×21... / 440dpi
(3) Next
[그림 끝]
[3단계] 다음은 안드로이드 가상 장치에 설치할 시스템 이미지, 즉 안드로이드 SDK 버전을 선택합니다. 여기서는 집필 시점에 최신 버전인 R 버전을 설치하겠습니다. R 버전 옆에 Download 링크를 눌러 설치하고 설치를 마치면 R 버전을 선택한 상태로 <Next>를 클릭합니다.
33
[그림 1-28] SDK 선택 화면


Download
[그림 끝]
[4단계] 안드로이드 가상 장치 최종 설정을 확인하고 <Finish>를 클릭합니다.
[그림 1-29] 최종 설정 화면


Finish
[그림 끝]
[5단계] 이제 안드로이드 가상 장치를 만드는 모든 설정이 끝났습니다. AVD 관리자에서 Actions에 있는 실행 버튼(▶)을 누르면 에뮬레이터가 실행됩니다[각주*].
[각주*] 혹시 에뮬레이터에 바탕화면이 나타나지 않는다면 오른쪽에 있는 메뉴 중 전원 아이콘을 눌러서 기기를 켜세요.[각주 끝]
34
[그림 1-30] 에뮬레이터 실행 화면


바탕화면이 안 나오면 전원을 켜세요
[그림 끝]
[6단계] 안드로이드 스튜디오를 보면 앱을 실행할 장치를 선택하는 곳이 있습니다. 만약 장치가 연결되지 않았다면 이곳에 <no devices>라고 나옵니다. 이 단추를 클릭해 에뮬레이터나 실제 스마트폰을 선택하면 해당 기기로 연결됩니다. 여기서는 앞 단계에서 만든 Pixel 3 API 30을 선택합니다. 그러면 에뮬레이터가 실행됩니다.
[그림 1-31] 장치 선택


first_flutter_app - main_dart [first_flutter_app] - Android Studio
<no devices>, main.dart, Pixel 3 API 30
Open Android Emulator: Pixel 3 API 30
[그림 끝]
이제 오른쪽의 녹색 실행 버튼(▶)을 눌러서 플러터 데모 앱을 실행해 봅시다. 잠깐 기다리면 빌드가 끝나고 Pixel 3 에뮬레이터에 플러터 데모 앱이 실행됩니다. 이 앱에는 오른쪽 아래 <+> 버튼을 클릭하면 숫자가 올라가는 간단한 기능이 있습니다.
[그림] 실행 결과


Flutter Demo Home Page
You have pushed the button this many times: 0
[그림 끝]
35
[아하!] 에뮬레이터가 안 돼요!
에뮬레이터는 컴퓨터에서 바로 실행 결과를 확인할 수 있어서 편리하긴 하지만 컴퓨터 자원을 많이 차지해서 느립니다. 그리고 설치와 실행 과정에서 문제가 발생해 실행이 안 될 수도 있습니다. 이때는 다음 실습에서 소개하는 스마트폰을 직접 연결해서 실습을 진행하기 바랍니다.
에뮬레이터를 실행할 때 발생할 수 있는 이슈를 크게 3가지만 다뤄 보려고 합니다.
HAXM is not installed.
[그림 1-32] HAXM 설치


[그림 끝]
이 오류는 자신의 컴퓨터에 장착된 CPU에 따라 발생합니다. HAXM은 하드웨어 가속 기능입니다. 에뮬레이터 추가 중 시스템 이미지를 선택하는 화면에서 이 메시지가 보이면 <Install Haxm>을 눌러 설치합니다.
Enable VT-x in your BIOS security settings (refer to documentation for your computer).
[그림 1-33] VT-x 관련 오류


[그림 끝]
이 오류는 가상화 기술을 사용하지 않도록 설정했을 때 나타납니다. 컴퓨터에 장착된 CPU가 VT-x 기술을 지원하는지 확인하고, 만약 지원한다면 컴퓨터 부팅 때 BIOS 설정에 들어가서 해당 기능을 활성화(enable)합니다.
The emulator process for AVD Pixel_3_API_30 was killed.
[그림 1-34] 에뮬레이터 실행 오류


[그림 끝]
이 오류가 발생하면 메뉴에서 [Tools → SDK Manager]를 누르고 [SDK Tools] 탭에서 Android SDK Build-Tools, Android Emulator, Android SDK Platform-Tools를 체크 표시하고 <Apply>를 눌러 최신 버전으로 업데이트합니다. 또한, CPU가 AMD 계열이면 Android Emulator Hypervisor Driver를 설치하는 것이 좋습니다.
[아하! 끝]
36
[Do it! 실습] 실제 스마트폰에서 앱 실행하기
안드로이드 스튜디오의 에뮬레이터가 너무 느리다면 개발한 앱을 실제 스마트폰에 설치해서 실행할 수도 있습니다.
[1단계] 먼저 안드로이드 스마트폰을 준비합니다. 그리고 스마트폰에서 [설정]을 실행하고 [휴대전화 정보 → 소프트웨어 정보]를 선택합니다. 이어서 [빌드 번호]를 연속해서 5번 터치하면 잠시 후 개발자 모드가 활성화됩니다. 개발자 모드가 활성화되면 설정 메뉴 맨 아래에 [개발자 옵션]이 나타납니다. [개발자 옵션]으로 들어가 [USB 디버깅]을 사용한다고 체크합니다.
[그림 1-35] USB 디버깅 기능 활성화


빌드번호: QP1A.190711.020.N960NKSU3DTC4
개발자 옵션: 개발자 옵션
USB 디버깅: USB가 연결된 경우 디버그 모드 사용
[그림 끝]
[2단계] 스마트폰에 맞는 USB 드라이버가 필요합니다. 자신이 소유한 스마트폰의 제조사 홈페이지에서 해당 기종의 USB 드라이버를 내려받아 설치합니다.
[글상자]
? 삼성: local.sec.samsung.com/comLocal/support/down/kies_main.do?kind=usb
? LG: www.lge.co.kr/lgekor/download-center/downloadCenterList.do
[글상자 끝]
37
[그림 1-36] 제조사 홈페이지에서 USB 드라이버 내려받기


소프트웨어 다운로드
통합 USB 드라이버, 통합 USB 드라이버 설치방법
[그림 끝]
[3단계] 이제 안드로이드 스튜디오가 설치된 컴퓨터에 USB 케이블로 스마트폰을 연결하면 스마트폰 화면에 USB 디버깅 허용을 묻는 알림 창이 나타납니다. <확인>을 누르면 안드로이드 스튜디오의 에뮬레이터란에 스마트폰 기종의 이름이 나타납니다.
[그림 1-37] USB 디버깅 허용 메시지(왼쪽)와 연결된 기기 확인(오른쪽)


USB 디버깅을 허용하시겠습니까?
컴퓨터 RSA 키 지문: 2C:25:E6:94:AF:97:84:CD:D8:C7:02:9C:37:DB:AD:29
이 컴퓨터에서 항상 허용
취소 | 확인
SM N960N (mobile), main.dart
[그림 끝]
[4단계] 실제 스마트폰에서 앱을 실행해 보겠습니다. 앞에서 실습한 대로 main.dart 옆에 있는 실행 버튼(▶)을 누릅니다. 또는 메뉴에서 [Run → Run 'main.dart']를 눌러도 됩니다. 잠시 후 빌드가 끝나면 스마트폰에 앱이 설치되고 자동으로 실행됩니다.
[그림] 실행 결과


Flutter Demo Home Page
You have pushed the button this many times: 0
[그림 끝]
이로써 첫 번째 플러터 프로젝트를 만들고 실행까지 해봤습니다. 아직은 데모 앱을 실행해 본 수준이지만 앞으로 하나씩 배워 가면 여러분이 생각하는 앱을 만들 수 있을 것입니다.
38
02 다트를 알면 플러터가 보인다
플러터는 다트(Dart)라는 프로그래밍 언어로 개발됐습니다. 따라서 플러터를 사용하려면 다트라는 새로운 언어를 알아야 합니다. 조금은 두려울 수도 있습니다. 누구나 처음은 어려운 법이니까요. 그러나 다트 홈페이지에도 “자바나 C# 개발자라면 하루면 배울 수 있다.”라고 소개하는 것처럼 다트는 생각보다 어렵지 않은 언어입니다.
다트 언어의 철학은 “간단하게 배워서 다양한 플랫폼에 써먹자!”입니다. 지금 다트를 익혀 두면 모바일 앱뿐만 아니라 서버와 웹 프런트엔드, 데스크톱 앱을 만들 수도 있습니다.
다만, 이 책의 주제는 플러터이므로 다트를 전문적으로 다루지는 않고 프로그래밍 경험이 있는 독자를 대상으로 핵심적인 내용만 간략하게 다루도록 하겠습니다.
02-1 카멜레온 같은 언어, 다트!
02-2 비동기 처리 방식 알아보기
02-3 JSON 데이터 주고받기
02-4 스트림 통신하기
02-5 도전! 다트 프로그램 만들기
39
02-1 카멜레온 같은 언어, 다트!
다트는 구글이 웹 프런트엔드 구현을 목적으로 개발한 프로그래밍 언어로 2011년 10월에 공개되었습니다. 다트는 마치 카멜레온 같습니다. 카멜레온은 주변의 환경에 따라서 색이 바뀌는 동물이죠? 마찬가지로 다트는 어떻게 활용하느냐에 따라 서버나 웹, 앱을 만들 때 사용할 수 있습니다. 이번 절에서는 이러한 다트 언어의 특징을 살펴봅니다.
다트 언어의 8가지 특징
다트는 다른 언어와 비교해 8가지 두드러진 특징이 있습니다. 이 책은 다트를 중점으로 다루지 않지만 이러한 특징을 알면 다트를 배우고 플러터 앱을 만드는 데 큰 도움이 됩니다.
① 다트는 main() 함수로 시작합니다.
② 다트는 어디에서나 변수를 선언하고 사용할 수 있습니다.
③ 다트에서는 모든 변수가 객체입니다. 그리고 모든 객체는 Object 클래스를 상속받습니다.
④ 다트는 자료형이 엄격한 언어입니다. 이 말은 변수에 지정한 자료형과 다른 유형의 값을 저장하면 오류가 발생한다는 의미입니다. 만약 여러 자료형을 허용하려면 dynamic 타입을 이용할 수 있습니다.
⑤ 다트는 제네릭 타입을 이용해 개발할 수 있습니다. 그리고 List<int>처럼 int형을 넣을 수도 있고, List<dynamic>처럼 다양한 데이터를 넣을 수도 있습니다.
⑥ 다트는 public, protected 같은 키워드가 없습니다. 만약 외부로 노출하고 싶지 않다면 변수나 함수 이름 앞에 언더스코어(_)를 이용해 표시할 수 있습니다.
⑦ 변수나 함수의 시작은 언더스코어 또는 문자열로 시작하고 그 이후에 숫자를 입력할 수 있습니다.
⑧ 다트는 삼항 연산자를 사용할 수 있습니다. 다음 코드에서 첫 번째 줄을 보면 isPublic이 참이면 "public", 참이 아니면 "private"를 반환하여 visibility에 지정합니다. 두 번째 줄은 매개변수로 전달받은 name이 null이면 "Guest"를 반환하고, 아니면 매개변수로 전달 받은 값을 그대로 반환합니다.
40
[글상자] 다트의 삼항 연산자
var visibility = isPublic ? 'public' : 'private';
String playerName(String name) => name ?? 'Guest';
[글상자 끝]
간단한 코드로 다트의 특징 이해하기
다트로 만든 프로그램의 시작점은 자바나 C처럼 main() 함수입니다. 예로 작성한 간단한 코드를 보며 다트의 특징을 살펴보겠습니다[각주*].
[각주*] 간단한 다트 코드를 실행해 보려면 웹 브라우저에서 dartpad.dartlang.org 사이트를 이용하면 편리해요.[각주 끝]
[글상자] 다트 프로그램 예
// 함수 정의
printInteger(int aNumber) {
print('The number is $aNumber.'); // 콘솔에 출력
}
// main() 함수에서 시작
main() {
var number = 42; // 동적 타입 변수 지정
printInteger(number); // 함수 호출
}
[글상자 끝]
[글상자] 실행 결과
The number is 42.
[글상자 끝]
예에서 main() 함수의 내용을 살펴보면 먼저 number라는 이름의 변수를 하나 선언하고 숫자 42를 넣었습니다. 이때 var 키워드[각주*]는 자료형을 특정하지 않고 변수를 선언할 때 사용합니다. 만약, 자료형을 특정하고 싶다면 int, String, double 등 다트가 제공하는 자료형으로 선언합니다.
[각주*] var 키워드로 변수를 선언하면 해당 변수에 저장되는 값의 유형에 따라 자료형이 정해집니다. 이것을 자료형 추론(type inference)이라고 해요.[각주 끝]
41
그리고 number 변수를 인자로 printInteger() 함수를 호출합니다. printInteger() 함수는 int형 변수를 매개변수로 받아서 콘솔 화면에 출력하는 사용자 정의 함수입니다. 콘솔 화면에 출력하는 기능은 print()라는 다트의 내장 함수를 사용했습니다. 다트에서 문자열을 표현할 때는 큰따옴표나 작은따옴표를 이용하는데, 이때 따옴표 안에 ${표현식}과 같은 형태로 사용하면 표현식에 변수를 직접 넣을 수 있습니다.
다음은 다트 언어가 제공하는 주요 자료형을 나타낸 표입니다.
[표 2-1] 다트가 제공하는 주요 자료형
구분

자료형

설명

숫자

int

정수형 숫자. 예 (1, ?500, 0)

double

실수형 숫자. 예 (3.14, ?7.1)

num

정수형 또는 실수형 숫자

문자열

String

텍스트 기반 문자

불리언

bool

True나 False

자료형 추론

var

입력받은 값에 따라 자료형 결정. 한 번 결정된 자료형은 변경 불가

dynamic

입력받은 값에 따라 자료형 결정. 다른 변수 입력하면 자료형 변경 가능

다트가 제공하는 키워드
다트 언어가 제공하는 키워드를 살펴보면 생각보다 자바랑 많이 겹치는 것을 알 수 있습니다. 각 키워드에 대한 설명과 예시는 다트 개발자 사이트에 좀 더 자세히 나와 있습니다.
[표 2-2] 다트가 제공하는 키워드(https://dart.dev/guides/language/language-tour#keywords)
abstract

dynamic

implements

show

as

else

import

static

assert

enum

in

super

async

export

interface

switch

await

extends

is

sync

break

external

library

this

case

factory

mixin

throw

catch

false

new

true

class

final

null

try

const

finally

on

typedef

continue

for

operator

var

covariant

Function

part

void

42
default

get

rethrow

while

deferred

hide

return

with

do

if

set

yield

다트를 제대로 배우려면 키워드를 살펴보면서 개념을 이해하고 실습을 진행해 봐야겠지만, 이 책의 목적은 다트가 아니라 플러터이므로 앱을 개발하면서 그때그때 필요한 부분을 살펴보겠습니다.
그래도 다트 언어의 핵심은 맛보고 넘어가는 것이 좋겠죠? 플러터를 본격적으로 개발하기에 앞서 다트 언어가 제공하는 몇 가지 핵심 프로그래밍 기법을 소개합니다.
43
02-2 비동기 처리 방식 알아보기
다트는 비동기 처리를 지원하는 언어입니다. 비동기(asynchronous)란 언제 끝날지 모르는 작업을 기다리지 않고 다음 작업을 처리하게 하는 것을 의미합니다. 만약 비동기를 지원하지 않고 동기(synchronous)로만 처리한다면 어떤 작업이 오래 걸릴 경우 사용자는 실행이 멈춘 것으로 생각하고 프로그램을 종료할 수 있습니다. 일반적으로 네트워크에서 데이터를 가져오거나 데이터베이스 쓰기, 파일 읽기 등의 작업은 상황에 따라 언제 끝날지 알 수 없으므로 비동기로 처리합니다.
다음 그림에서 첫 번째는 작업을 순차적으로 처리하는 동기 방식을 표현한 그림이고, 두 번째는 어떤 작업이 끝나기를 기다리지 않고 다른 작업을 처리하는 비동기 방식을 표현했습니다.
[그림 2-1] 동기와 비동기 처리 방식 비교


동기 방식: 1 ~ 4
비동기 방식: 1, 2, 3, 4
[그림 끝]
비동기 프로세스의 작동 방식
다트는 async와 await 키워드를 이용해 비동기 처리를 구현합니다. 구현하는 방법은 다음과 같습니다.
(1) 함수 이름 뒤, 본문이 시작하는 중괄호 { 앞에 async 키워드를 붙여 비동기로 만든다.
(2) 비동기 함수 안에서 언제 끝날지 모르는 작업 앞에 await 키워드를 붙인다.
(3) 2번 작업을 마친 결과를 받기 위해 비동기 함수 이름 앞에 Future(값이 여러 개면 Stream) 클래스를 지정한다.
44
다음은 비동기 처리를 구현한 코드입니다. 천천히 읽고 출력 결과를 예측해 보세요.
[글상자] 비동기 처리 예
void main() {
checkVersion();
print('end process');
}
Future checkVersion() async {
var version = await lookUpVersion();
print(version);
}
int lookUpVersion() {
return 12;
}
[글상자 끝]
일반적인 생각으로 코드를 보면 main() 함수에서 제일 먼저 checkVersion() 함수를 호출했으므로 checkVersion() 함수에 있는 lookUpVersion() 함수가 호출되어 12를 전달받아 출력한 다음, 다시 main() 함수로 돌아와서 ‘end process’가 출력될 것 같습니다. 하지만 실제 출력 결과는 다음과 같습니다.
[글상자] 실행 결과
end process
12
[글상자 끝]
왜 이런 결과가 나올까요? 먼저 checkVersion() 함수를 보면 이름 앞뒤로 Future와 async가 붙었습니다. 이렇게 하면 checkVersion() 함수를 비동기로 만들겠다는 의미입니다. 즉, checkVersion() 함수 안에 await가 붙은 함수를 따로(비동기로) 처리한 다음 그 결과는 Future 클래스에 저장해 둘 테니 먼저 checkVersion() 함수를 호출한 main() 함수의 나머지 코드를 모두 실행하라(‘end process’ 출력)는 의미입니다. 그리고 main() 함수를 모두 실행했으면 그때 Future 클래스에 저장해 둔 결과를 이용해서 checkVersion() 함수의 나머지 코드를 실행합니다(‘12’ 출력).
앞선 코드에서 lookUpVersion() 함수 앞에 await 키워드가 붙었습니다. await 키워드는 처리를 완료하고 결과를 반환할 때까지 이후 코드의 처리를 멈춥니다. 따라서 lookUpVersion()
45
함수를 호출해 version 변수에 12가 저장된 다음에야 비로소 print(version) 문으로 이를 출력합니다. 이처럼 비동기 함수에서 어떤 결괏값이 필요하다면 해당 코드를 await로 지정합니다. 그러면 네트워크 지연 등으로 제대로 된 값을 반환받지 못한 채 이후 과정이 실행되는 것을 방지할 수 있습니다.
이러한 비동기 처리를 이용하면 지연이 발생하는 동안 애플리케이션이 멈춰 있지 않고 다른 동작을 하게 할 수 있습니다.
비동기 함수가 반환하는 값 활용하기
비동기 함수가 반환하는 값을 처리하려면 then() 함수를 이용합니다. 다음 코드를 살펴보겠습니다.
[글상자] then() 함수 사용법
void main() async {
await getVersionName().then((value) => {
print(value)
});
print('end process');
}
Future<String> getVersionName() async {
var versionName = await lookUpVersionName();
return versionName;
}
String lookUpVersionName() {
return 'Android Q';
}
[글상자 끝]
[글상자] 실행 결과
Android Q
end process
[글상자 끝]
코드를 보면 Future<String>이라는 반환값을 정해 놓은 getVersionName()이라는 함수가 있습니다. 이 함수는 async 키워드가 붙었으므로 비동기 함수입니다. 이처럼 비동기 함수가 데
46
이터를 성공적으로 반환하면 호출하는 쪽에서 then() 함수를 이용해 처리할 수 있습니다. then() 이외에 error() 함수도 이용할 수 있습니다. error() 함수는 실행 과정에서 오류가 발생했을 때 호출되므로 이를 이용해 예외를 처리할 수 있습니다.
다트와 스레드
다트는 하나의 스레드(thread)[각주*]로 동작하는 프로그래밍 언어입니다. 그래서 앞에서 살펴본 await 키워드를 잘 사용해야 합니다. 다음 코드를 살펴봅시다.
[각주*] 프로그램의 실행 흐름(갈래)을 의미합니다.[각주 끝]
[글상자] await 키워드 활용 예
void main() {
printOne();
printTwo();
printThree();
}
void printOne() {
print('One');
}
void printThree() {
print('Three');
}
void printTwo() async {
Future.delayed(Duration(seconds: 1), () {
print('Future!!');
});
print('Two');
}
[글상자 끝]
Future.delayed() 함수는 Duration 기간 동안 기다린 후에 진행하라는 의미입니다. 예의 코드는 1초 후에 진행하라는 의미입니다. Duration에는 분(minutes)이나 밀리초(milliseconds) 등 다양한 값을 넣을 수 있습니다.
이 코드의 실행 결과는 다음과 같습니다.
47
[글상자] 실행 결과
One
Two
Three
Future!!
[글상자 끝]
‘One’ 출력 이후에 printTwo() 함수에 진입하면 Future를 1초 지연했으므로 async로 정의한 비동기 함수의 특징에 따라 ‘Two’가 먼저 출력됩니다. 그리고 ‘Three’를 출력하고 ‘Future!!’가 가장 늦게 출력됩니다.
그럼 printTwo() 함수를 다음처럼 수정하면 어떻게 될까요?
[글상자]
(...생략...)
void printTwo() async {
await Future.delayed(Duration(seconds: 2), () {
print('Future Method');
});
print('Two');
}
[글상자 끝]
Future.delayed() 코드 앞에 await 키워드를 붙였으므로 이후 코드의 실행이 멈춥니다. 따라서 printTwo() 함수를 벗어나 main() 함수의 나머지 코드를 모두 실행하고, 그다음에 await가 붙은 코드부터 차례대로 실행합니다.
[글상자] 실행 결과
One
Three
Future Method
Two
[글상자 끝]
이처럼 await 키워드를 이용하면 await가 속한 함수를 호출한 쪽(예에서는 main() 함수)의 프로세스가 끝날 때까지 기다리기 때문에 이를 잘 고려해서 프로그램을 작성해야 합니다.
48
02-3 JSON 데이터 주고받기
애플리케이션을 개발하다 보면 서버와의 통신이 중요하다는 것을 알게 됩니다. 대부분 앱은 서버와 데이터를 주고받으며 상호 작용하고 화면에 필요한 데이터를 출력합니다. 이러한 데이터를 교환할 때 가장 많이 쓰는 형식이 JSON입니다. 직접 문자열 형태나 XML을 이용해 데이터를 주고받기도 하지만, 가장 편리하면서 파일 크기도 작은 JSON 형식을 주로 이용하는 거죠. 다트에서는 이러한 JSON 통신을 간편하게 이용할 수 있습니다.
JSON을 사용하려면 소스에 convert라는 라이브러리를 포함해야 합니다. 간단하게 JSON 형식의 문자열을 다루는 코드를 살펴보겠습니다.
[글상자] JSON 데이터 디코딩 예
import 'dart:convert';
void main() {
var jsonString = '''
[
{"score": 40},
{"score": 80}
]
''';
var scores = jsonDecode(jsonString);
print(scores is List); // true 출력
var firstScore = scores[0];
print(firstScore is Map); // true 출력
print(firstScore['score'] == 40); // true 출력
}
[글상자 끝]
이 코드에서 jsonString 변수에 저장된 데이터가 JSON 형태의 문자열입니다. 이 데이터를 convert 라이브러리에 있는 jsonDecode() 함수에 전달한 후 그 결과를 scores 변수에 저장 했습니다. jsonDecode() 함수는 JSON 형태의 데이터를 dynamic 형식의 리스트로 변환해서 반환해 줍니다. scores 변수가 리스트인지는 True/False로 점검할 수 있습니다. scores is
49
List 코드는 scores 변수가 리스트가 아니면 False를 표시하고 리스트이면 True를 반환합니다.
그리고 scores 리스트에서 첫 번째 값을 firstScore에 저장합니다. 이 값은 키(key)와 값(value)이 있는 Map 형태입니다. print(firstScore['score'] == 40) 코드는 firstScore 데이터의 score 키에 해당하는 값이 40이라는 것을 나타냅니다. 이처럼 jsonDecode() 함수를 이용하면 서버에서 JSON 데이터를 받아서 사용할 수 있습니다.
이제 애플리케이션에서 서버로 데이터를 보내는 예도 살펴보겠습니다. 이때는 jsonEncode() 함수를 이용해 JSON 형태로 변환한 데이터를 서버로 보낼 수 있습니다.
[글상자] JSON 데이터 인코딩 예
import 'dart:convert';
void main() {
var scores = [
{'score': 40},
{'score': 80},
{'score': 100, 'overtime': true, 'special_guest': null}
];
var jsonText = jsonEncode(scores);
print(jsonText ==
'[{"score":40},{"score":80},'
'{"score":100,"overtime":true,'
'"special_guest":null}]'); // true 출력
}
[글상자 끝]
scores 데이터는 배열로 이루어졌고 각 항목은 score값으로 구성되며 마지막 항목에는 overtime과 special_guest값을 추가했습니다. 혹시 앞의 코드와 다른 점이 보이나요? 앞의 코드에서는 {"score": 40}처럼 키에 큰따옴표를 사용해 JSON 데이터임을 표시했고, 지금 코드는 {'score': 40}처럼 작은따옴표를 이용해 변수임을 표시했습니다.
이 scores 데이터를 인자로 jsonEncode() 함수를 호출하면 키값이 큰따옴표로 묶이고 전체 데이터를 작은따옴표로 한 번 묶어서 JSON 형태의 데이터가 됩니다. 이처럼 다트는 간단하게 JSON을 만들고 파싱하여 데이터를 주고받는 기능을 제공합니다.
50
02-4 스트림 통신하기
애플리케이션을 개발하다 보면 데이터를 순서대로 주고받아야 할 때가 있습니다. 데이터를 순서대로 주고받을 것으로 생각해서 화면을 구성했는데 네트워크나 와이파이 연결이 끊기거나 특정 API 호출이 늦어져 순서가 달라지면 애플리케이션이 원하는 흐름대로 작동하지 않을 수도 있습니다.
이처럼 순서를 보장받고 싶을 때 스트림(stream)을 이용합니다. 스트림은 처음에 넣은 데이터가 꺼낼 때도 가장 먼저 나오는 데이터 구조로 생각할 수 있습니다. 따라서 스트림을 이용하면 데이터를 차례대로 주고받는 코드를 작성할 수 있습니다.
[글상자] 스트림 통신 예
import 'dart:async';
Future<int> sumStream(Stream<int> stream) async {
var sum = 0;
await for (var value in stream) {
print('sumStream : $value');
sum += value;
}
return sum;
}
Stream<int> countStream(int to) async* {
for (int i = 1; i <= to; i++) {
print('countStream : $i');
yield i;
}
}
main() async {
var stream = countStream(10);
var sum = await sumStream(stream);
print(sum); // 55
}
[글상자 끝]
51
main() 함수를 살펴보면 먼저 countStream(10) 함수를 호출합니다. 이 함수는 async*와 yield 키워드를 이용해 비동기 함수로 만들었습니다. 이 함수는 for 문을 이용해 1부터 int형 매개변수 to로 전달받은 숫자까지 반복합니다.
async* 명령어는 앞으로 yield를 이용해 지속적으로 데이터를 전달하겠다는 의미입니다. 위 코드에서 yield는 int형 i를 반환하는데, return은 한 번 반환하면 함수가 끝나지만 yield는 반환 후에도 계속 함수를 유지합니다.
이렇게 받은 yield값을 인자로 sumStream() 함수를 호출하면 이 값이 전달될 때마다 sum 변수에 누적해서 반환해 줍니다. 그리고 main() 함수에서 이 값을 받아서 출력하면 55가 나옵니다.
출력 결과를 보면 함수가 어떤 흐름으로 진행되는지 알 수 있습니다. 이처럼 스트림을 이용하면 데이터를 차례대로 받아서 처리할 수 있습니다.
[글상자] 실행 결과
countStream : 1
sumStream : 1
countStream : 2
sumStream : 2
(...생략...)
countStream : 9
sumStream : 9
countStream : 10
sumStream : 10
55
[글상자 끝]
아니면 다음처럼 then() 함수를 이용해 스트림 코드를 작성할 수도 있습니다. 다음 코드를 살펴보겠습니다.
[글상자] then() 함수를 활용한 스트림 예
main() {
var stream = Stream.fromIterable([1, 2, 3, 4, 5]);
// 가장 앞의 데이터 결과: 1
stream.first.then((value) => print('first: $value'));
// 가장 마지막 데이터의 결과: 5
stream.last.then((value) => print('last: $value'));
52
// 현재 스트림이 비어 있는지 확인: false
stream.isEmpty.then((value) => print('isEmpty: $value'));
// 전체 길이: 5
stream.length.then((value) => print('length: $value'));
}
[글상자 끝]
코드를 보면 Stream 클래스를 이용해 배열을 하나 만든 후 함수를 이용해서 값을 가져옵니다. 그런 다음 then() 함수로 가져다 사용합니다.
그런데 이 코드를 그대로 실행하면 오류가 발생합니다. 일단 스트림을 통해 데이터를 사용하면 데이터는 사라지기 때문입니다. 따라서 다음처럼 한 번만 실행하도록 변경해야 합니다.
[글상자] 스트림 오류를 해결한 코드
main() {
var stream = Stream.fromIterable([1, 2, 3, 4, 5]);
// 가장 마지막 데이터의 결과: 5
stream.last.then((value) => print('last: $value'));
}
[글상자 끝]
스트림은 실시간으로 서버를 살펴보다가 서버에서 데이터가 변경되면 화면을 새로 고침하지 않더라도 자동으로 변경된 데이터가 반영되어야 할 때 사용할 수 있는 유용한 클래스입니다. 아직은 익숙하지 않지만 하나씩 배워 가면서 익숙해지도록 해봅시다.
53
02-5 도전! 다트 프로그램 만들기
지금까지 다트 프로그래밍의 주요 기법에 관해 간략하게 살펴봤습니다. 이번에는 다트 언어로 간단한 프로그램을 구현해 보겠습니다. 3개의 문제를 함께 풀어 보면서 다트 프로그래밍에 첫발을 내디뎌 보겠습니다.
[Do it! 실습] 구구단 프로그램 작성하기
2~9단까지 구구단을 출력하는 프로그램을 작성해 봅시다. 먼저 책을 잠시 덮어 두고, 어떻게 풀면 좋을지 스스로 한번 코드를 작성해 보세요. 이 문제는 for 문을 중첩해서 풀 수 있습니다.
[글상자] 구구단 프로그램 예
void main() {
int i;
int j;
for (i = 2; i <= 9; i++) {
for (j = 1; j <= 9; j++) {
print('$i * $j = ${i * j}');
}
}
}
[글상자 끝]
[글상자] 실행 결과
2 * 1 = 2
2 * 2 = 4
(...생략...)
9 * 8 = 72
9 * 9 = 81
[글상자 끝]
54
[Do it! 실습] 자동차 클래스 구현하기
이번에는 자동차 클래스를 만들어 봅시다. 이 클래스는 다음과 같은 속성을 포함합니다.
[표 2-3] Car 클래스 속성
이름

자료형

의미

maxSpeed

int

최고 속도

price

num

가격

name

String

이름

Car 클래스 안에 saleCar()라는 이름으로 함수를 작성합니다. 이 함수는 자동차 가격을 10% 할인해서 반환합니다. 그리고 main() 함수에서 Car 클래스를 이용해 다음과 같은 속성값으로 3종류의 자동차를 선언합니다. 새로운 객체를 선언할 때 자바에서는 new라는 키워드를 사용하지만 다트는 생략할 수 있습니다. 물론 new를 사용해도 무방합니다.
[표 2-4] Car 객체의 속성값
maxSpeed

price

name

320

100000

BMW

250

70000

BENZ

200

80000

FORD

BMW를 3번 할인하는 함수를 호출한 뒤에 차량 가격을 출력해 보세요.
[글상자] 자동차 클래스 구현 예
void main() {
Car bmw = Car(320, 100000, 'BMW');
Car toyota = Car(250, 70000, 'BENZ');
Car ford = Car(200, 80000, 'FORD');
bmw.saleCar();
bmw.saleCar();
bmw.saleCar();
print(bmw.price);
}
55
class Car {
int maxSpeed;
num price;
String name;
Car(int maxSpeed, num price, String name) {
this.maxSpeed = maxSpeed;
this.price = price;
this.name = name;
}
int saleCar() {
price = price * 0.9;
return price;
}
}
[글상자 끝]
[글상자] 실행 결과
729000
[글상자 끝]
[Do it! 실습] 로또 번호 생성기 만들기
다트 언어로 로또 번호 생성기를 만들어 봅시다. 무작위 수를 생성하는 랜덤 함수를 이용하려면 dart:math 라이브러리를 사용해야 합니다.
as math 코드는 import한 dart:math 라이브러리를 math라는 이름으로 사용하겠다는 의미입니다. 이 math를 이용해 6개의 무작위 수를 만드는 로또 번호 생성기를 만들어 봅시다. 만약, 생성한 번호가 같을 때는 다시 생성합니다.
[글상자]
import 'dart:math' as math;
[글상자 끝]
56
[글상자] 로또 번호 생성기
import 'dart:collection';
import 'dart:math' as math;
void main() {
var rand = math.Random();
HashSet<int> lotteryNumber = HashSet();
while(lotteryNumber.length < 6) {
lotteryNumber.add(rand.nextInt(45));
}
print(lotteryNumber);
}
[글상자 끝]
[글상자] 실행 결과
{9, 11, 23, 24, 29, 42}
[글상자 끝]
HashSet를 사용하려면 dart:collection이라는 라이브러리를 import해야 합니다. Set는 중복을 허용하지 않는 리스트라고 보면 됩니다. while 문을 이용해 랜덤 숫자를 만들다가 6개의 중복되지 않는 무작위 수를 완성하면 출력하는 식으로 구현할 수 있습니다. 이 외에 다른 방법으로도 로또 번호 생성기를 만들 수 있습니다. 여러분이 작성한 코드도 정답이 될 수 있습니다.
57
03 플러터 내부 구조 살펴보기
플러터 프로젝트를 만들면 많은 파일과 폴더가 자동으로 생성됩니다. 이번 장에서는 이러한 플러터 프로젝트의 구성을 살펴보겠습니다. 그리고 플러터 앱 개발에서 핵심인 위젯과 생명주기를 알아보겠습니다. 가벼운 마음으로 첫 번째 플러터 앱을 만나 봅시다.
03-1 플러터 프로젝트 구조 알아보기
03-2 위젯의 생명주기 이해하기
58
03-1 플러터 프로젝트 구조 알아보기
플러터 프로젝트를 만들면 자동으로 많은 파일이 생성됩니다. 기본적으로 안드로이드용 앱과 iOS용 앱을 만드는 프로젝트 폴더가 각각 생성되고, 플러터 앱을 구현하는 소스 파일과 프로젝트 설정, 테스트 등을 수행하는 파일도 생성됩니다. 플러터 프로젝트를 구성하는 핵심적인 폴더와 파일을 살펴보고, 그중 메인 소스 파일의 구조도 살펴보겠습니다.
플러터 프로젝트 폴더는 어떻게 구성되었나?
안드로이드 스튜디오를 실행하고 01장에서 만들었던 first_flutter_app 프로젝트를 열어 보세요[각주*]. 그리고 왼쪽에 보이는 프로젝트 탐색 창을 살펴보면 다음과 같습니다.
[각주*] 안드로이드 스튜디오에서 기존 프로젝트를 열 때는 [File → Open]을 누릅니다. 그리고 프로젝트 선택 창에서 열고자 하는 프로젝트가 있는 폴더를 선택한 후 <OK>를 누릅니다.[각주 끝]
[그림 3-1] 플러터 프로젝터 구조


android [first_flutter_app_android]
ios
lib - main.dart
test - widget_test.dart
[그림 끝]
먼저 lib 폴더에는 플러터 앱의 소스가 작성된 main.dart 파일이 있습니다. 그리고 android와 ios 폴더에는 각 운영체제에서 프로젝트를 시작할 때 필요한 파일이 있습니다. test 폴더[각주*]에는 다트 코드로 함수를 테스트할 때 사용하는 파일이 있습니다.
[각주*] 일반적으로 함수를 테스트하려면 앱을 다시 실행해야 해서 시간이 걸리는데, 플러터 프로젝트는 test 폴더를 제공하므로 편리하게 테스트할 수 있습니다.[각주 끝]
59
이처럼 플러터 프로젝트는 많은 파일로 구성되지만 우선은 lib 폴더에만 집중하면 됩니다. build 폴더 등은 앱의 설정값을 바꾸면 자동으로 변경되므로 직접 수정하지 않아도 됩니다.
[표 3-1] 플러터 프로젝트 주요 폴더 소개
폴더

내용

비고

android

안드로이드 프로젝트 관련 파일

안드로이드 스튜디오로 실행 가능

ios

iOS 프로젝트 관련 파일

엑스코드로 실행 가능(맥 전용)

lib

플러터 앱 개발을 위한 다트 파일

플러터 SDK 설치 필요

test

플러터 앱 개발 중 테스트 파일

테스트 편의성 제공

루트에도 여러 파일이 있지만 여기서 주목할 파일은 pubspec.yaml입니다. pubspec.yaml 파일은 플러터에서 다양한 패키지와 이미지, 폰트 등을 사용할 수 있게 해줍니다. 앞으로 앱을 꾸미는 데 많이 사용할 것입니다.
[표 3-2] 루트 안 파일 소개
파일

내용

비고

pubspec.yaml

패키지, 이미지, 폰트 설정

직접 관리

README.md

프로젝트 소개

.gitignore

깃(git)에 커밋, 푸시 등 소스 코드를 업로드할 때 필요 없는 파일 기록

.metadada

Flutter SDK 정보

자동 관리

.packages

Flutter SDK에 사용하는 기본 패키지 경로

first_flutter_app.iml

파일이 자동으로 생성될 때 만들어지는 폴더 위치

pubspec.lock

pubspec.yaml 파일에 적용된 패키지 위치

플러터 메인 소스 파일은 어떻게 구성되었나?
이제 플러터 앱의 소스 파일을 살펴보겠습니다. 프로젝트 구성에서 lib 폴더를 보면 main.dart 파일이 있습니다. 이 파일은 플러터 프로젝트를 만들면 자동으로 생성됩니다. 그리고 다트 앱을 실행하면 이 파일 안에 있는 main() 함수부터 시작합니다. 처음 보는 낯선 코드가 길게 늘어져 있지만, 하나씩 살펴보면서 구조를 이해하는 데 집중해 봅시다.
60
[그림 3-2] 플러터 메인 구조


[main.dart]
import 'package:flutter/material.dart';
void main() {
runApp(MyApp());
}
class MyApp extends StatelessWidget {
// This widget is the root of your application.
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(
// This is the theme of your application.
//
[그림 끝]
import 구문
소스 첫 줄에는 import 구문이 있습니다. import는 해당 소스 파일에서 사용하려는 패키지를 불러올 때 사용하는 구문입니다. 자바의 import와 똑같습니다. 다른 다트 클래스나 pubspec.yaml 파일에서 내려받은 패키지를 불러올 때도 사용합니다.
[글상자] import 구문
import 'package:flutter/material.dart';
[글상자 끝]
기본 예제에서는 material.dart 패키지를 불러왔습니다. 이 패키지에는 플러터의 UI와 관련된 거의 모든 클래스가 포함되어 있어서 자주 사용합니다.
main() 함수
다음은 main() 함수입니다. 플러터 앱은 자바나 C 언어로 작성된 프로그램처럼 main() 함수에서 시작합니다.
[글상자] main() 함수
void main() {
runApp(MyApp());
}
[글상자 끝]
61
main() 함수에서는 runApp() 함수를 호출합니다. runApp() 함수는 binding.dart 클래스에 정의되어 있으며 플러터 앱을 시작하는 역할을 합니다. 이 함수에 플러터 앱을 시작하면서 화면에 표시할 위젯을 전달합니다. 예에서는 MyApp이라는 위젯을 전달했습니다.
[아하!] 위젯이 무엇인가요?
앱에서 위젯은 자동차 부품처럼 특정한 기능을 담당하면서 앱을 편리하고 아름답게 만드는 부품이라고 생각할 수 있습니다. 앱에서 위젯은 클래스로 구현하며 이를 상속받는 다양한 위젯이 있습니다. 예를 들어 Text 클래스는 글자를 전문적으로 표시하는 위젯이고, Image 클래스는 이미지를 전문적으로 표시하는 위젯, Button 클래스는 버튼을 표시하는 위젯입니다.
[아하! 끝]
MyApp 클래스
다음 코드는 main() 함수에서 runApp() 함수로 플러터 앱을 실행할 때 화면에 표시할 위젯으로 전달한 MyApp 클래스를 정의한 부분입니다.
[글상자] MyApp 클래스
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(
primarySwatch: Colors.blue,
visualDensity: VisualDensity.adaptivePlatformDensity,
),
home: MyHomePage(title: 'Flutter Demo Home Page'),
);
}
}
[글상자 끝]
62
[그림] 실행 결과


Flutter Demo Home Page
You have pushed the button this many times: 0
[그림 끝]
클래스 이름 뒤의 extends는 다트에서 상속을 의미하는 키워드입니다. 여기서는 Stateless Widget이라는 클래스를 상속받았는데 일단 상태가 변경되지 않는 위젯을 상속받았다고 생각하면 됩니다. 더 자세한 내용은 잠시 후에 설명합니다.
MyApp 클래스에서는 @override 애너테이션을 이용해서 build()라는 함수를 재정의했습니다. build() 함수에는 어떠한 위젯을 만들 것인지를 정의합니다. 처음 runApp()을 이용해 클래스를 실행할 때는 MaterialApp() 함수를 반환해야 합니다. MaterialApp은 그림을 그리는 데 필요한 도화지라고 생각하면 됩니다. MaterialApp() 함수에는 그림을 그리는 도구에 속하는 title, theme 그리고 home 등이 정의되어 있습니다.
title에 앱의 이름을 정하고 theme에는 지금 만들 앱의 테마를 어떤 색상으로 할지 정합니다. 메인 색상을 지정하는 primarySwatch 속성에는 Colors.blue가 입력되었습니다. 플러터에서 Colors 클래스를 이용하면 다양한 색상을 지정할 수 있습니다. 그리고 visualDensity 속성은 앱이 모바일이나 웹, 데스크톱, 맥 등 어떤 플랫폼에서도 자연스럽게 보이도록 지원합니다. home에는 앱을 실행할 때 첫 화면에 어떤 내용을 표시할지 정합니다. 코드에서는 home에 MyHomePage 클래스를 지정했습니다.
63
상태 연결에 따른 위젯 구분
플러터 앱을 구성하는 위젯은 스테이트리스(stateless)와 스테이트풀(statefull) 두 가지로 구분할 수 있습니다. 이러한 구분은 상태 연결과 관련이 있는데 상태 연결이 무엇을 의미하는지 살펴보겠습니다.
내용을 갱신할 필요가 없는 위젯은 화면에 보이기 전에 모든 로딩을 마칩니다. 예를 들어 앱을 처음 실행하면 사용자에게 정적인 도움말을 보여줄 수 있습니다. 이런 도움말 페이지는 갱신할 필요가 없습니다. 즉, 앱이 위젯의 상태를 감시하고 있을 필요가 없는 거죠. 이처럼 상태를 연결할 필요가 없는 위젯을 스테이트리스 위젯이라고 하며 StatelessWidget 클래스를 상속받아서 만듭니다.
[그림 3-3] 스테이트리스 위젯


StatefulWidget: Constructor → build
[그림 끝]
반면에 내용을 갱신해야 할 때도 있습니다. 예를 들어 계산기 앱에서 숫자를 입력하고 계산 버튼을 누르면 결괏값이 화면에 출력됩니다. 이때 버튼을 누를 때마다 화면에 누른 숫자가 반영되어야 합니다. 즉, 앱이 위젯의 상태를 감시하다가 위젯이 특정 상태가 되면 알맞은 처리를 수행해야 합니다. 이처럼 상태가 연결된 동적인 위젯을 스테이트풀 위젯이라고 하며 StatefulWidget 클래스를 상속받아서 만듭니다.
[그림 3-4] 스테이트풀 위젯


[전체 흐름]
1. → 2.
1. [① → ②]
2. [① → ② → ③ → ④ → ⑤ → ⑥, ⑤ → ⓐ, ⓑ → ③]
[세부 내용]
1. StatefulWidget
① Constructor
② build
2. State
① initState
② didChangeDependencies
③ dirty
④ build
⑤ clean
⑥ dispose
ⓐ didUpdateWidget
ⓑ setState
[그림 끝]
64
스테이트풀 위젯은 언제든 상태가 변경되면 특정한 처리를 수행해야 하므로 항시 지켜봐야 합니다. 그만큼 메모리나 CPU 등 자원을 많이 소비합니다. 그러나 스테이트리스 위젯은 갱신할 필요가 없으므로 적은 자원으로 화면을 구성할 수 있습니다.
[Do it! 실습] 데모 앱을 수정해 보자
여기서는 안드로이드 스튜디오가 만들어준 플러터 프로젝트의 데모 앱을 변경해 보겠습니다. 소스 코드 수정에 따라 앱이 어떻게 바뀌는지 살펴보면서 메인 소스 파일의 구조를 이해해 봅시다.
[1단계] main.dart 파일을 열고 MyApp 클래스에 있는 build() 함수에서 home을 정의한 부분을 다음처럼 수정합니다. 코드에서 Text는 화면에 텍스트를 출력하는 플러터의 기본 위젯입니다.
[글상자] lib/main.dart
(...생략...)
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
(...생략...)
home: Text('hello\nFlutter'),
);
}
}
[글상자 끝]
[2단계] 코드를 수정했으면 안드로이드 스튜디오에서 실행 버튼을 누릅니다. 그러면 에뮬레이터 또는 연결한 기기에서 앱이 실행되고 다음처럼 ‘hello Flutter’라는 텍스트가 출력됩니다.
65
[그림] 실행 결과


hello Flutter
[그림 끝]
화면 왼쪽 위에 ‘hello Flutter’가 빨간색 글자와 노란색 밑줄이 그어진 채로 표시되었습니다. 그런데 처음 실행했을 때와 다르게 왜 배경이 검은색[각주*]으로 바뀌었을까요? 원인은 방금 수정한 코드에서 화면을 기본 구성으로 호출하지 않고 home에 Text() 함수를 바로 넣었기 때문입니다. 이처럼 기본적인 화면 구조에서 벗어나면 기본 테마가 적용되지 않고 텍스트에 노란색 밑줄이 생깁니다.
[각주*] 만약 배경이 흰색이면 화면 아래쪽에 있는 버튼 중 ■ 모양을 눌렀다가 앱을 눌러서 화면을 다시 그리게 해보세요.[각주 끝]
[아하!] 그렇다면 플러터의 기본 배경색은 흰색인가요?
사실 플러터는 기본 배경색이 검은색입니다. 이 검은색을 다양한 색으로 칠한다고 생각하면 됩니다. 그리고 플러터의 위젯은 왼쪽에서 오른쪽으로, 위에서 아래로 그려집니다. 왼쪽 위가 시작점이라고 기억하면 됩니다.
[아하! 끝]
66
[3단계] 이번에는 텍스트를 가운데 정렬해 보겠습니다. Text() 함수에 두 번째 인자로 textAlign 속성을 추가하고 TextAlign.center값을 추가합니다.
[글상자] lib/main.dart
(...생략...)
home: Text('hello\nFlutter', textAlign: TextAlign.center)
(...생략...)
[글상자 끝]
[4단계] 소스를 수정했으니 다시 실행해 보겠습니다. 그런데 여기서 안드로이드 스튜디오의 실행 버튼을 누르면 소스를 다시 빌드해서 시간이 오래 걸립니다. 이때 플러터의 핫 리로드(hot reload) 기능을 이용하면 편리합니다. 핫 리로드 기능은 [Ctrl]+[\]를 눌러 저장하는 것만으로 핫 리로드 기능이 자동으로 실행되어 바뀐 코드가 적용됩니다[각주*].
[각주*] 그런데 핫 리로드 기능은 몇 가지 경우에 동작하지 않을 수 있습니다(flutter.dev/docs/development/tools/hotreload). 만약 원하는 결과가 안 나오면 실행을 멈추고([Ctrl]+[F2]) 다시 실행([Shift]+[F10])해 보세요.[각주 끝]
[그림] 실행 결과


hello Flutter, hello Flutter
[그림 끝]
67
실행 결과에서 오른쪽은 텍스트가 차지하는 공간을 나타냅니다. 가로는 화면 전체, 세로는 글자가 써진 부분까지입니다.
[4단계] 그렇다면 텍스트를 화면 한가운데에 놓으려면 어떻게 해야 할까요? 이때는 Center로 감싸 주면 됩니다.
[글상자] lib/main.dart
(...생략...)
home: Center(
child: Text('hello\nFlutter', textAlign: TextAlign.center),
));
(...생략...)
[글상자 끝]
[그림] 실행 결과


hello Flutter
[그림 끝]
이제는 가운데 정렬로 ‘hello Flutter’가 보이네요. 수정한 코드에서는 Center() 함수를 호출하고 child 옵션에 Text() 함수를 넣었습니다. child 옵션은 자신 아래 어떤 위젯을 넣겠다는 의미인데 하나만 넣을 때는 child, 여러 위젯을 넣고 싶을 때는 children 옵션을 사용합니다.
68
[5단계] 그런데 검은색 바탕에 빨간 글자가 조금 무섭습니다. 하나씩 바꿔 볼까요? 먼저 배경을 바꾸려면 Container가 필요합니다. Container는 플러터에서 가장 많이 사용하는 위젯 중 하나로 특정 공간을 책임지는 역할을 합니다. 그 공간에서 배경색이나 정렬, 여백 등 다양한 역할을 감당하는 만능 위젯이라고 할 수 있죠. Container에도 child를 넣을 수 있습니다. 앞에서 작성한 Center를 child에 넣어 보겠습니다.
[글상자] lib/main.dart
(...생략...)
home: Container(
child: Center(
child: Text('hello\nFlutter', textAlign: TextAlign.center),
)));
(...생략...)
[글상자 끝]
그런데 다시 실행하면 딱히 바뀌는 게 없을 거예요. 지금은 공간만 만들어 주었으니까요. 이제 이 Container에 color를 넣어보겠습니다. color에 Colors.white를 입력합니다.
[글상자] lib/main.dart
(...생략...)
home: Container(
color: Colors.white,
child: Center(
child: Text(
(...생략...)
[글상자 끝]
[그림] 실행 결과


hello Flutter
[그림 끝]
69
[6단계] 이제 배경 화면이 하얀색으로 바뀌었습니다. 하지만 아직 글자가 빨간색이라 너무 강렬하네요. 한번 바꿔 볼까요? 방법은 간단합니다. Text 안에 style 옵션만 추가하면 됩니다. style은 TextStyle() 함수를 통해서 입력받고 이 TextStyle에서 color값과 fontSize 그리고 폰트까지 바꿀 수 있습니다.
[글상자] lib/main.dart
(...생략...)
child: Text(
'hello\nFlutter',
textAlign: TextAlign.center,
style: TextStyle(color: Colors.blue, fontSize: 20),
),
(...생략...)
[글상자 끝]
[그림] 실행 결과


hello Flutter
[그림 끝]
[Do it! 실습] 스위치를 달아서 화면을 갱신해 보자
이번에는 앱에 스위치를 달고 화면을 갱신하는 방법을 살펴보겠습니다. 그리고 머티리얼 디자인도 적용해 보겠습니다. 앱에 머티리얼 디자인을 적용하려면 Scaffold 클래스를 이용합니다[각주*].
[각주*] 머티리얼 디자인과 Scaffold 클래스에 관한 자세한 내용은 4장에서 다룹니다.[각주 끝]
[1단계] 먼저 머티리얼 디자인을 적용하기 위해 main.dart 파일을 열고 MyApp 클래스를 다음처럼 수정합니다. 그리고 MyApp 클래스 아래 작성된 여러 클래스는 사용하지 않을 것이므로 모두 지웁니다.
70
* 제작자 주: 본문에 각주* 표시 누락됨.
[글상자] lib/main.dart
(...생략...)
class MyApp extends StatelessWidget {
var switchValue = false;
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(
primarySwatch: Colors.blue,
visualDensity: VisualDensity.adaptivePlatformDensity,
),
darkTheme: ThemeData.light(),
home: Scaffold(
body: Center(
child: Switch(
value: switchValue,
onChanged: (value) {
switchValue = value;
}),
),
));
}
}
[글상자 끝]
[그림] 실행 결과


[그림 끝]
[각주*] 소스 코드를 입력하고 [Ctrl]+[Alt]+[L] 키를 누르면 코드가 자동으로 정렬됩니다.[각주 끝]
71
StatelessWidget을 상속받은 MyApp 클래스에서 Scaffold를 이용해 스위치를 구성했습니다. 이 스위치는 사용자가 누를 때마다 true나 false값이 switchValue값으로 들어가 스위치 상태가 변합니다.
그런데 실행된 앱에서 스위치를 아무리 눌러도 화면에 변화가 없습니다. MyApp 클래스는 StatelessWidget 클래스를 상속받아 스테이트리스로 만들었으므로 위젯의 상태 변경에 따른 값을 화면에 반영하지 못하기 때문입니다.
[2단계] 그럼 스테이트리스 위젯을 스테이트풀 위젯으로 바꾸면 될까요? 한번 해보죠. 코드를 다음처럼 수정해 봅시다.
[글상자] lib/main.dart
(...생략...)
void main() {
runApp(MyApp());
}
class MyApp extends StatefulWidget {
@override
State<StatefulWidget> createState() {
return _MyApp();
}
}
class _MyApp extends State<MyApp> {
(...생략...)
home: Scaffold(
body: Center(
child: Switch(
value: switchValue,
onChanged: (value) {
print(value);
switchValue = value;
}),
(...생략...)
[글상자 끝]
72
코드가 조금 복잡해졌지만 우선 세부 코드에 집중하기보다 구조 중심으로 살펴봅시다. 스테이트풀 위젯은 혼자서 화면을 출력할 수 없고 State 클래스가 필요합니다. 그러므로 State 클래스를 상속받는 _MyApp 클래스를 만들고 그 안에 앞에서 만들어 놓은 위젯을 담습니다. 그리고 StatefulWidget 클래스를 상속받는 MyApp은 createState() 함수를 재정의해서 호출합니다. 이렇게 하면 MyApp 클래스가 현재 화면을 주시하다가 상태가 변경되면 이를 감지하고 _MyApp 클래스가 화면을 갱신합니다.
[아하!] 코드에서 언더스코어(_)는 어떤 의미인가요?
언더스코어(_)는 내부에서만 사용할 수 있다는 것을 의미합니다. 즉, _MyApp 클래스는 main.dart 안에서만 사용하므로 언더스코어를 넣습니다. 변수나 함수도 내부에서만 사용할 거라면 언더스코어를 넣어서 작성합니다.
[아하! 끝]
그리고 Switch() 함수에서 print() 함수로 value값(스위치 상태)을 출력하게 했습니다. print() 함수가 출력하는 내용은 안드로이드 스튜디오의 실행 창에서 확인할 수 있습니다. 여기서는 플러터 앱 실행 중 내부에서 발생하는 다양한 기록을 볼 수 있습니다. 안드로이드 스튜디오 화면 아래 [Run] 탭으로 열고 닫을 수 있습니다.
[그림 3-5] 안드로이드 스튜디오 실행 창


ture, ▶ 4: Run
[그림 끝]
그런데 앱에서 스위치를 눌러도 여전히 화면이 바뀌지 않습니다. 실행 창에는 분명 스위치가 켜졌다는 의미로 true가 출력되는데 왜 그럴까요?
[3단계] 플러터에서는 변숫값이 바뀌면 이 사실을 앱에 알려 화면을 갱신해 주어야 합니다.
이때 사용하는 함수가 setState()입니다.
73
[글상자] lib/main.dart
(...생략...)
child: Switch(
value: switchValue,
onChanged: (value) {
setState(() {
print(value);
switchValue = value;
});
}),
(...생략...)
[글상자 끝]
[그림] 실행 결과


[그림 끝]
드디어 스위치가 끔에서 켬으로 바뀌었습니다. 사용자가 스위치를 누르면 onChanged 이벤트가 발생하면서 value값을 전달받습니다. 이 값이 switchValue에 담기고 switchValue가 가리키는 Switch의 value가 변경되면서 화면을 갱신합니다. 이처럼 화면의 값을 바꾸려면 setState() 함수 안에서 해야 합니다. 그래야만 바뀐 값이 반영된 화면으로 갱신합니다.
74
[Do it! 실습] 버튼을 눌러 텍스트를 바꿔 보자
이제 버튼을 이용하는 법을 연습해 보겠습니다. 플러터에서 버튼은 기본적으로 RaisedButton이라는 위젯을 사용합니다. 이 위젯을 이용하면 사용자가 버튼을 눌렀을 때 해당 이벤트를 받아서 동작을 처리할 수 있습니다.
[1단계] 먼저 다음처럼 버튼에 표시할 텍스트를 저장한 변수를 선언하고 RaisedButton 위젯을 추가합니다.
[글상자] lib/main.dart
(...생략...)
class _MyApp extends State<MyApp> {
var switchValue = false;
String test = 'hello'; // 버튼에 들어갈 텍스트 입력
@override
Widget build(BuildContext context) {
(...생략...)
home: Scaffold(
body: Center(
child: RaisedButton(
child: Text('$test'),
onPressed: () {})),
));
}
}
[글상자 끝]
버튼 위젯에도 child를 선언할 수 있습니다. child를 선언해 Text를 넣고 그 Text에 문자열 ‘hello’가 입력된 test 변수를 대입합니다. Text는 따옴표 안에 $ 기호 다음을 변수로 인식합니다.
[2단계] 이제 버튼을 누르면 텍스트가 바뀌는 로직을 추가해 보겠습니다.
75
[글상자] lib/main.dart
(...생략...)
child: RaisedButton(
child: Text('$test'),
onPressed: () {
if (test == 'hello') {
setState(() {
test = 'flutter';
});
} else {
setState(() {
test = 'hello';
});
}
})),
(...생략...)
[글상자 끝]
만약 test 변숫값이 ‘hello’이면 setState() 함수 안에서 test 변숫값을 ‘flutter’로 바꿉니다. ‘hello’가 아닐 때는 test 변숫값을 다시 ‘hello’로 바꾸는 코드를 넣었습니다.
이제 실행해보면 다음처럼 버튼을 누를 때마다 텍스트가 바뀌는 것을 확인할 수 있습니다.
[그림] 실행 결과


hello, flutter
[그림 끝]
76
[3단계] 이제 버튼의 색도 바꿔봅시다. 색을 바꾸려면 앞에서 사용했던 Colors 클래스를 이용합니다. 여기서는 버튼을 누르면 색이 바뀌도록 변경해 보겠습니다.
[글상자] lib/main.dart
(...생략...)
class _MyApp extends State<MyApp> {
var switchValue = false;
String test = 'hello'; // 버튼에 들어갈 텍스트 입력
Color _color = Colors.blue;
@override
Widget build(BuildContext context) {
(...생략...)
child: RaisedButton(
child: Text('$test'),
color: _color,
onPressed: () {
if (_color == Colors.blue) {
setState(() {
test = 'flutter';
_color = Colors.amber;
});
} else {
setState(() {
test = 'flutter';
_color = Colors.blue;
});
}
})),
));
}
}
[글상자 끝]
_color 변수를 하나 선언한 후 Colors.blue로 초기화합니다. 그리고 버튼의 color: 인자에 _color를 넣어서 초기화한 색상을 넣습니다. 버튼을 눌렀을 때 만약 파란색이면 노란색으로
77
바꾸고, 파란색이 아니면 다시 원래 색상으로 되돌리는 코드를 넣었습니다. 이제 다시 빌드하면 버튼을 누를 때마다 버튼의 색상이 바뀌는 것을 확인할 수 있습니다.
[그림] 실행 결과


hello, Flutter
[그림 끝]
78
03-2 위젯의 생명주기 이해하기
위젯의 생명주기를 알면 언제 데이터를 주고받을지, 그리고 화면이 사라질 때 어떤 로직을 처리해야 할지를 정리해서 넣을 수 있습니다. 예를 들어 특정 화면에서 소리로 문서를 읽어 준다고 했을 때 화면을 종료해도 계속 소리가 나오면 안 되겠죠? 이런 상황을 막기 위해 화면이 사라질 때 소리도 함께 멈추는 기능(함수)을 넣어야 합니다. 이처럼 생명주기를 이해하면 앱의 동작이나 자원을 효율적으로 관리할 수 있습니다.
스테이트풀 위젯의 생명주기
스테이트리스 위젯은 한 번 만들어지면 갱신할 수 없으므로 생명주기가 없습니다. 즉, 다른 화면으로 넘어가면 모든 로직이 종료됩니다. 그러나 스테이트풀 위젯은 10단계로 구분하는 생명주기가 있습니다. 앱을 만들 때 생명주기는 매우 중요하므로 지금부터 각 생명주기를 살펴보겠습니다. 앞에 붙은 번호순으로 생명주기가 진행되므로 순서도 눈여겨봐야 합니다.
1. 상태를 생성하는 createState() 함수
먼저 StatefulWidget 클래스를 상속받는 클래스는 반드시 createState() 함수를 호출해야 합니다. 이 함수는 다른 생명주기 함수들이 포함된 State 클래스를 반환합니다. 즉, 위젯의 상태를 생성하는 함수로 생각할 수 있습니다.
[글상자]
class MyHomePage extends StatefulWidget {
@override
_MyHomePageState createState() => new _MyHomePageState();
}
[글상자 끝]
79
[아하!] 왜 State와 StatefulWidget 클래스를 나누어 놓았을까요?
바로 성능 때문입니다. StatefulWidget보다 State 클래스가 상대적으로 더 무겁기 때문에 StatefulWidget에서 감시하고 있다가 상태 변경 신호가 오면 State 클래스가 화면을 갱신하도록 구현합니다. 만약 StatefulWidget에서 바로 갱신하면 나중에 화면이 종료되어도 할당받은 메모리를 없앨 때까지 오랜 시간이 걸릴 수 있습니다. 따라서 상태 변경 감시는 StatefulWiget 클래스가 담당하고, 실제 갱신 등은 State 클래스가 담당하도록 분리해 두었습니다.
[아하! 끝]
2. 위젯을 화면에 장착하면 mounted == true
createState() 함수가 호출되어 상태가 생성되면 곧바로 mounted 속성이 true로 변경됩니다. mounted 속성이 true라는 것은 위젯을 제어할 수 있는 buildContext 클래스에 접근할 수 있다는 의미입니다. buildContext가 활성화되어야 비로소 setState() 함수를 이용할 수 있습니다. 그렇지 않으면 오류가 발생합니다. 화면 구성도 안 되었는데 setState() 함수로 위젯을 건드릴 수는 없으니까요. 따라서 다음처럼 setState() 함수를 호출하기 전에 mounted 속성을 점검 코드로 활용하면 좀 더 안전하게 작성할 수 있습니다
[글상자]
if (mounted) {
setState()
}
[글상자 끝]
3. 위젯을 초기화하는 initState() 함수
initState() 함수는 위젯을 초기화할 때 한 번만 호출합니다. 주로 데이터 목록을 만들거나 처음 필요한 데이터를 주고받을 때 호출합니다.
[글상자]
@override
initState() {
super.initState();
_getJsonData();
}
[글상자 끝]
80
initState() 함수를 호출할 때 내부에서 _getJsonData() 함수를 호출해 서버에서 받아온 데이터를 화면에 출력하게 만들 수 있습니다. 만약 네트워크 통신이 안 되거나 데이터가 이상하다면 화면에 표시하기 전에 미리 알아서 적절하게 대응해야 하므로 위젯을 초기화하는 initState() 함수에서 데이터를 준비해 놓는 게 좋습니다.
4. 의존성이 변경되면 호출하는 didChangeDependencies() 함수
위젯을 초기화하는 initState() 함수가 호출된 후에 이어서 바로 호출되는 함수가 didChangeDependencies()입니다. 이 함수는 데이터에 의존하는 위젯이라면 화면에 표시하기 전에 꼭 호출해야 합니다. 주로 상속받은 위젯을 사용할 때 피상속자가 변경되면 호출합니다.
5. 화면에 표시하는 build() 함수
build() 함수는 앞서 데모 앱에서도 재정의해서 사용해 봤습니다. 이 함수는 Widget을 반환합니다. 즉, 위젯을 화면에 렌더링합니다. build() 함수에서 위젯을 만들고 반환하면 비로소 화면에 표시됩니다.
[글상자]
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(
primarySwatch: Colors.amber,
),
home: MyHomePage(title: 'Flutter Demo Home Page'),
);
}
[글상자 끝]
6. 위젯을 갱신하는 didUpdateWidget() 함수
부모 위젯이나 데이터가 변경되어 위젯을 갱신해야 할 때 호출합니다. 만약 initState()에서 특정 이벤트에 의해 위젯이 변경되면 didUpdateWidget() 함수를 호출해 위젯을 갱신할 수 있습니다. initState() 함수는 위젯을 초기화할 때 한 번만 호출되므로 위젯이 변경되었을 때 호출하는 didUpdateWidget() 같은 함수가 필요합니다.
81
[글상자]
@override
void didUpdateWidget(Widget oldWidget) {
if (oldWidget.importantProperty != widget.importantProperty) {
_init();
}
}
[글상자 끝]
7. 위젯의 상태를 갱신하는 setState() 함수
setState() 함수를 이용하면 데이터가 변경되었다는 것을 알려주고 변경된 데이터를 이용해 화면의 UI를 변경할 수 있도록 합니다. 플러터 앱을 만든다는 것은 곧 앱의 화면을 구성하는 일이므로 제일 많이 호출하는 함수입니다.
[글상자]
void updateProfile(String name) {
setState(() => this.name = name);
}
[글상자 끝]
8. 위젯의 상태 관리를 중지하는 deactivate() 함수
deactivate() 함수는 State 객체가 플러터의 구성 트리로부터 제거될 때 호출됩니다. 다만, State 객체가 제거됐다고 해서 해당 메모리까지 지워지지는 않습니다. deactivate() 함수가 호출되더라도 바로 다음에 설명하는 dispose() 함수를 호출하기 전까지는 State 객체를 재사용할 수 있습니다.
9. 위젯의 상태 관리를 완전히 끝내는 dispose() 함수
State 객체를 영구적으로 소멸할 때 호출합니다. 이 함수를 호출한다는 것은 이제 해당 위젯을 종료한다는 뜻입니다. 예를 들어 네트워크 통신을 하거나 스트림 통신을 하다가 dispose() 함수를 호출하면 데이터 전송을 중지합니다. 그리고 위젯을 소멸할 때 꼭 호출해야 하는 함수라면 dispose() 함수 안에서 호출해야 합니다. 만약 앞에서 살펴본 deactivate() 함수 호출로 State 객체를 트리에서 제거한 후에 같은 State를 다시 다른 트리에 재사용할 경우 (흔하지 않지만) dispose() 함수가 호출되지 않을 수 있습니다.
82
10. 위젯을 화면에서 제거하면 mounted == false
State 객체가 소멸하면 마지막으로 mounted 속성이 false로 되면서 생명주기가 끝납니다. mounted 속성이 false가 되었다는 것은 이 State는 재사용할 수 없다는 의미입니다. 그러므로 setState() 함수를 호출하면 오류가 발생합니다.
다음은 지금까지 공부한 스테이트풀 위젯의 생명주기를 정리한 표입니다. 1번부터 진행 순서로 각 주기의 특징을 요약하면 다음과 같습니다.
[표 3-3] 위젯의 생명주기 요약
호출 순서

생명주기

내용

1

createState()

처음 스테이트풀을 시작할 때 호출

2

mounted == true

createState() 함수가 호출되면 mounted는 true

3

initState()

State에서 제일 먼저 실행되는 함수. State 생성 후 한 번만 호출

4

didChangeDependencies()

initState() 호출 후에 호출되는 함수

5

build()

위젯을 렌더링하는 함수. 위젯을 반환

6

didUpdateWidget()

위젯을 변경해야 할 때 호출하는 함수

7

setState()

데이터가 변경되었음을 알리는 함수. 변경된 데이터를 UI에 적용하기 위해 필요

8

deactivate()

State가 제거될 때 호출

9

dispose()

State가 완전히 제거되었을 때 호출

10

mounted == false

모든 프로세서가 종료된 후 mounted가 false로 됨

[Do it! 실습] 생명주기 순서 출력하기
[1단계] 지금까지 살펴본 생명주기 순서를 출력하는 프로그램을 구현해 보겠습니다. 편의를 위해 지금까지 만든 데모 앱에 코드를 추가하는 형태로 작성하겠습니다. StatefulWidget 클래스를 상속받는 MyApp 클래스에서 createState() 함수를 찾아 다음과 같은 출력문을 추가합니다.
[글상자] lib/main.dart
(...생략...)
class MyApp extends StatefulWidget {
@override
State<StatefulWidget> createState() {
83
print('createState');
return _MyApp();
}
}
(...생략...)
[글상자 끝]
[2단계] _MyApp 클래스로 이동한 다음 initState()와 didChangeDependencies() 함수를 다음처럼 추가합니다.
[글상자] lib/main.dart
(...생략...)
class _MyApp extends State<MyApp> {
(...생략...)
@override
Widget build(BuildContext context) { ...생략... }
@override
void initState() {
super.initState();
print('initState');
}
@override
void didChangeDependencies() {
super.didChangeDependencies();
print('didChangeDependencies');
}
}
[글상자 끝]
[3단계] 마지막으로 build() 함수에서 return 문 전에 출력문을 추가합니다.
[글상자] lib/main.dart
(...생략...)
@override
Widget build(BuildContext context) {
print('build');
(...생략...)
[글상자 끝]
84
소스 파일을 실행한 후 안드로이드 스튜디오의 실행 창을 보면 다음처럼 생명주기 함수가 호출 순서대로 출력되는 것을 확인할 수 있습니다.
[글상자] 실행 결과
I/flutter (16949): createState
I/flutter (16949): initState
I/flutter (16949): didChangeDependencies
I/flutter (16949): build
[글상자 끝]
아직은 화면 이동을 다루지 않았으므로 didUpdateWidget() 등 다른 함수는 호출하지 않았습니다. 앞으로 플러터를 배워 가면서 생명주기에 대해 더 자세히 알아보겠습니다.
지금까지 플러터 프로젝트를 생성하면 자동으로 만들어지는 데모 앱을 훑어보았습니다. 그리고 이 앱을 조금씩 변경하면서 플러터 앱의 구조와 위젯의 생명주기를 살펴봤습니다. 이번 장에서는 맛보기 기능만 구현했지만 나중에는 여러분이 상상하는 다양한 위젯과 기능으로 가득 채워질 것으로 기대해 봅니다.
85
둘째마당 플러터 핵심 기능 배우기
플러터는 여러 가지 위젯을 제공함으로써 앱을 좀 더 편리하게 개발할 수 있게 돕습니다. 플러터 앱 개발은 결국 각 위젯의 특징을 이해하고 이를 이용해 원하는 기능을 각 생명주기에 맞게 구현하는 것입니다.
둘째마당에서는 많은 앱에서 기본으로 사용하는 핵심적인 기능을 살펴봅니다. 그럼 본격적으로 플러터 앱 개발을 시작해 봅시다.
04 플러터 위젯 사용법
05 탭바와 리스트 만들기
06 iOS 스타일로 플러터 앱 만들기
07 네트워크를 이용해 통신하기
08 내비게이션 활용하기
86
04 플러터 위젯 사용법
이번 장부터는 본격적으로 플러터 앱을 개발하는 데 필요한 내용을 하나씩 살펴보겠습니다. 그중에서 구글의 머티리얼 디자인이 적용된 위젯을 사용하는 방법과 앱에 이미지, 폰트 등을 추가하는 방법 등을 이번 장에서 살펴봅니다. 그리고 간단한 계산기 앱을 만들어 보면서 사용자와 상호작용하는 방법까지 살펴보겠습니다.
04-1 스캐폴드를 이용한 머티리얼 디자인 적용
04-2 이미지와 폰트 추가하기
04-3 사용자와 상호작용하는 앱 만들기
87
04-1 스캐폴드를 이용한 머티리얼 디자인 적용
머티리얼 디자인은 무엇일까?
이번 절에서는 머티리얼 디자인을 이용해 앱을 만들어 보겠습니다. 머티리얼 디자인(material design)은 구글에서 2014년부터 사용한 플랫 디자인(flat design) 지침입니다. 머티리얼 디자인이 나오기 전까지는 앱마다 디자인이 달랐습니다. 앱 개발사별로 추구하는 디자인 철학과 설계 방식에 따라 아이콘이나 버튼을 만들었죠. 따라서 개성은 있지만 통일되지 않은 사용자 경험(UX, user experience)을 줄 수밖에 없었습니다. 이 때문에 사용자는 앱 사용법을 이해하는 데 시간이 필요했습니다. 또한, 과도한 이미지 사용으로 앱 크기가 커지는 바람에 늘 기기의 용량 부족에 시달렸습니다.
이에 구글은 안드로이드 롤리팝 버전부터 머티리얼 디자인 지침을 제시했고, 지금까지 수많은 앱이 머티리얼 디자인 지침에 따라 만들어졌습니다. 머티리얼 디자인을 적용하면 평면, 단색 위주의 간결한 디자인을 바탕으로 앱의 용량을 줄이고 동시에 속도를 개선할 수 있습니다. 이제 안드로이드 앱 사용자는 머티리얼 디자인 덕분에 직관적이고 일관된 UI를 경험할 수 있게 되었고, 처음 접하는 앱이라도 쉽게 적응할 수 있게 되었습니다.
[그림 4-1] 머티리얼 디자인 웹 사이트(material.io)


[그림 끝]
88
[Do it! 실습] 스캐폴드 이용하기
플러터 앱을 제작할 때 머티리얼 디자인을 적용하려면 스캐폴드(Scaffold) 클래스[각주*]를 이용합니다. 스캐폴드 클래스는 각종 위젯을 머티리얼 디자인 레이아웃으로 설계하는 것을 돕는 역할을 합니다. 이번 실습에서는 스캐폴드를 이용해 머티리얼 디자인이 적용된 앱을 만들어 봅니다.
[각주*] 스캐폴드 클래스에 대한 더 자세한 설명은 api.flutter.dev/flutter/material/Scaffold-class.html를 참고하세요.[각주 끝]
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] 안드로이드 스튜디오에서 [File → New → New Flutter Project] 메뉴를 누르고 material_flutter_app이라는 이름[각주*]으로 새로운 플러터 프로젝트를 생성합니다. 플러터 프로젝트를 생성하는 과정의 자세한 설명은 「01-4」절을 참고하세요.
[각주*] 프로젝트 이름에는 대문자와 띄어쓰기를 사용할 수 없으니 유의하세요.[각주 끝]
[그림 4-2] 프로젝트 설정


New Flutter Application
Configure the new Flutter Application
Project name: material_flutter_app
Flutter SDK path: D:\flutter / View setup docs...
Project location: D:\flutterProject\MaterialFlutterApp
Description: 머터리얼 디자인 플러터 앱 / ? Create Project offline
[Next]
[그림 끝]
[2단계] 프로젝트가 생성됐으면 lib 폴더의 main.dart 파일을 열고 StatefulWidget 클래스를 상속받는 MaterialFlutterApp 클래스를 만듭니다. 3장에서 스테이트풀 위젯을 화면에 출력하려면 State 클래스를 이용해야 한다고 했으므로 State 클래스를 상속받는 _MaterialFlutterApp 클래스도 만듭니다.
89
[글상자] lib/main.dart
import 'package:flutter/material.dart';
void main() => runApp(MyApp());
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Material Flutter App',
theme: ThemeData(
primarySwatch: Colors.blue,
),
home: MaterialFlutterApp(),
);
}
}
class MaterialFlutterApp extends StatefulWidget {
@override
State<StatefulWidget> createState() {
return _MaterialFlutterApp();
}
}
class _MaterialFlutterApp extends State<MaterialFlutterApp> {
@override
Widget build(BuildContext context) {
return null;
}
}
[글상자 끝]
그런데 코드를 작성한 후 앱을 실행해 보면 오류 화면이 출력됩니다.
[그림 4-3] 오류가 발생한 앱 화면


A build function returned null.
The offending widget is: MaterialFlutterApp
Build functions must never return null.
To ruturn an empty space that causes the building widget to fill available room, return "Container()". To return an empty space that takes as little room as possible, return "Container(width: 0.0, height: 0.0)".
See also: https://flutter.dev/docs/testing/errors
[그림 끝]
90
[3단계] 안드로이드 스튜디오 아래 실행(Run) 창에도 오류가 발생한 원인이 나타납니다. 오류 메시지를 확인하면 다음과 같습니다.
[그림 4-4] 오류 화면


A build function returned null.
[그림 끝]
이 오류 메시지는 build() 함수가 null이라서 화면에 아무것도 표시할 수 없다는 내용입니다. 원인을 알았으니 수정해 볼까요?
[4단계] _MaterialFlutterApp 클래스에서 재정의한 build() 함수에 null 대신 위젯을 넣어 줍시다. 우선 내용이 비어 있는 Scaffold() 함수 호출로 위젯의 골격만 작성해 오류를 없애 봅시다. 소스를 다음처럼 수정하고 저장하면 앱에 오류 내용이 사라지고 흰색 빈 화면이 나타납니다.
[글상자] lib/main.dart
(...생략...)
class _MaterialFlutterApp extends State<MaterialFlutterApp>{
@override
Widget build(BuildContext context) {
return Scaffold(
);
}
}
[글상자 끝]
[그림] 실행 결과


[그림 끝]
91
[Do it! 실습] 제목 줄 추가하기
앞에서 작성한 스캐폴드 함수에 위젯을 하나씩 채워 보겠습니다. 먼저 현재 위치를 알 수 있는 제목 줄을 추가해 봅시다. 제목 줄은 스캐폴드 위젯에서 앱바 옵션으로 구현합니다.
[1단계] 스캐폴드에 appBar를 선언하고 새로운 AppBar를 생성합니다. 그리고 AppBar에서 title값에 Text() 함수로 ‘Material Desing App’이라는 문자열을 입력합니다[각주*].
[각주*] 앱바에는 버튼이나 아이콘 이미지 등을 넣을 수도 있어요.[각주 끝]
[글상자] lib/main.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(title: Text('Material Design App'),),
);
}
(...생략...)
[글상자 끝]
[2단계] 다음은 오른쪽 아래에 떠 있는 듯한 버튼[각주*]을 만들어 보겠습니다. 스캐폴드에 floating ActionButton을 선언한 후 새로운 FloatingActionButton() 함수를 생성합니다. 이 함수에 child를 선언하고 Icon을 이용해 Icons.add를 선택하면 버튼 안에 + 모양의 아이콘이 표시됩니다. Icons에는 기본 머티리얼 디자인에 알맞은 아이콘들이 정의되어 있습니다.
[각주*] 앱 개발에서는 이와 같은 버튼을 플로팅 버튼(floating button)이라고 합니다.[각주 끝]
92
[글상자] lib/main.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(title: Text('Material Design App'),),
floatingActionButton: FloatingActionButton(child: Icon(Icons.add),
onPressed: () {
}),
);
}
(...생략...)
[글상자 끝]
[그림] 실행 결과


Material Design App
[그림 끝]
지금까지 만든 플러터 앱의 위젯 구성은 다음과 같습니다.
[그림 4-5] 위젯 구성


- Scaffold
1. Container: Body
2. AppBar: Text
3. FloatingActionButton: Icon
[그림 끝]
위젯 구성에서 왼쪽의 Body는 앱의 메인 화면을 구성하는 본문을 나타냅니다. 다음 실습에서 body를 선언하고 새로운 컨테이너[각주*]를 생성해 보겠습니다.
[각주*] 컨테이너(container)는 위젯을 담아 관리하는 상자라는 개념으로 생각해도 좋습니다.[각주 끝]
93
[Do it! 실습] 위젯을 여러 개 만들기
지금까지는 child를 이용해 하나의 위젯만 만들었습니다. 이번에는 여러 개의 위젯을 만드는 방법을 알아보겠습니다. 위젯을 여러 개 만들려면 Row와 Column 위젯을 이용합니다. Row는 가로, Column은 세로로 위젯을 배치합니다. 이때 Row와 Column 옵션 안에는 child가 아닌 children을 이용해 배열 형태로 선언합니다.
[1단계] 먼저 스캐폴드 안에 body를 선언하고 그 안에 Container의 child로 Column을 지정합니다. 다시 Column 안에 children을 이용해 위젯 목록을 배열 형태로 나열할 기본 골격을 만듭니다.
[글상자] lib/main.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(title: Text('Material Design App'),),
floatingActionButton: FloatingActionButton(child: Icon(Icons.add),
onPressed: () {
}),
body: Container(
child: Column(
children: <Widget>[
],
),
),
);
}
(...생략...)
[글상자 끝]
[2단계] 이제 children에 위젯을 여러 개 넣을 수 있습니다. 여기서는 아이콘과 텍스트를 하나씩 만듭니다.
94
[글상자] lib/main.dart
(...생략...)
body: Container(
child: Column(
children: <Widget>[
Icon(Icons.android),
Text('android')
],
),
),
(...생략...)
[글상자 끝]
[그림] 실행 결과


Material Design App, android
[그림 끝]
[3단계] 새로 만든 위젯이 본문 왼쪽 모서리에 있어서 보기가 힘들므로 중앙에 보이도록 정렬해 보겠습니다. 위젯을 가운데에 정렬하려면 Container와 Column 사이에 Center 위젯을 놓습니다. 그런데 Center 위젯은 가로로만 정렬해 줍니다. 세로로도 정렬해 위젯을 본문 한가운데에 표시하려면 Column에 mainAxisAlignment를 선언하고 MainAxisAlignment.center를 입력합니다.
[글상자] lib/main.dart
(...생략...)
body: Container(
child: Center(
child: Column(
children: <Widget>[Icon(Icons.android), Text('android')],
mainAxisAlignment: MainAxisAlignment.center, // 세로로 정렬해주는 코드
),
),
),
(...생략...)
[글상자 끝]
95
소스를 저장하고 앱의 화면을 확인하면 다음처럼 본문 한 가운데로 정렬된 아이콘과 텍스트가 보입니다.
[그림] 실행 결과


Material Design App, android
[그림 끝]
지금까지 스캐폴드를 이용해 화면을 구현하는 기본적인 방법을 살펴봤습니다. 다음 그림은 지금까지 구성한 위젯을 나타낸 것입니다.
[그림 4-6] 위젯 구성


- Scaffold
Text Icon
1. Body
1-1. Container
1-2. Center
1-3. Column
1) Icon
2) Text
2. AppBar
1) Text
3. FloatingActionButton
1) Icon
[그림 끝]
96
04-2 이미지와 폰트 추가하기
앱을 만들다 보면 기본 이미지 외에 추가로 이미지를 만들어 넣어야 할 때가 있습니다. 서버에서 이미지를 가져와 화면에 출력할 수도 있지만, 자주 사용되는 이미지는 앱에 넣어 두었다가 직접 호출하는 편이 데이터 사용이나 속도 면에서 유리합니다. 이번 절에서는 앱에 이미지와 폰트를 추가하는 방법을 살펴보겠습니다.
[Do it! 실습] 이미지 표시하기
[1단계] 안드로이드 스튜디오에서 image_font_add_app이라는 이름으로 새로운 플러터 프로젝트를 생성합니다. 그리고 lib 폴더에 imageWidget이라는 이름의 새로운 다트 파일을 추가합니다.
[그림 4-7] imageWidget.dart 파일 추가


imageWidget.dart
[그림 끝]
[2단계] 우선 imageWidget.dart 파일을 열고 material.dart를 import합니다. 그리고 StatefulWidget을 상속받는 ImageWidgetApp 클래스를 생성합니다. 해당 클래스는 State를 상속받는 _ImageWidgetApp 클래스를 반환해야 합니다.
[글상자] lib/imageWidget.dart
import 'package:flutter/material.dart';
class ImageWidgetApp extends StatefulWidget {
@override
State<StatefulWidget> createState() {
return _ImageWidgetApp();
}
}
class _ImageWidgetApp extends State<ImageWidgetApp> {
97
@override
Widget build(BuildContext context) {
return null;
}
}
[글상자 끝]
[3단계] 이제 이미지를 추가해 보겠습니다. 이미지를 추가하려면 일단 프로젝트에 해당 이미지가 포함돼야 합니다. 프로젝트 탐색 창에서 프로젝트 이름에 마우스 오른쪽을 누르고 [New → Directory]를 선택한 후 image라는 이름으로 폴더를 생성합니다.
[그림 4-8] image 폴더 추가


image
[그림 끝]
[4단계] image 폴더에 이미지를 한 장 넣습니다. 필자가 제공한 이미지 파일(flutter_logo.png)[각주*]을 마우스로 끌어다가 image 폴더에 놓습니다.
[각주*] 이미지나 폰트처럼 이 책에서 실습에 필요한 파일은 모두 필자가 제공한 실습 파일에 있어요. 장별 프로젝트 폴더에서 같은 경로에 각 파일이 담겨 있으니 활용하기 바랍니다.[각주 끝]
[그림 4-9] 플러터 로고 이미지 파일 추가


flutter_logo.png
[그림 끝]
[5단계] 프로젝트에 이미지를 추가했습니다. 기존 안드로이드나 스위프트 앱 개발에서는 프로젝트에 이미지만 추가하면 바로 사용할 수 있지만, 플러터 앱은 한 가지 더 수정할 부분이 있습니다. 바로 pubspec.yaml 파일에 해당 이미지 정보를 추가해야 합니다. pubspec.yaml은 플러터 앱의 환경 설정과 관련된 파일입니다. 이 파일에 플러터 버전 관리나 새로운 패키지를 추가할 수 있으며 이미지와 폰트도 추가할 수 있습니다.
pubspec.yaml 파일에 코드를 추가할 때는 들여쓰기에 조심해야 합니다. 들여쓰기를 잘못하면 앱이 제대로 동작하지 않을 수 있습니다. 프로젝트 루트에 있는 pubspec.yaml 파일은 주
98
석을 제거하면 다음과 같은 내용입니다. 마지막 두 줄이 이미지를 추가하는 코드입니다.
[글상자] pubspec.yaml
name: image_font_add_app
description: 이미지와 폰트 추가하기
publish_to: 'none'
version: 1.0.0+1
environment:
sdk: ">=2.7.0 <3.0.0"
dependencies:
flutter:
sdk: flutter
cupertino_icons: ^0.1.3
dev_dependencies:
flutter_test:
sdk: flutter
flutter:
uses-material-design: true
assets: // 이미지를 추가하는 코드
- image/flutter_logo.png // 이미지를 추가하는 코드
[글상자 끝]
[아하!] pubspec.yaml 파일을 수정했더니 편집 창에 노란 줄이 생겼어요!
소스에서 패키지나 파일을 추가하는 코드를 작성하면 플러터 프레임워크가 변경된 프로젝트 구성을 알아야 하므로 알림을 표시합니다. 이 알림에서 <Get dependencies>를 클릭하면 자동으로 변경된 정보를 받아와서 파일이나 패키지를 사용할 수 있도록 합니다.
[그림 4-10] 의존성 설정 안내


Get dependencies
[그림 끝]
[아하! 끝]
99
[6단계] 이미지를 추가했으니 이제 위젯을 만들어 보겠습니다. 앱에 포함된 이미지를 호출하는 방법은 크게 3가지가 있습니다.
? file: 외부의 폴더나 갤러리에 있는 파일을 사용하는 경우
? asset: 앱을 만들 때 미리 넣어놓은 파일을 사용하는 경우
? memory: 배열이나 문자열 형태의 이미지 데이터를 사용하는 경우
이 실습에서는 이미지를 미리 넣어놓고 pubspec.yaml 파일에 assets로 선언했으므로 Image.asset(이미지_경로) 형태로 호출하면 됩니다.
[글상자] lib/imageWidget.dart
(...생략...)
class _ImageWidgetApp extends State<ImageWidgetApp> {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(title: Text('Image Widget'),),
body: Container(
child: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: <Widget>[
Image.asset('image/flutter_logo.png'), // 이미지를 불러오는 코드
],
),
),
),
);
}
}
[글상자 끝]
[7단계] 이제 main.dart 파일을 열고 ImageWidgetApp 클래스를 home으로 실행합니다. 이때 imageWidget.dart 파일을 import 구문으로 추가해야 합니다. 소스를 변경한 후 빌드하면 이미지가 출력되는 것을 확인할 수 있습니다.
100
[글상자] lib/main.dart
import 'package:flutter/material.dart';
import 'imageWidget.dart';
(...생략...)
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Material Flutter App',
theme: ThemeData(
primarySwatch: Colors.blue,
),
home: ImageWidgetApp(),
);
}
}
[글상자 끝]
[그림] 실행 결과


Image Widget
[그림 끝]
[8단계] 그런데 결과 화면의 이미지가 너무 크죠? 이럴 때는 imageWidget.dart 파일에서 이미지를 불러오는 코드를 수정해 크기를 줄여보세요. 넓이와 높이를 설정하고 저장하면 이미지가 작게 보입니다.
[글상자] lib/imageWidget.dart
(...생략...)
Image.asset('image/flutter.png', width: 200, height: 100) ,
(...생략...)
[글상자 끝]
아울러 지금처럼 이미지의 넓이와 높이를 직접 지정해야 할 때 fit를 이용하면 원하는 형태로 표시할 수 있습니다.
[글상자] lib/imageWidget.dart
(...생략...)
Image.asset('image/flutter.png', width: 200, height: 100, fit: BoxFit.fill) ,
(...생략...)
[글상자 끝]
101
fit를 BoxFit.fill로 설정하면 이미지에 설정한 값대로 넓이 200, 높이 100 크기로 보입니다.
[그림 4-11] fit 설정 전(왼쪽)과 후(오른쪽)의 이미지 크기 비교


Image Widget, Image Widget
[그림 끝]
[아하!] 이미지 크기를 조절하는 fit의 옵션값들
fit는 앱의 배경이나 이미지를 정해진 공간에 적절히 배치해야 할 때 응용할 수 있습니다. fit에 설정할 수 있는 옵션값은 다음과 같습니다. 이미지를 어떤 크기로 표시할지 골라서 적용해 보세요.
[표 4-1] fit 옵션값
fit 옵션값

설명

이미지 표시 예

BoxFit.fill

width, height를 가득 채워서 그린다.

[그림]



[그림 끝]

BoxFit.contain

이미지가 잘리지 않고 비율이 변하지 않는 범위에서 가능한 한 크게 그린다.

[그림]



[그림 끝]

BoxFit.cover

비율을 유지한 채 지정한 범위를 모두 덮도록 그린다. 이미지가 잘릴 수 있다.

[그림]



[그림 끝]

BoxFit.fitWidth

width를 꽉 채워서 그린다. 이미지가 잘릴 수 있다.

[그림]



[그림 끝]

102
fit 옵션값

설명

이미지 표시 예

BoxFit.fitHeight

height를 꽉 채워서 그린다. 이미지가 잘릴 수 있다.

[그림]



[그림 끝]

BoxFit.none

원본 이미지를 표시한다. 이미지가 잘릴 수 있다.

[그림]



[그림 끝]

BoxFit.scaleDown

전체 이미지가 나올 수 있게 이미지 크기를 조절해서 표시한다.

[그림]



[그림 끝]

[아하! 끝]
[Do it! 실습] 폰트 변경하기
[1단계] 이번에는 폰트 파일을 추가해서 앱에 표시되는 텍스트의 스타일을 변경해 보겠습니다. 먼저 사용하려는 폰트 파일을 준비합니다. 실습에서는 필자가 제공한 무료 폰트 파일(Pacifico-Regular.ttf)을 사용합니다.
프로젝트에 font라는 새 폴더를 만들고 준비한 폰트 파일을 끌어서 넣습니다[각주*].
[각주*] 폰트 파일 이름은 영어만 가능해요.[각주 끝]
[그림 4-12] font 폴더 생성 후 폰트 파일 추가


Pacifico-Regular.ttf
[그림 끝]
[2단계] pubspec.yaml 파일을 열고 폰트를 추가합니다. 앞에서 이미지를 추가했던 코드 아래 fonts:를 입력하고 그 하위에 폰트 정보를 다음처럼 입력합니다.
[글상자] pubspec.yaml
(...생략...)
flutter:
uses-material-design: true
assets:
- image/flutter_logo.png
fonts: // 폰트를 불러오는 코드
- family: Pacifico // 폰트를 불러오는 코드
fonts: // 폰트를 불러오는 코드
- asset: font/Pacifico-Regular.ttf // 폰트를 불러오는 코드
weight: 400 // 폰트를 불러오는 코드
[글상자 끝]
103
[3단계] 이제 앱 화면에 방금 추가한 폰트로 텍스트를 추가해 봅시다. imageWidet.dart 파일을 열고 Text를 추가한 후 style에 TextStyle() 함수를 이용해 텍스트 모양을 설정합니다. fontFamily에는 pubspec.yaml 파일에 설정한 폰트 이름인 Pacifico를 입력합니다.
[글상자] lib/imageWidet.dart
(...생략...)
class _ImageWidgetApp extends State<ImageWidgetApp> {
@override
Widget build(BuildContext context) {
(...생략...)
children: <Widget>[
Image.asset('image/flutter.png',
width: 200, height: 100, fit: BoxFit.fill),
Text('Hello Flutter', // Pacifico 폰트로 텍스트를 표시하는 코드
style: TextStyle(fontFamily: 'Pacifico', // Pacifico 폰트로 텍스트를 표시하는 코드
fontSize: 30, color: Colors.blue), // Pacifico 폰트로 텍스트를 표시하는 코드
) // Pacifico 폰트로 텍스트를 표시하는 코드
],
(...생략...)
[글상자 끝]
소스 파일을 저장하고 빌드하면 다음처럼 지정한 스타일로 텍스트가 표시됩니다.
[그림] 실행 결과


Image Widget, Hello Flutter
[그림 끝]
지금까지 pubspec.yaml 파일을 이용해서 앱에 이미지와 폰트를 추가해 보았습니다. pubspec.yaml 파일을 이용하면 안드로이드의 그래들이나 노드제이에스의 npm처럼 간단하게 패키지를 내려받아서 이용할 수도 있는데 이 방법은 07장에서 좀 더 자세히 다뤄 보겠습니다.
104
04-3 사용자와 상호작용하는 앱 만들기
지금까지 기본적인 플러터 위젯을 살펴보았습니다. 이번 절에서는 계산기 앱을 만들어 보면서 사용자와 상호작용하는 위젯을 살펴보겠습니다. 기본적으로 버튼은 사용자가 눌렀을 때 onPressed라는 이벤트가 발생합니다. 이때 어떤 기능을 수행할지 정의하는 것으로 사용자와 상호작용하는 앱을 구현할 수 있습니다.
[Do it! 실습] 덧셈 계산기 앱 만들기
[1단계] 먼저 widget_example이라는 이름으로 새 프로젝트를 생성하고 main.dart 파일에서 Column을 이용할 수 있게 StatefulWidget을 만듭니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[글상자] lib/main.dart
import 'package:flutter/material.dart';
void main() => runApp(MyApp());
class MyApp extends StatelessWidget {
static const String _title = 'Widget Example';
@override
Widget build(BuildContext context) {
return MaterialApp(
title: _title,
home: WidgetApp(),
);
}
}
class WidgetApp extends StatefulWidget {
WidgetApp({Key key}) : super(key: key);
@override
105
_WidgetExampleState createState() => _WidgetExampleState();
}
class _WidgetExampleState extends State<WidgetApp> {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Widget Example'),
),
body: Container(
child: Center(
child: Column(
),
),
),
);
}
}
[글상자 끝]
[2단계] 이제 Column에 children을 선언한 후 차례대로 Text, TextField, RaisedButton 위젯을 추가합니다. RaisedButton 위젯의 onPressed는 버튼이 눌렸을 때 발생하는 이벤트입니다.
[글상자] lib/main.dart
(...생략...)
child: Column(
children: <Widget>[
Text('flutter'),
TextField(),
RaisedButton(onPressed: () {
})
],
),
(...생략...)

onPressed → 버튼이 눌리면 발생하는 이벤트
[글상자 끝]
106
[3단계] 그런데 이 상태로 소스 파일을 저장하고 앱을 빌드하면 위젯이 서로 붙어 보입니다. 위젯 사이의 간격을 좀 더 벌렸으면 좋겠는데요, 이럴 때 쓰는 위젯이 Padding입니다 Padding을 이용해 위젯 사이의 간격을 벌려 봅시다.
[글상자] lib/main.dart
(...생략...)
child: Column(
children: <Widget>[
Padding(
padding: EdgeInsets.all(15),
child: Text('flutter'),
),
Padding(
padding: EdgeInsets.only(left: 20, right: 20),
child: TextField(),
),
Padding(
padding: EdgeInsets.all(15),
child: RaisedButton(onPressed: () {}),
),
],
),
(...생략...)
[글상자 끝]
[그림 4-13] 패딩 적용 전(왼쪽)과 후(오른쪽)


[그림 끝]
Padding을 이용해 EdgeInsets.all 옵션을 지정하면 사방으로 모든 공간에 여백이 생기고, EdgeInsets.only 옵션은 left, right, top, bottom에 원하는 값을 넣어 여백을 줄 수 있습니다.
107
[4단계] 이번에는 두 수를 입력받아서 덧셈 후 그 결과를 출력하는 기능을 추가해 보겠습니다. 사용자로부터 데이터 입력은 텍스트필드(TextField)를 사용하고 덧셈 후 텍스트 위젯에 출력해 보겠습니다. 텍스트필드를 다루려면 TextEditingController를 설정해야 합니다. _Widget ExampleState 클래스에 TextEditingController를 선언합니다. 그리고 Text에 출력할 문자열도 하나 선언합니다.
[글상자] lib/main.dart
(...생략...)
class _WidgetExampleState extends State<WidgetApp> {
String sum = '';
TextEditingController value1 = TextEditingController();
TextEditingController value2 = TextEditingController();
(...생략...)
[글상자 끝]
[5단계] 이제 텍스트필드에 controller를 선언하고 첫 번째 텍스트필드에는 value1을, 두 번째 텍스트필드[각주*]에는 value2를 입력합니다.
[각주*] 두 번째 텍스트필드는 앞에서 작성하지 않았으므로 Padding() 함수를 이용해 하나 더 추가합니다.[각주 끝]
[글상자] lib/main.dart
(...생략...)
Padding(
padding: EdgeInsets.only(left: 20, right: 20),
child: TextField(keyboardType: TextInputType.number, controller: value1),
),
Padding(
padding: EdgeInsets.only(left: 20, right: 20),
child: TextField(keyboardType: TextInputType.number, controller: value2),
),
(...생략...)
[글상자 끝]
텍스트필드에서 keyboardType에는 사용자에게 보일 키보드를 지정합니다. 위 코드처럼 number를 지정하면 숫자 입력용 키보드가 나타납니다.
108
[아하!] 플러터가 제공하는 키보드 유형
플러터는 자주 사용되는 키보드 유형을 미리 지정해 놓았습니다. 다음 표에서 확인할 수 있습니다.
[표 4-2] 플러터가 제공하는 키보드 유형
키보드 유형

설명

text

기본 텍스트

multiline

멀티 라인 텍스트. 메모 같이 여러 줄을 입력할 때 사용

number

숫자 키보드 표시

phone

전화번호 전용 키보드

datetime

날짜 입력 키보드

emailAddress

@ 표시 등 이메일 입력 키보드

url

주소 입력 창

[아하! 끝]
[6단계] RaisedButton도 꾸며 보겠습니다. child에 Row를 선언하고 children에 Icon과 Text를 입력해서 add 아이콘과 Text에 ‘더하기’라고 추가합니다.
[글상자] lib/main.dart
(...생략...)
child: RaisedButton(
child: Row(
children: <Widget>[
Icon(Icons.add),
Text('더하기')
],
),
color: Colors.amber,
onPressed: () {
}
),
(...생략...)
[글상자 끝]
109
이제 소스 파일을 저장하면 앱 화면이 다음처럼 나타나고 텍스트필드를 클릭하거나 터치하면 숫자 키보드가 올라옵니다.
[그림] 실행 결과


Widget Example, flutter, +더하기
[그림 끝]
[7단계] 더하기 버튼을 눌렀을 때 사용자가 입력한 두 수를 덧셈 후 출력해 봅시다. 먼저 계산된 결괏값 sum을 Text 위젯에 표시하는 부분을 작성합니다.
[글상자] lib/main.dart
(...생략...)
Padding(
padding: EdgeInsets.all(15),
child: Text(
'결과 : $sum',
style: TextStyle(fontSize: 20),
),
),
(...생략...)
[글상자 끝]
[8단계] 그런 다음 두 수를 덧셈하는 코드를 작성합니다. 두 수는 현재 사용자가 텍스트필드에 입력했으므로 이 값을 가져와야 합니다. 이처럼 텍스트필드에 있는 값을 가져오려면 TextEditingController.value.text 코드를 사용합니다. 덧셈 연산은 사용자가 더하기 버튼
110
을 눌렀을 때 이뤄져야 하므로 RaisedButton의 onPressed 이벤트 처리 부분에 작성합니다.
[글상자] lib/main.dart
(...생략...)
child: RaisedButton(
(...생략...)
onPressed: () {
setState(() {
int result = int.parse(value1.value.text) + int.parse(value2.value.text);
sum = '$result';
});
}
),
(...생략...)
[글상자 끝]
위 코드에 사용한 setState() 함수[각주*]는 위젯의 상태를 갱신하는 역할을 합니다. 즉, setState() 함수에서 데이터가 바뀌면 해당 데이터를 사용하는 모든 위젯에 알려줍니다. 따라서 위 코드에서 덧셈 결과를 sum 변수에 입력하면 sum 변수를 사용하는 위젯의 값이 바뀌어 출력됩니다.
[각주*] setState() 함수는 State 클래스를 상속받은 클래스에서만 호출할 수 있습니다.[각주 끝]
그리고 텍스트필드는 입력된 모든 데이터를 문자열로 인식하므로 연산하려면 반드시 정수로 바꿔줘야 합니다. 따라서 int.parse() 함수를 이용해 정수로 바꿨습니다. 하지만 이렇게 바꾸더라도 사용자가 숫자(1, 2, 3, ...)가 아닌 문자열(일, 이, 삼, ...)을 입력하면 오류가 발생합니다. 일단 이번 실습에서는 이런 예외 처리를 하지 않고 진행합니다.
이제 소스 파일을 저장하고 텍스트필드에 숫자를 입력 후 더하기 버튼을 누르면 합계에 덧셈 결과가 표시됩니다.
[그림] 실행 결과


Widget Example, 결과: 11.0, 5, 6
[그림 끝]
111
[Do it! 실습] 뺄셈, 곱셉, 나눗셈 기능 추가하기
앞선 실습에서 덧셈만 하는 계산기를 만들었습니다. 이번에는 뺄셈, 곱셈, 나눗셈까지 기능을 추가해 사칙연산 계산기를 완성해 보겠습니다. 버튼을 더 만들어도 좋지만 여기서는 위젯을 학습하는 목적으로 펼침 버튼(DropdownButton)을 이용해 만들어 보겠습니다.
[1단계] 먼저 main.dart 파일을 열고 Column의 위젯 목록에서 패딩을 하나 추가합니다. 그리고 그 안에 DropdownButton을 이용해 펼침 버튼을 하나 생성합니다.
[글상자] lib/main.dart
(...생략...)
Padding(
padding: EdgeInsets.all(15),
child: DropdownButton(items: null, onChanged: null),
)
(...생략...)
[글상자 끝]
DropdownButton에 전달한 items는 펼침 버튼에 표시할 아이템 목록이고, onChanged는 아이템이 바뀔 때 처리할 이벤트입니다. 우선 펼침 버튼에 표시할 아이템 목록을 만들어야겠네요. _buttonList라는 리스트를 선언하고 아이템을 입력합니다. 그리고 DropdownButton 형식의 리스트를 하나 더 선언합니다.
[글상자] lib/main.dart
(...생략...)
class _WidgetExampleState extends State<WidgetApp> {
List _buttonList = ['더하기' , '빼기' , '곱하기' , '나누기'];
List<DropdownMenuItems<String>> _dropDownMenuItems = new List();
(...생략...)
[글상자 끝]
[2단계] 이제 앞에서 정의한 아이템 목록을 펼침 버튼에 넣겠습니다. 이 작업은 build 전에 수행해도 되지만, 「03-2」절에서 스테이트풀의 생명주기를 배웠으므로 이를 활용해 상태를 초기화하는 initState() 함수에 작성해 보겠습니다. _WidgetExampleState 클래스에 initState() 함수를 재정의하고 다음 코드를 추가합니다.
112
[글상자] lib/main.dart
(...생략...)
class _WidgetExampleState extends State<WidgetApp> {
List _buttonList = ['더하기' , '빼기' , '곱하기' , '나누기'];
List<DropdownButton<String>> _dropDownMenuItems = new List();
String _buttonText;
(...생략...)
@override
void initState() {
super.initState();
for(var item in _buttonList) {
_dropDownMenuItems.add(DropdownMenuItem(value: item, child: Text(item)));
}
_buttonText = _dropDownMenuItems[0].value;
}
(...생략...)
[글상자 끝]
initState() 함수에서 _buttonList에 있는 문자열을 하나씩 빼서 _dropDownMenuItems에 추가함으로써 아이템 목록을 펼침 버튼에 넣을 메뉴 아이템으로 만듭니다.
[3단계] 이제 앞서 1단계에서 작성한 펼침 버튼의 items와 onChanged 이벤트 처리 함수에 다음 코드를 작성함으로써 메뉴 아이템을 펼침 버튼에 넣습니다.
[글상자] lib/main.dart
(...생략...)
Padding(
padding: EdgeInsets.all(15),
child: DropdownButton(items: _dropDownMenuItems, onChanged: (value) {
setState(() {
_buttonText = value;
});
}, value: _buttonText,),
)
(...생략...)
[글상자 끝]
113
이렇게 하면 사용자가 펼침 버튼을 클릭해 값을 바꿀 때마다 onChanged 이벤트가 발생해 _buttonText값이 사용자가 선택한 값으로 바뀝니다.
소스 파일을 저장하고 앱을 빌드하면 펼침 버튼이 보입니다. 이 버튼을 클릭하면 아이템 목록이 나타나고 목록에서 하나를 선택할 수 있습니다.
[그림] 실행 결과


Widget Example, 합계:, +더하기, 더하기, 빼기, 곱하기, 나누기
[그림 끝]
[4단계] 이번에는 사용자가 펼침 버튼에서 아이템을 선택했을 때 연산 버튼(RaisedButton)의 값도 사용자가 선택한 값으로 바뀌도록 수정해 보겠습니다. 간단하게 연산 버튼의 위젯 목록에서 Text 위젯에 표시할 값을 사용자가 선택한 값이 담긴 _buttonText로 넣어줍니다.
[글상자] lib/main.dart
(...생략...)
child: Row(
children: <Widget>[
Icon(Icons.add),
Text(_buttonText)
],
),
(...생략...)
[글상자 끝]
[5단계] 이제 펼침 버튼을 눌러 연산을 선택하고 연산 버튼을 누르면 텍스트필드에 있는 두 수를 이용해 사용자가 선택한 연산을 수행하도록 다음 코드를 추가합니다.
114
[글상자] lib/main.dart
(...생략...)
child: RaisedButton(
child: Row(
children: <Widget>[Icon(Icons.add), Text(_buttonText)],
),
color: Colors.amber,
onPressed: () {
setState(() {
var value1Int = double.parse(value1.value.text);
var value2Int = double.parse(value2.value.text);
var result;
if (_buttonText == '더하기') {
result = value1Int + value2Int;
} else if (_buttonText == '빼기') {
result = value1Int - value2Int;
} else if (_buttonText == '곱하기') {
result = value1Int * value2Int;
} else {
result = value1Int / value2Int;
}
sum = '$result';
});
})),
(...생략...)
[글상자 끝]
[그림] 실행 결과


Widget Example, 결과: 6.0, 2, 3, +곱하기, 곱하기
[그림 끝]
소스 파일을 저장하고 앱을 빌드하면 사칙연산을 할 수 있는 계산기 앱이 실행됩니다. 펼침 버튼을 눌러 연산을 선택하고 연산 버튼을 누르면 사용자가 텍스트필드에 입력한 두 수를 대상으로 연산을 수행한 후 결괏값을 출력합니다.
지금까지 기본적인 플러터 위젯을 살펴보았습니다. 지금은 플러터 앱의 기본을 배우는 단계이므로 코드를 예쁘게 만드는 것보다는 어디서 어떻게 활용하는지를 아는 것이 더 중요합니다. 자신감을 가지고 한 걸음씩 나아가다 보면 원하는 앱을 만들 수 있을 것입니다.
115
05 탭바와 리스트 만들기
플러터 앱을 만들 때 한 화면에 너무 많은 기능을 넣으면 화면이 복잡해질 수 있습니다. 이럴 때는 탭바라는 위젯을 사용합니다. 탭바는 사용자가 자주 이용할만한 기능별로 메뉴를 만들어서 배치하고 메뉴마다 화면을 연결해 보여주는 위젯입니다. 이번 장에는 탭바와 함께 많은 데이터를 효율적으로 보여주는 리스트를 구현하는 방법도 살펴보겠습니다.
05-1 탭바로 화면 이동하기
05-2 목록을 보여주는 리스트뷰 만들기
116
05-1 탭바로 화면 이동하기
앱을 만들다 보면 모든 내용과 기능을 한 화면에 보여줄 수 없을 때가 있습니다. 이때 각 화면을 탭(tab)으로 연결한 탭바를 이용하면 관련 있는 내용끼리 묶을 수 있습니다. 그리고 메인 화면에서 탭을 눌러 화면을 이동할 수 있으므로 좀 더 직관적인 앱을 만들 수 있죠. 이러한 탭바는 화면 위나 아래에 놓을 수 있습니다.
[그림 5-1] 탭이 위에 있는 페이스북 앱(왼쪽)과 아래에 있는 카카오톡 앱(오른쪽)


facebook, 조준수선생님/감사합니다.
[그림 끝]
[Do it! 실습] 여러 페이지 만들고 이동하기
여러 화면을 만들고 각 화면을 탭바에 연결해 사용자가 탭을 눌렀을 때 각 화면으로 이동하는 앱을 구현해 보겠습니다. 모바일 앱 개발에서 이와 같은 기능을 내비게이션(navigation)이라고 하는데, 이와 관련해서는 07장에서 더 자세하게 다룹니다. 이번 실습에서는 간단하게 탭바를 이용해 화면을 이동하는 기능을 구현해 보겠습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] 먼저 tabbar_example이라는 이름으로 새로운 플러터 프로젝트를 생성합니다. lib 폴더 아래에 sub 폴더를 추가[각주*]한 후 firstPage.dart 파일을 만듭니다. 이 파일을 열고 Stateless Widget을 상속받는 FirstApp 클래스를 생성하고 스캐폴드 위젯 안에서 body의 Text에 ‘첫 번째 페이지’라고 입력합니다.
[각주*] 안드로이드 스튜디오 탐색 창에서 lib 폴더에 마우스 오른쪽을 누르고 [New → Package] 메뉴를 눌러 폴더를 생성할 수 있어요.[각주 끝]
117
[글상자] lib/sub/firstPage.dart
import 'package:flutter/material.dart';
class FirstApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return Scaffold(
body: Container(
child: Center(
child: Text('첫 번째 페이지'),
),
),
);
}
}
[글상자 끝]
[2단계] 다시 sub 폴더에 secondPage.dart 파일을 만든 후 FirstApp 클래스와 똑같이 Second App 클래스를 작성합니다. 이때 Text 위젯에는 ‘두 번째 페이지’라고 입력합니다.
[글상자] lib/sub/secondPage.dart
import 'package:flutter/material.dart';
class SecondApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return Scaffold(
body: Container(
child: Center(
child: Text('두 번째 페이지'),
),
),
);
}
}
[글상자 끝]
118
[3단계] 탭바 위젯을 사용하려면 탭 컨트롤러가 필요합니다. main.dart 파일을 열고 _MyHomePageState 클래스를 다음처럼 수정합니다. initState() 함수를 이용해 TabController를 선언합니다.
[글상자] lib/main.dart
(...생략...)
class _MyHomePageState extends State<MyHomePage> {
TabController controller;
@override
void initState() {
super.initState();
controller = TabController(length: 2, vsync: this);
}
}
[글상자 끝]
TabController에서 length에는 몇 개의 탭을 만들지 지정하고, vsync에는 탭이 이동했을 때 호출되는 콜백 함수를 어디서 처리할지 지정합니다. 지금은 vsync: this 코드에서 오류가 발생합니다. 탭 컨트롤러는 여러 화면을 이동하는 역할을 하므로 기본적으로 애니메이션을 사용하는데, this가 가리키는 _MyHomePageState 클래스에 이와 관련된 코드가 빠졌기 때문입니다.
_MyHomePageState 클래스에 with 키워드[각주*]를 추가하고 SingleTickerProviderStateMixin 클래스를 지정하면 vsync: this 코드에 오류가 사라집니다.
[각주*] with는 여러 클래스를 재사용할 수 있는 편리한 키워드입니다.[각주 끝]
[글상자] lib/main.dart
(...생략...)
class _MyHomePageState extends State<MyHomePage>
with SingleTickerProviderStateMixin {
(...생략...)
}
[글상자 끝]
119
현재 하나의 화면을 조정할 수 있게 만든 클래스에 with를 이용해 SingleTickerProviderStateMixin 클래스를 추가로 상속함으로써 탭을 눌렀을 때 _MyHomePageState 클래스에서 애니메이션 동작을 처리할 수 있게 했습니다. 만약, SingleTickerProviderStateMixin 클래스를 상속에 포함하지 않으면 _MyHomePageState 클래스에서 탭 컨트롤러를 만들 수 없으므로 주의 바랍니다.
[4단계] 「03-2」절에서 살펴본 스테이트풀의 생명주기에서 위젯의 상태 관리를 완전히 끝내는(State 객체 소멸) dispose() 함수를 기억할 겁니다. 스테이트풀이 마지막에 호출하는 함수입니다. 탭 컨트롤러는 애니메이션을 이용하므로 dispose() 함수를 호출해 주어야 메모리 누수를 막을 수 있습니다.
_MyHomePageState 클래스 안에 dispose() 함수를 재정의하는 코드를 추가합니다.
[글상자] lib/main.dart
(...생략...)
class _MyHomePageState extends State<MyHomePage>
with SingleTickerProviderStateMixin {
(...생략...)
@override
void dispose() {
controller.dispose();
super.dispose();
}
}
[글상자 끝]
[5단계] 이제 build() 함수를 이용해 화면을 구성해 보겠습니다. 스캐폴드로 appBar와 body 그리고 bottomNavigation을 선언합니다.
[글상자] lib/main.dart
(...생략...)
class _MyHomePageState extends State<MyHomePage>
with SingleTickerProviderStateMixin {
@override
Widget build(BuildContext context) {
120
return Scaffold(
appBar: AppBar(
title: Text('TabBar Example'),
),
body:
bottomNavigationBar:
);
}
[글상자 끝]
body와 bottomNavigaionBar는 다음처럼 작성합니다. body에는 TabBarView 위젯을, bottomNavigaionBar에는 TabBar 위젯을 만듭니다.
[글상자] lib/main.dart
(...생략...)
}
import 'package:flutter/material.dart';
import 'sub/firstPage.dart'; // firstPage.dart 임포트
import 'sub/secondPage.dart'; // secondPage.dart 임포트
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('TabBar Example'),
),
body: TabBarView(
children: <Widget>[FirstApp(), SecondApp()],
controller: controller,
),
bottomNavigationBar: TabBar(tabs: <Tab>[
Tab(icon: Icon(Icons.looks_one, color: Colors.blue),) ,
Tab(icon: Icon(Icons.looks_two, color: Colors.blue),)
], controller: controller,
)
);
}
}
[글상자 끝]
121
탭 컨트롤러에 length를 2로 지정했으므로 bottomNavigationBar에 탭을 두 개 만들어서 각각 파란색 숫자 아이콘을 넣었습니다. 탭에는 아이콘 말고도 텍스트나 다른 위젯을 넣을 수도 있습니다. 그리고 initState() 함수에 만들어 둔 탭 컨트롤러가 담긴 controller를 입력했습니다.
body에는 TabBarView의 children을 <Widget>이라고 선언하고 각각 FirstApp(), SecondApp()을 넣었습니다. 그리고 다른 다트 파일에 정의된 클래스를 사용했으므로 import 구문으로 각 파일의 경로를 추가했습니다.
[6단계] 이제 프로젝트를 빌드하면 앱이 실행됩니다. 첫 번째 페이지에서 아래쪽 탭을 클릭하거나 화면을 왼쪽, 오른쪽으로 쓸어 넘기면 각 페이지로 이동하는 애니메이션을 볼 수 있습니다.
[그림] 실행 결과


TabBar Example-첫 번째 페이지
TabBar Example-두 번째 페이지
[그림 끝]
지금까지 만든 앱의 위젯 구성은 다음과 같습니다.
122
[그림 5-2] 위젯 구성


- MaterialApp
1. appBar
1) Text
2. Body
2-1. TabBarView
2-1-1. FirstApp
2-1-1-1. Scaffold
1) appBar
2) body
2-1-2. SecondApp
2-1-2-1. Scaffold
1) appBar
2) body
3. bottomNavigationBar
1) TabBar
[그림 끝]
[아하!] 탭 컨트롤러 활용법
탭 컨트롤러(TabController)는 탭의 위치나 애니메이션 상태 등을 확인할 수 있는 기능을 제공합니다. 탭이 이동할 때 어떤 동작을 추가하고 싶으면 탭이 이동할 때 호출되는 addListener() 함수를 사용하면 좋습니다.
[글상자]
controller.addListener(() {
if(!controller.indexIsChanging) {
print("이전 index, ${controller.previousIndex}");
print("현재 index, ${controller.index}");
}
});
[글상자 끝]
indexIsChanging 속성은 탭이 현재 이동 중인지를 나타내고 previousIndex는 이전에 선택된 탭 번호(첫 번째 탭은 0부터 시작), index는 현재 선택된 탭 번호를 나타냅니다. 이처럼 탭 컨트롤러에는 다양한 정보가 들어 있습니다. 탭 컨트롤러에 관해 더 자세한 내용은 다음 API 문서에서 확인할 수 있습니다.
? https://api.flutter.dev/flutter/material/TabController-class.html
[아하! 끝]
123
05-2 목록을 보여주는 리스트뷰 만들기
스마트폰은 대부분 세로로 긴 형태여서 앱을 만들 때 정보를 목록으로 나열하는 화면 구성을 많이 사용합니다. 인스타그램이나 페이스북 그리고 구글이나 네이버 검색도 목록으로 구성되었습니다. 이처럼 대부분 앱이 세로로 긴 목록으로 화면을 구성하다 보니 사용자들도 세로 스크롤을 자연스럽게 여깁니다. 이번 절에서는 리스트뷰를 이용해서 많은 정보를 제공하는 방법을 살펴보겠습니다.
[Do it! 실습] 동물 소개 페이지 만들기
[1단계] 리스트뷰를 이용해 동물 목록을 보여주는 앱을 만들어 보겠습니다. 먼저, listview_example이라는 이름으로 새로운 플러터 프로젝트를 만듭니다. 그리고 「05-1」절에서 만든 탭바가 구현된 다트 파일에 이어서 작성하기 위해 tabbar_example 프로젝트의 lib 폴더에 있는 파일들을 그대로 복사해서 현재 프로젝트의 lib 폴더에 붙여 넣습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[그림 5-3] 이전 프로젝트의 lib 폴더 복사와 붙여 넣기


lib
[그림 끝]
그리고 프로젝트 루트에 repo/images 폴더를 만들어 실습 파일로 제공한 동물 이미지를 추가합니다.
124
[그림 5-4] 실습에 사용할 동물 이미지 추가


repo
[그림 끝]
이미지를 넣은 후 pubspec.yaml 파일을 열고 다음 코드를 추가합니다.
[글상자] pubspec.yaml
(...생략...)
flutter:
uses-material-design: true
assets:
- repo/images/bee.png
- repo/images/cat.png
- repo/images/cow.png
- repo/images/dog.png
- repo/images/fox.png
- repo/images/monkey.png
- repo/images/pig.png
- repo/images/wolf.png
[글상자 끝]
코드 추가 후 pubspec.yaml 파일을 저장하면 소스 편집 창 위에 ‘Flutter commands’ 줄이 나타나는데, 여기서 <Pub get>을 클릭해 이미지를 사용할 수 있게 준비합니다.
[그림 5-5] 이미지 사용 준비


Pub get
[그림 끝]
125
[2단계] lib 폴더에 animalItem.dart 파일을 추가하고 동물 정보를 담당할 Animal 클래스를 생성합니다.
[글상자] lib/animalItem.dart
import 'package:flutter/material.dart';
class Animal {
String imagePath;
String animalName;
String kind;
bool flyExist = false;
Animal(
{@required this.animalName,
@required this.kind,
@required this.imagePath,
this.flyExist});
}
[글상자 끝]
동물 이름(animalName), 동물 종류(kind), 동물 이미지 경로(imagePath), 그리고 날 수 있는지(flyExist)에 대한 정보를 담을 변수를 선언했습니다. flyExist 논리형 변수는 false를 기본값으로 해놓고 새로운 Animal 객체를 선언할 때 이를 입력받습니다.
Animal 클래스의 생성자 함수를 보면 Animal 객체를 생성할 때 전달받은 동물 정보가 중괄호 안에 있는 각각의 매개변수에 대입됩니다. 매개변수 앞에 붙은 @required 애너테이션은 함수를 호출할 때 꼭 전달해야 하는 값이라는 뜻입니다.
[3단계] 클래스를 만들었으면 main.dart 파일을 열고 앞 단계에서 만든 animalItem.dart 파일을 import 구문으로 불러옵니다. 그리고 _MyHomePageState 클래스의 TabController 선언 아래 동물 정보를 담을 List를 선언합니다.
[글상자] lib/main.dart
import 'package:flutter/material.dart';
import './animalItem.dart';
(...생략...)
126
class _MyHomePageState extends State<MyHomePage> with SingleTickerProviderStateMixin
{
TabController controller;
List<Animal> animalList = List();
(...생략...)
}
(...생략...)
[글상자 끝]
이제 각 동물의 정보를 입력해 Animal 객체를 생성하고 동물 목록 animalList에 추가합니다. 이 작업은 initState() 함수에 작성합니다.
[글상자] lib/main.dart
(...생략...)
// animalList를 추가한 initState() 함수
@override
void initState() {
super.initState();
controller = TabController(length: 2, vsync: this);
animalList.add(Animal(animalName: "벌", kind: "곤충",
imagePath: "repo/images/bee.png"));
animalList.add(Animal(animalName: "고양이", kind: "포유류",
imagePath: "repo/images/cat.png"));
animalList.add(Animal(animalName: "젖소", kind: "포유류",
imagePath: "repo/images/cow.png"));
animalList.add(Animal(animalName: "강아지", kind: "포유류",
imagePath: "repo/images/dog.png"));
animalList.add(Animal(animalName: "여우", kind: "포유류",
imagePath: "repo/images/fox.png"));
animalList.add(Animal(animalName: "원숭이", kind: "영장류",
imagePath: "repo/images/monkey.png"));
animalList.add(Animal(animalName: "돼지", kind: "포유류",
imagePath: "repo/images/pig.png"));
animalList.add(Animal(animalName: "늑대", kind: "포유류",
imagePath: "repo/images/wolf.png"));
}
(...생략...)
[글상자 끝]
127
[4단계] 이제 lib/sub 폴더에 있는 firstPage.dart 파일을 엽니다. FirstApp 클래스에서 animalList 데이터를 받아올 수 있도록 클래스를 수정합니다. 처음에 FirstApp 객체를 생성할 때 목록도 있어야 하므로 final로 선언합니다. 그런데 final로 선언하면 오류가 발생합니다. 이럴 때는 list를 매개변수로 입력받는 생성자를 추가하면 됩니다. 똑같은 코드를 secondPage.dart 파일의 같은 위치에도 추가하되 생성자 이름만 SecondApp으로 바꿉니다.
[글상자] lib/sub/firstPage.dart
import 'package:flutter/material.dart';
import '../animalItem.dart'; // Animal 클래스 사용을 위한 import
class FirstApp extends StatelessWidget {
final List<Animal> list; // Animal List 선언
FirstApp({Key key, this.list}) : super(key: key);
(...생략...)
[글상자 끝]
[5단계] 각 탭을 선택할 때 표시할 리스트를 생성하기 위해 main.dart 파일을 열고 FirstApp과 SecondApp 클래스 모두에 동물 목록을 전달합니다. 그리고 앱바에 표시할 제목도 바꿉니다.
[글상자] lib/main.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Listview Example'),
),
body: TabBarView(
children: <Widget>[
FirstApp(list: animalList),
SecondApp(list: animalList)
],
(...생략...)
[글상자 끝]
128
[6단계] 이제 전달받은 list를 통해서 리스트뷰를 만들어 보겠습니다. 리스트뷰를 위젯으로 만드는 방법은 여러 가지가 있지만, 여기서는 ListView.builder를 사용해 보겠습니다. ListView.builder를 사용하려면 itemBuilder가 필요합니다.
firstPage.dart 파일을 열고 build() 함수 안에 있는 Center에 기존 내용을 다음처럼 대체합니다. 리스트뷰의 아이템은 Card로 만듭니다.
[글상자] lib/sub/firstPage.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
body: Container(
child: Center(
child: ListView.builder(itemBuilder: (context, position) {
return Card( // 이 부분에 위젯을 이용해 데이터를 표시
);
}),
),
),
);
}
(...생략...)
[글상자 끝]
itemBuilder는 BuildContext와 int를 반환합니다. BuildContext는 위젯 트리에서 위젯의 위치를 알려주며 int는 아이템의 순번을 의미합니다. 위 코드에서 각각 context와 position에 담았습니다.
[7단계] 카드에 이미지와 텍스트 위젯을 이용해 동물 이름을 출력하는 코드를 작성합니다.
[글상자] lib/sub/firstPage.dart
(...생략...)
child: ListView.builder(
itemBuilder: (context, position) {
return Card(
child: Row(
129
children: <Widget>[
Image.asset(
list[position].imagePath,
height: 100,
width: 100,
fit: BoxFit.contain,
),
Text(list[position].animalName)
],
),
);
},
itemCount: list.length),
(...생략...)

itemCount: list.length → 아이템 개수만큼만 스크롤 할 수 있게 제한
[글상자 끝]
position은 리스트에서 아이템의 위치를 나타냅니다. 만약 position이 1이면 list[1] 코드는 목록에서 두 번째 아이템(첫 번째 아이템은 0)을 의미합니다. 각각의 아이템은 Animal 객체이므로 리스트에 .animalName, .imagePath와 같은 코드를 붙여 동물 정보를 가져올 수 있습니다.
프로젝트를 빌드한 후 앱을 실행하면 다음과 같은 화면이 보입니다.
[그림] 실행 결과


Listview Example: 벌, 고양이, 염소, 강아지, 여우, 원숭이
[그림 끝]
130
[Do it! 실습] 터치 이벤트 처리로 알림 창 띄우기
이번에는 목록에서 동물을 터치했을 때 해당 동물 정보를 보여주는 알림 창을 띄워 봅시다.
[1단계] 먼저 터치 이벤트를 처리해야 하므로 GestureDetector 위젯을 사용합니다. Gesture Detector를 작성하고 앞선 실습에서 만들어 둔 Card를 child에 넣습니다.
[글상자] lib/sub/firstPage.dart
(...생략...)
child: ListView.builder(
itemBuilder: (context, position) {
return GestureDetector(
child: Card(
(...생략...)
),
);
},
itemCount: list.length),
(...생략...)
[글상자 끝]
[2단계] GestureDetector 위젯은 한 번 터치, 두 번 터치, 길게 누르기, 끌기 등 손가락 제스처와 관련된 많은 이벤트를 처리합니다. 이 실습에서는 한 번 터치했을 때 알림 창을 띄우도록 onTap 이벤트에 showDialog() 함수를 호출합니다.
[글상자] lib/sub/firstPage.dart
(...생략...)
child: ListView.builder(
itemBuilder: (context, position) {
return GestureDetector(
child: Card(
(...생략...)
),
onTap: () {
AlertDialog dialog = AlertDialog(
content: Text(
'이 동물은 ${list[position].kind}입니다',
131
style: TextStyle(fontSize: 30.0),
),
);
showDialog(
context: context,
builder: (BuildContext context) => dialog);
},
);
},
itemCount: list.length),
(...생략...)
[글상자 끝]
AlertDialog를 이용해 dialog라는 이름의 알림 창을 만들고 내용과 스타일을 content와 style로 설정합니다. 그리고 showDialog() 함수를 호출해 알림 창을 띄웁니다. 모든 작업이 끝났다면 소스를 저장합니다. 그런 후 목록에서 동물을 터치하면 다음과 같은 알림 창이 나타납니다.
[그림] 실행 결과


이 동물은 포유류입니다
[그림 끝]
[Do it! 실습] 동물을 추가하는 화면 만들기
이번에는 동물을 추가로 등록하는 화면을 만들어 보겠습니다. 앞에서 이 프로젝트를 만들 때 「05-1」절에서 만든 탭바를 이용하려고 파일을 복사한 후 이어서 작업했습니다. 지금까지 만든 동물 목록이 첫 번째 페이지였다면 두 번째 페이지에는 동물을 추가하는 화면을 만들어 보겠습니다.
132
[1단계] secondPage.dart 파일에 작성된 SecondApp 클래스를 다음처럼 수정하고 이 클래스를 상속받는 _SecondApp 클래스를 작성합니다. secondPage.dart 파일의 전체 내용을 다음처럼 수정해 기본 골격을 만듭니다.
[글상자] lib/sub/secondPage.dart
import 'package:flutter/material.dart';
import '../animalItem.dart';
class SecondApp extends StatefulWidget {
@override
State<StatefulWidget> createState() => _SecondApp();
List<Animal> list;
SecondApp({Key key, @required this.list}) : super(key: key);
}
class _SecondApp extends State<SecondApp> {
@override
Widget build(BuildContext context) {
return Scaffold(
body: Container(
child: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: <Widget>[ // 이제부터 여기 대괄호 안에 위젯을 담아요
] // 이제부터 여기 대괄호 안에 위젯을 담아요
),
),
),
);
}
}
[글상자 끝]
SecondApp 클래스의 코드를 보면 기존의 StatefulWidget을 만드는 방식과 다른 것을 알 수 있습니다. 다트에서는 반환값을 한 줄로 표현하고자 할 때 => 화살표를 이용할 수 있습니다.
즉, createState() => _SecondApp() 코드는 _SecondApp()을 반환하는 createState() 함수를 호출한다는 의미입니다.
133
[2단계] 그런 다음 <Widget>[] 배열 안에 사용자가 동물 이름을 입력할 텍스트필드를 하나 추가합니다. 키보드 유형은 text로 설정합니다. 그리고 nameController를 사용하기 위해 TextEditingController() 함수의 반환값을 받는 변수를 final로 선언합니다.
[글상자] lib/sub/secondPage.dart
(...생략...)
class _SecondApp extends State<SecondApp> {
final nameController = TextEditingController();
(...생략...)
children: <Widget>[
TextField(
controller: nameController,
keyboardType: TextInputType.text,
maxLines: 1,
),
]
(...생략...)
[글상자 끝]
[3단계] 라디오 버튼을 이용해 동물의 종류를 선택할 수 있도록 텍스트필드 아래 다음 코드를 추가합니다. 이때 각 위젯이 가로로 배치되도록 Row 안에 작성합니다.
[글상자] lib/sub/secondPage.dart
(...생략...)
class _SecondApp extends State<SecondApp> {
final nameController = TextEditingController();
int _radioValue = 0;
(...생략...)
children: <Widget>[
TextField( ...생략... ),
Row(
children: <Widget>[
Radio(value: 0, groupValue: _radioValue, onChanged: _radioChange),
Text('양서류'),
Radio(value: 1, groupValue: _radioValue, onChanged: _radioChange),
134
Text('파충류'),
Radio(value: 2, groupValue: _radioValue, onChanged: _radioChange),
Text('포유류'),
],
),
]
(...생략...)
_radioChange(int value) {
setState(() {
_radioValue = value;
});
}
}
[글상자 끝]
라디오 버튼을 만들려면 value, groupValue, onChanged 값을 지정해야 합니다. value는 인덱스값이고 groupValue는 그룹화[각주*], onChanged는 이벤트 처리입니다. value에는 각각 0, 1, 2를 넣어 인덱스를 부여합니다. 그리고 groupValue에는 int형 _radioValue를 선언해서 넣습니다. 초깃값은 0으로 합니다. onChanged에는 라디오 버튼이 눌렸을 때 호출할 함수를 라디오 버튼의 인덱스값을 _radioValue 변수에 넣는 _radioChange() 함수로 정의해서 넣습니다.
[각주*] 라디오 버튼은 같은 그룹에서 하나만 선택할 수 있는 특징이 있어요.[각주 끝]
[4단계] 이번에는 동물이 날 수 있는지를 선택하는 체크박스를 추가합니다.
[글상자] lib/sub/secondPage.dart
(...생략...)
class _SecondApp extends State<SecondApp> {
final nameController = TextEditingController();
int _radioValue = 0;
bool flyExist = false;
(...생략...)
children: <Widget>[
TextField( ...생략... ),
Row(children: <Widget>[ ...생략... ],),
135
Row(
children: <Widget>[
Text('날 수 있나요?'),
Checkbox(
value: flyExist,
onChanged: (check) {
setState(() {
flyExist = check;
});
})
],
),
]
(...생략...)
[글상자 끝]
[5단계] 마지막으로 동물 이미지를 고를 수 있게 합니다. 이미지를 클릭하면 해당 이미지를 선택하는 식으로 코드를 작성합니다. 그리고 소스를 빌드한 후 실행해 보세요.
[글상자] lib/sub/secondPage.dart
(...생략...)
class _SecondApp extends State<SecondApp> {
final nameController = TextEditingController();
int _radioValue = 0;
bool flyExist = false;
var _imagePath;
(...생략...)
children: <Widget>[
TextField( ...생략... ),
Row(children: <Widget>[ ...생략... ],), // 동물 종류 선택 라디오 버튼
Row(children: <Widget>[ ...생략... ],), // 날 수 있는지 선택 체크박스
Row(
children: <Widget>[
GestureDetector(
child: Image.asset('repo/images/cow.png', width: 80),
onTap: () {
136
_imagePath = 'repo/images/cow.png';
},
),
GestureDetector(
child: Image.asset('repo/images/pig.png', width: 80),
onTap: () {
_imagePath = 'repo/images/pig.png';
},
),
GestureDetector(
child: Image.asset('repo/images/bee.png', width: 80),
onTap: () {
_imagePath = 'repo/images/bee.png';
},
),
GestureDetector(
child: Image.asset('repo/images/cat.png', width: 80),
onTap: () {
_imagePath = 'repo/images/cat.png';
},
),
GestureDetector(
child: Image.asset('repo/images/dog.png', width: 80),
onTap: () {
_imagePath = 'repo/images/dog.png';
},
),
],
)
]
(...생략...)
[글상자 끝]
[그림] 실행 결과


Listview Example
RIGHT OVERFLOWED BY 7.3 PIXELS - 그림을 다시 배치하라는 표시
[그림 끝]
137
[6단계] 앱을 실행 후 동물을 추가하는 화면에서 고양이 그림 오른쪽에 노란색과 검은색 빗금이 보이나요? 이 표시는 그림이 화면을 벗어났으니 위젯을 다시 배치하라는 의미입니다. 마지막 강아지 그림의 GestureDetector 위젯을 삭제하여 이미지 개수를 5개에서 4개로 바꾸겠습니다. 그리고 위젯들을 양쪽 여백 사이에 균일하게 배치하기 위해 각각의 Row 위젯에 mainAxisAlignment를 spaceAround값으로 설정합니다.
[글상자] lib/sub/secondPage.dart
(...생략...)
children: <Widget>[
TextField( ...생략... ),
Row(children: <Widget>[ ...생략... ],
mainAxisAlignment: MainAxisAlignment.spaceAround),
Row(children: <Widget>[ ...생략... ],
mainAxisAlignment: MainAxisAlignment.spaceAround),
Row(children: <Widget>[ ...생략...
〔GestureDetector(〕 // 강아지 그림 표시 코드를 지워요
〔child: Image.asset('repo/images/dog.png', width: 80),〕 // 강아지 그림 표시 코드를 지워요
〔onTap: () {〕 // 강아지 그림 표시 코드를 지워요
〔_imagePath = 'repo/images/dog.png';〕 // 강아지 그림 표시 코드를 지워요
〔},〕 // 강아지 그림 표시 코드를 지워요
〔),〕 // 강아지 그림 표시 코드를 지워요
mainAxisAlignment: MainAxisAlignment.spaceAround),
]
(...생략...)
[글상자 끝]
[그림] 실행 결과


Listview Example
? 양서류, ○ 파충류, ○ 포유류
날 수 있나요? ?
[그림 끝]
138
[7단계] 이제 children의 마지막 위젯으로 <동물 추가하기> 버튼을 만들어 줍니다.
[글상자] lib/sub/secondPage.dart
(...생략...)
children: <Widget>[
TextField( ...생략... ),
Row( ...생략... ),
Row( ...생략... ),
Row( ...생략... ),
RaisedButton(
child: Text('동물 추가하기'),
onPressed: () {}),
]
(...생략...)
[글상자 끝]
이제 앱을 실행하고 2번 탭을 클릭하면 동물을 추가하는 화면이 나타납니다. 아직 추가 기능은 동작하지 않습니다. 다음 실습에서 이 기능을 구현하겠습니다.
[그림] 실행 결과


Listview Example
○ 양서류, ○ 파충류, ? 포유류
날 수 있나요? ?
동물 추가하기
[그림 끝]
139
[아하!] 에뮬레이터에서는 한글을 어떻게 입력하나요?
안드로이드 에뮬레이터는 문자를 입력할 때 기본적으로 영문 키보드만 나타납니다. 그러므로 한글을 입력하려면 한글 키보드를 추가해야 합니다. 한글 키보드를 추가하려면 텍스트 필드를 눌러 키보드가 올라온 상태에서 […]를 누르고 [Settings]를 누릅니다. 설정 메뉴 중 [Languages]를 누르고 <ADD KEYBOARD>를 눌러 키보드 목록을 부릅니다. 돋보기 아이콘을 누르고 ‘Korean’을 입력해 한글 키보드를 찾아서 선택합니다. 키보드 종류를 선택한 후 <DONE>을 누르면 한글 키보드가 추가됩니다. 이제 키보드에서 지구 모양 아이콘을 누르면 한글/영문 키보드로 바뀝니다.
[그림 5-6] 한글 키보드 추가하기


(1) […], (2) 설정 아이콘 / Languages: English (US) (QWERTY) / ADD KEYBOARD / Korean / DONE / 지구 모양 아이콘
[그림 끝]
[아하! 끝]
140
[Do it! 실습] 가로 리스트뷰로 동물 이미지 추가하기
앞의 실습에서 경험해 본 것처럼 Row 위젯은 이미지가 화면을 벗어나면 다 표시하지 못하고 노란색 빗금으로 이를 알려줍니다. 이럴 때는 리스트뷰를 사용하면 편리합니다. 리스트뷰는 세로 스크롤이 기본이지만 scrollDirection을 이용하면 가로로도 변경할 수 있습니다.
secondPage.dart 파일을 열고 Row로 만들었던 이미지 선택 영역을 다음처럼 가로 리스트뷰로 변경합니다. 그리고 몇 가지 동물을 더 추가합니다.
[글상자] lib/sub/secondPage.dart
(...생략...)
children: <Widget>[
TextField( ...생략... ),
Row(children: <Widget>[ ...생략... ],),
Row(children: <Widget>[ ...생략... ],),
Container( // 기존 Row를 교체
height: 100,
child: ListView(
scrollDirection: Axis.horizontal,
children: <Widget>[
(...생략...)
GestureDetector(
child: Image.asset('repo/images/fox.png', width: 80),
onTap: () {
_imagePath = 'repo/images/fox.png';
},
),
GestureDetector(
child: Image.asset('repo/images/monkey.png', width: 80),
onTap: () {
_imagePath = 'repo/images/monkey.png';
},
),
], 〔mainAxisAlignment: MainAxisAlignment.spaceAround〕
),
),
RaisedButton( ...생략... )
],
(...생략...)
[글상자 끝]
141
소스를 저장한 후 앱을 보면 이제 가로로 스크롤되는 목록을 확인할 수 있습니다.
[그림] 실행 결과


Listview Example
? 양서류, ○ 파충류, ○ 포유류
날 수 있나요? ?
동물 추가하기
[그림 끝]
[Do it! 실습] 동물을 목록에 추가하기
이제 동물을 목록에 추가해 보겠습니다. 동물을 추가하기 전에 알림 창을 띄우고 확인을 누르면 그때 동물이 추가되도록 만들어 보겠습니다. secondPage.dart 파일의 <동물 추가하기> 버튼에 다음과 같은 코드를 추가합니다.
[글상자] lib/sub/secondPage.dart
(...생략...)
RaisedButton(
child: Text('동물 추가하기'),
onPressed: () {
var animal = Animal(
animalName: nameController.value.text,
kind: getKind(_radioValue),
imagePath: _imagePath,
flyExist: flyExist);
AlertDialog dialog = AlertDialog(
title: Text('동물 추가하기'),
142
content: Text(
'이 동물은 ${animal.animalName} 입니다. '
'또 동물의 종류는 ${animal.kind}입니다.\n이 동물을 추가하시겠습니까?',
style: TextStyle(fontSize: 30.0),
),
actions: [
RaisedButton(
onPressed: () {
widget.list.add(animal);
Navigator.of(context).pop();
},
child: Text('예'),
),
RaisedButton(
onPressed: () {
Navigator.of(context).pop();
},
child: Text('아니요'),
),
],
);
showDialog(
context: context,
builder: (BuildContext context) => dialog);
})
(...생략...)
_radioChange(int value) { ...생략... }
getKind(int radioValue) {
switch (radioValue) {
case 0:
return "양서류";
case 1:
return "파충류";
case 2:
return "포유류";
}
}
}
[글상자 끝]
143
AlertDialog에서 Title은 알림 창에 표시할 제목이고 content는 내용입니다. 그리고 actions는 배열 형태로 위젯을 가져올 수 있는데, 여기서는 버튼을 선언해 이벤트를 처리하도록 작성했습니다. <아니요>를 누르면 알림 창이 꺼지고 <예>를 누르면 animal을 리스트에 추가한 다음에 알림 창이 꺼지도록 했습니다. 마지막에 getKind() 함수도 추가했습니다. 이 함수는 라디오 버튼에서 선택된 값을 전달받아 동물의 종류를 문자열로 반환합니다.
이제 <동물 추가하기> 버튼을 누르면 다음과 같이 알림 창이 표시됩니다. <예> 버튼을 클릭하고 첫 번째 탭으로 이동하면 방금 추가한 동물이 목록에 보입니다.
[그림] 실행 결과


동물 추가하기
이 동물은 사막여우입니다. 또 동물의 종류는 포유류입니다. 이 동물을 추가하시겠습니까? [예][아니요]
[그림 끝]
지금까지 페이지 두 개를 이용해 리스트를 만들고 리스트에 아이템을 추가하는 앱을 만들어 봤습니다. 요즘 나오는 대부분 앱은 사용자들이 위아래로 편리하게 정보를 확인할 수 있도록 리스트 형태로 제작합니다. 따라서 이번 절에서 만들어 본 기본적인 리스트는 다양한 앱을 만드는 데 응용할 수 있습니다. 리스트는 자주 사용하고 사용법도 다양하므로 앞으로 학습을 진행하면서 차근차근 배워가겠습니다.
144
06 iOS 스타일로 플러터 앱 만들기
04장에서 안드로이드의 머티리얼 디자인을 다루면서 디자인 지침에 관해 언급한 적이 있습니다. 통일된 스타일 가이드를 제시함으로써 앱의 사용성을 높이려는 전략이라고요. 애플도 이러한 목적으로 디자인 지침을 만들었는데 애플 본사가 있는 미국 캘리포니아주의 도시 이름을 따서 ‘쿠퍼티노’라고 부릅니다.
이번 장에서는 플러터에서 제공하는 쿠퍼티노 위젯을 이용해서 앱을 만들어 봅니다. 쿠퍼티노 위젯을 사용하면 기존의 iOS 앱을 사용하던 사람들에게 익숙한 스타일로 앱을 디자인할 수 있습니다.
06-1 쿠퍼티노 위젯으로 동물 소개 앱 만들기
06-2 쿠퍼티노 위젯으로 동물 추가 화면 만들기
06-3 그 밖의 쿠퍼티노 위젯
145
06-1 쿠퍼티노 위젯으로 동물 소개 앱 만들기
이번 절에서는 앞서 05장에서 만들었던 동물 소개 앱을 쿠퍼티노 위젯을 이용해 iOS 스타일로 바꿔보겠습니다. 플러터는 iOS 스타일의 위젯을 cupertino라는 패키지로 제공합니다. 플러터 프로젝트의 pubspec.yaml 파일을 보면 cupertino_icons라는 설정값이 보이는데 이 패키지는 플러터가 기본으로 제공하는 iOS 아이콘 묶음입니다.
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
# The following adds the Cupertino Icons font to your application.
# Use with the CupertinoIcons class for iOS style icons.
cupertino_icons: ^0.1.3 // 쿠퍼티노 아이콘 라이브러리
(...생략...)
[글상자 끝]
[아하!] dependencies 설정은 어떤 역할을 하나요?
pubspec.yaml 파일에서 dependencies 설정은 누군가 이미 구현해 놓은 패키지를 가져와서 사용할 수 있도록 하는 방법입니다. 노드제이에스의 npm과 비슷하다고 할 수 있습니다. 플러터에 사용할 수 있는 패키지는 pub.dev 사이트에서 찾을 수 있으며, pubspec.yaml 파일에서 dependencies 설정에 라이브러리 이름을 등록하면 자동으로 해당 라이브러리를 가져와서 사용할 수 있습니다. 이와 관련한 실습은 07장에서 진행합니다.
[아하! 끝]
146
[Do it! 실습] 쿠퍼티노 사용 준비하기
[1단계] 앞서 05장에서 만들었던 listview_example 프로젝트에서 lib 폴더 아래 cupertinoMain.dart라는 이름으로 새로운 다트 파일을 만듭니다. 그리고 다음과 같은 코드를 작성합니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[글상자] lib/cupertinoMain.dart
import 'package:flutter/cupertino.dart';
class CupertinoMain extends StatefulWidget {
@override
State<StatefulWidget> createState() {
return _CupertinoMain();
}
}
[글상자 끝]
첫 줄에는 cupertino 패키지를 불러오는 코드를 작성했습니다. iOS 스타일의 화면을 구현하려면 이처럼 cupertino 패키지를 사용해야 합니다. 그리고 StatefulWidget 클래스를 상속받는 CupertinoMain 클래스를 작성했습니다.
[2단계] 다음은 화면을 구성하는 기본 골격을 만듭니다. 같은 파일에 다음과 같은 내용으로 _CupertinoMain 클래스를 생성합니다. 그러면 쿠퍼티노를 사용할 기본 준비가 끝납니다.
[글상자] lib/cupertinoMain.dart
(...생략...)
class _CupertinoMain extends State<CupertinoMain> {
@override
Widget build(BuildContext context) {
return CupertinoApp(
home: CupertinoTabScaffold(tabBar: null, tabBuilder: null),
);
}
}
[글상자 끝]
147
04장에서 살펴본 머티리얼 디자인에서는 build() 함수가 MaterialApp을 반환하지만, iOS 스타일에서는 CupertinoApp을 반환합니다. 쿠퍼티노 디자인의 위젯 묶음을 사용하기 위한 것으로 이해하면 됩니다. 그리고 CupertinoApp의 home에서 CupertinoTabScaffold를 선언했습니다. tabBar와 tabBuilder에는 임시로 null을 넣었습니다. 다음 실습에서 탭바를 만든 후 여기에 넣을 것입니다.
한 가지 기억할 것은 쿠퍼티노 위젯의 이름에는 항상 ‘Cupertino’라는 접두어가 붙는다는 사실입니다.
[Do it! 실습] 쿠퍼티노 탭바 만들기
[1단계] 쿠퍼티노 디자인의 탭바를 하나 만들어 봅시다. _CupertinoMain 클래스에 CupertinoTabBar를 만든 후 initState() 함수에서 정의해줍니다. 그리고 탭바에서 각 탭에 표시할 아이콘을 추가합니다. 아이콘을 추가할 때 지금까지 머티리얼 디자인에서는 Icons.add처럼 작성했는데, 쿠퍼티노 디자인에서는 CupertinoIcons.add를 이용합니다.
[글상자] lib/cupertinoMain.dart
(...생략...)
class _CupertinoMain extends State<CupertinoMain> {
CupertinoTabBar tabBar;
@override
void initState() {
super.initState();
tabBar = CupertinoTabBar(items: <BottomNavigationBarItem>[
BottomNavigationBarItem(icon: Icon(CupertinoIcons.home)),
BottomNavigationBarItem(icon: Icon(CupertinoIcons.add)),
]);
}
@override
Widget build(BuildContext context) { ...생략... }
}
[글상자 끝]
148
[2단계] 방금 정의한 탭바를 앞의 실습에서 build() 함수에 만들어 놓은 tabBar에 넣습니다. 그리고 tabBuilder에서 각 탭을 어떻게 표시할지 작성합니다. 탭은 두 개이므로 각 탭을 누르면 tabBuilder에서 value가 0이나 1을 반환합니다. 이 값을 이용해 각 탭의 로직을 처리할 수 있습니다.
[글상자] lib/cupertinoMain.dart
(...생략...)
return CupertinoApp(
home: CupertinoTabScaffold(
tabBar: tabBar,
tabBuilder: (context, value) {
if (value == 0) {
return Container(
child: Center(
child: Text('cupertino tab 1 '),
),
);
} else {
return Container(
child: Center(
child: Text('cupertino tab 2'),
),
);
}
}),
);
(...생략...)
[글상자 끝]
[3단계] 이제 main.dart 파일을 열고 방금 작성한 cupertinoMain.dart 파일을 불러온 다음, main() 함수에서 runApp() 괄호 안을 CupertinoMain()으로 변경합니다. 그리고 실행해 보면 탭바에 쿠퍼티노 디자인의 아이콘이 보입니다.
[글상자] lib/main.dart
(...생략...)
import './cupertinoMain.dart';
void main() => runApp(CupertinoMain());
(...생략...)
[글상자 끝]
149
[그림] 실행 결과


cupertino tab 1, cupertino tab 2
[그림 끝]
[Do it! 실습] 쿠퍼티노 리스트뷰 만들기
[1단계] 05장에서 만든 리스트뷰를 iOS 스타일로 만들어 앞의 실습에서 만든 탭에 넣어 보겠습니다. 먼저 cupertinoMain.dart 파일을 열고 05장에서 만들었던 동물 목록을 추가합니다. 그리고 List를 이용해 animalList를 선언한 후 initState() 함수에서 animalList에 동물 정보를 추가합니다.
[글상자] lib/cupertinoMain.dart
import 'package:flutter/cupertino.dart';
import 'animalItem.dart';
class CupertinoMain extends StatefulWidget { ...생략... }
class _CupertinoMain extends State<CupertinoMain> {
CupertinoTabBar tabBar;
List<Animal> animalList = List();
@override
150
void initState() {
super.initState();
tabBar = CupertinoTabBar(items: <BottomNavigationBarItem>[
BottomNavigationBarItem(icon: Icon(CupertinoIcons.home)),
BottomNavigationBarItem(icon: Icon(CupertinoIcons.add)),
]);
animalList.add(Animal(animalName: "벌", kind: "곤충", imagePath: "repo/images/bee.png"));
animalList.add(Animal(animalName: "고양이", kind: "포유류", imagePath: "repo/images/cat.png"));
animalList.add(Animal(animalName: "젖소", kind: "포유류", imagePath: "repo/images/cow.png"));
animalList.add(Animal(animalName: "강아지", kind: "포유류", imagePath: "repo/images/dog.png"));
animalList.add(Animal(animalName: "여우", kind: "포유류", imagePath: "repo/images/fox.png"));
animalList.add(Animal(animalName: "원숭이", kind: "영장류", imagePath: "repo/images/monkey.png"));
animalList.add(Animal(animalName: "돼지", kind: "포유류", imagePath: "repo/images/pig.png"));
animalList.add(Animal(animalName: "늑대", kind: "포유류", imagePath: "repo/images/wolf.png"));
}
(...생략...)
[글상자 끝]
[2단계] lib 폴더에 iosSub 폴더를 새로 만들고 cupertinoFirstPage.dart 파일을 만듭니다. 이 파일을 열고 StatelessWidget을 상속받는 CupertinoFirstPage 클래스를 생성합니다. 전체 코드는 다음과 같습니다.
[글상자] lib/iosSub/cupertinoFirstPage.dart
import 'package:flutter/material.dart';
import 'package:flutter/cupertino.dart';
import '../animalItem.dart';
class CupertinoFirstPage extends StatelessWidget {
final List<Animal> animalList;
151
const CupertinoFirstPage({Key key, @required this.animalList}) : super(key: key);
@override
Widget build(BuildContext context) {
return CupertinoPageScaffold(
navigationBar: CupertinoNavigationBar(
middle: Text('동물 리스트'),
),
child: ListView.builder(
itemBuilder: (context, index) {
return Container(
padding: EdgeInsets.all(5),
height: 100,
child: Column(
children: <Widget>[
Row(
children: <Widget>[
Image.asset(
animalList[index].imagePath,
fit: BoxFit.contain,
width: 80,
height: 80,
),
Text(animalList[index].animalName)
],
),
Container(
height: 2,
color: CupertinoColors.black,
)
],
),
);
},
itemCount: animalList.length,
));
}
}
[글상자 끝]
152
cupertinoMain에서 만든 동물 리스트를 상속받아서 리스트뷰로 화면에 출력합니다. 리스트뷰를 사용하는 방식은 기존의 머티리얼 방식과 다르지 않습니다. 다만, 쿠퍼티노에서는 05장에서 사용했던 카드 위젯이 없습니다. 따라서 Container를 이용해 만들고 각 Container에 높이를 정해서 위젯을 배치했습니다. 또한 앱바 위젯도 없습니다. 대신에 내비게이션바가 있으므로 CupertinoNavigationBar를 이용해 이를 꾸밀 수 있습니다. 여기서는 middle값에 ‘동물 리스트’라는 텍스트를 넣었습니다.
[3단계] cupertinoMain.dart 파일에서 build() 함수가 방금 작성한 CupertinoFirstPage를 반환하도록 수정합니다.
[글상자] lib/cupertinoMain.dart
import 'package:flutter/cupertino.dart';
import 'animalItem.dart';
import 'iosSub/cupertinoFirstPage.dart';
(...생략...)
@override
Widget build(BuildContext context) {
return CupertinoApp(
home: CupertinoTabScaffold(
tabBar: tabBar,
tabBuilder: (context, value) {
if (value == 0) {
return CupertinoFirstPage(
animalList: animalList,
);
} else {
// 여기에 두 번째 페이지 반환 예정
}
}),
(...생략...)
[글상자 끝]
153
두 번째 페이지는 아직 만들지 않았으므로 else 문 안은 비워두고 일단 실행해 봅니다. 이로써 iOS 스타일의 동물 목록이 완성되었습니다.
[그림] 실행 결과


동물 리스트: 벌, 고양이, 젖소, 강아지, 여우, 원숭이
[그림 끝]
154
06-2 쿠퍼티노 위젯으로 동물 추가 화면 만들기
앞 절에서 쿠퍼티노 디자인으로 동물 목록을 만들었습니다. 이번 절에서는 동물 소개 앱의 두 번째 페이지인 동물 추가 화면을 쿠퍼티노 디자인으로 만들어 보겠습니다. 여기서는 쿠퍼티노 위젯 중 세그먼트를 사용해 보겠습니다. 세그먼트 위젯은 머티리얼의 라디오 버튼처럼 여럿 중 하나를 선택할 수 있는 iOS 스타일 위젯입니다.
[그림 6-1] iOS의 세그먼트 위젯


Midnight / Viridian / Cerulean
[그림 끝]
[Do it! 실습] 세그먼트 위젯 사용하기
[1단계] 먼저 iosSub 폴더에 cupertinoSecondPage.dart 파일을 만듭니다. 이 파일에 Stateful Widget을 상속받는 CupertinoSecondPage 클래스를 생성합니다. 그리고 CupertinoPage Scaffold를 반환하는 _CupertinoSecondPage 클래스를 만들어 화면의 골격을 준비합니다.
[글상자] lib/iosSub/cupertinoSecondPage.dart
import 'package:flutter/cupertino.dart';
import '../animalItem.dart';
class CupertinoSecondPage extends StatefulWidget {
final List<Animal> animalList;
const CupertinoSecondPage({Key key, this.animalList}) : super(key: key);
@override
State<StatefulWidget> createState() {
return _CupertinoSecondPage();
}
}
class _CupertinoSecondPage extends State<CupertinoSecondPage> {
@override
Widget build(BuildContext context) {
155
return CupertinoPageScaffold(
navigationBar: CupertinoNavigationBar(
middle: Text('동물 추가'),
),
child: null,
);
}
}
[글상자 끝]
아직 child는 비워뒀습니다. 여기에 이름을 입력하는 텍스트필드, 종류를 선택하는 세그먼트, 날개 유무를 확인하는 스위치, 그리고 동물 이미지 목록과 추가하기 버튼을 만듭니다.
[2단계] 먼저 텍스트필드를 사용하기 위한 TextEditingController를 선언합니다. 또 입력한 값을 저장할 변수도 선언합니다.
[글상자] lib/iosSub/cupertinoSecondPage.dart
(...생략...)
class _CupertinoSecondPage extends State<CupertinoSecondPage> {
TextEditingController _textController; // 동물 이름
int _kindChoice = 0; // 동물 종류
bool _flyExist = false; // 날개 유무
String _imagePath; // 동물 이미지
@override
void initState() {
super.initState();
_textController = TextEditingController();
}
@override
Widget build(BuildContext context) { ...생략... }
}
[글상자 끝]
156
[3단계] 쿠퍼티노가 제공하는 세그먼트 위젯을 이용해 동물의 종류를 선택하는 항목을 만들어 보겠습니다. 먼저 세그먼트로 구성할 내용이 필요합니다. _CupertinoSecondPage 클래스에 선언한 변수 목록 아래 Map을 추가합니다.
[글상자] lib/iosSub/cupertinoSecondPage.dart
(...생략...)
class _CupertinoSecondPage extends State<CupertinoSecondPage> {
TextEditingController _textController;
int _kindChoice = 0;
bool _flyExist = false;
String _imagePath;
Map<int, Widget> segmentWidgets = {
0: SizedBox(
child: Text('양서류', textAlign: TextAlign.center),
width: 80,
),
1: SizedBox(
child: Text('포유류', textAlign: TextAlign.center),
width: 80,
),
2: SizedBox(
child: Text(
'파충류',
textAlign: TextAlign.center,
),
width: 80,
)
};
(...생략...)
[글상자 끝]
Map은 정수형 키와 위젯형 값을 쌍으로 해서 <int, Widget> 형태로 구성되며 Widget에 원하는 형태의 위젯을 넣으면 됩니다. 예에 사용한 SizedBox는 영역을 만들어 주는 위젯입니다. 이 위젯에 지정한 값만큼 세그먼트의 너비와 높이가 정해집니다. 참고로 텍스트만 넣으면 세그먼트가 너무 좁아서 width로 너비를 직접 입력했습니다.
157
[Do it! 실습] 동물 추가하기 화면 완성하기
[1단계] 이제 build() 함수를 구현해 동물 추가하기 페이지를 완성해 보겠습니다. build() 함수는 소스가 길어서 몇 단계로 나누어 설명하겠습니다. 대부분은 05장에서 만들었던 내용과 크게 다르지 않으므로 변경된 부분 위주로 설명하겠습니다[각주*].
[각주*] 이번 실습에서 5단계까지 build() 함수를 작성하므로 괄호 등에 주의하기 바랍니다. 코드를 어느 위치에 추가해야 하는지 헷갈릴 때는 필자가 제공한 완성된 소스 파일을 확인하기 바랍니다.[각주 끝]
[글상자] lib/iosSub/cupertinoSecondPage.dart
(...생략...)
@override
Widget build(BuildContext context) {
return CupertinoPageScaffold(
navigationBar: CupertinoNavigationBar(
middle: Text('동물 추가'),
),
child: Container(
child: Center(
child: Column(
children: <Widget>[
Padding(
padding: EdgeInsets.all(10),
child: CupertinoTextField(
controller: _textController,
keyboardType: TextInputType.text,
maxLines: 1,
),
),
(...생략...)
[글상자 끝]
CupertinoTextField는 iOS 스타일의 입력 창입니다. 양 옆에 적당한 공간을 주기 위해 Padding 위젯으로 감싼 뒤 머티리얼에 있는 텍스트필드처럼 _textController를 지정했습니다. 이 _textController는 앞서 initState() 함수에 선언했습니다. maxLines는 최대로 입력할 수 있는 줄 수입니다. 동물 이름만 입력할 것이므로 1줄로 입력받습니다.
158
[2단계] 이어서 다음 코드로 세그먼트 컨트롤을 설정합니다.
[글상자] lib/iosSub/cupertinoSecondPage.dart
(...생략...)
CupertinoSegmentedControl(
padding: EdgeInsets.only(bottom: 20, top: 20),
groupValue: _kindChoice,
children: segmentWidgets,
onValueChanged: (value) {
setState(() {
_kindChoice = value;
});
}),
(...생략...)
[글상자 끝]
_CupertinoSecondPage 클래스에서 선언했던 segmentWidgets를 children에 넣고 groupValue에는 0으로 초기화한 _kindChoice값을 넣습니다. 이후에는 segmentWidgets에서 정해진 키값이 groupValue값이 됩니다. onValueChanged에는 값이 바뀌었을 때 동작할 이벤트를 정의합니다.
[3단계] 이어서 CupertinoSwitch를 이용해 동물의 날개 유무를 묻는 iOS 스타일의 스위치를 만듭니다.
[글상자] lib/iosSub/cupertinoSecondPage.dart
(...생략...)
Row(
children: <Widget>[
Text('날개가 존재합니까?'),
CupertinoSwitch(
value: _flyExist,
onChanged: (value) {
setState(() {
_flyExist = value;
});
})
159
],
mainAxisAlignment: MainAxisAlignment.center,
),
(...생략...)
[글상자 끝]
[4단계] 다음은 가로로 보여주는 리스트뷰에서 동물의 이미지를 고를 수 있게 합니다.
[글상자] lib/iosSub/cupertinoSecondPage.dart
(...생략...)
SizedBox(
height: 100,
child: ListView(
scrollDirection: Axis.horizontal,
children: <Widget>[
GestureDetector(
child: Image.asset('repo/images/cow.png', width: 80),
onTap: () {
_imagePath = 'repo/images/cow.png';
},
),
GestureDetector(
child: Image.asset('repo/images/pig.png', width: 80),
onTap: () {
_imagePath = 'repo/images/pig.png';
},
),
GestureDetector(
child: Image.asset('repo/images/bee.png', width: 80),
onTap: () {
_imagePath = 'repo/images/bee.png';
},
),
GestureDetector(
child: Image.asset('repo/images/cat.png', width: 80),
onTap: () {
_imagePath = 'repo/images/cat.png';
},
160
),
GestureDetector(
child: Image.asset('repo/images/fox.png', width: 80),
onTap: () {
_imagePath = 'repo/images/fox.png';
},
),
GestureDetector(
child: Image.asset('repo/images/monkey.png', width: 80),
onTap: () {
_imagePath = 'repo/images/monkey.png';
},
),
],
),
),
(...생략...)
[글상자 끝]
리스트뷰를 가로로 스크롤 하려면 scrollDirection을 Axis.horizontal로 설정해야 합니다. 이때 height로 높이를 지정하는 것이 중요합니다. 높이를 지정하지 않으면 얼마만큼 높이로 리스트를 만들지 알 수 없어서 오류가 발생합니다.
GestureDetector 위젯을 이용해 이미지를 넣고 가로로 스크롤되는 리스트뷰로 출력합니다. 그리고 onTap() 이벤트를 통해 선택된 동물 이미지를 저장합니다.
[5단계] CupertinoButton을 이용해 iOS 스타일 버튼을 추가합니다. 이 버튼을 누르면 리스트에 동물을 추가합니다.
[글상자] lib/iosSub/cupertinoSecondPage.dart
(...생략...)
CupertinoButton(
child: Text('동물 추가하기'),
onPressed: () {
widget.animalList.add(Animal(
animalName: _textController.value.text,
kind: getKind(_kindChoice),
161
imagePath: _imagePath,
flyExist: _flyExist));
})
],
mainAxisAlignment: MainAxisAlignment.center,
),
),
),
);
}
getKind(int radioValue) {
switch (radioValue) {
case 0:
return "양서류";
case 1:
return "파충류";
case 2:
return "포유류";
}
}
}
[글상자 끝]
[6단계] 마지막으로 cupertinoMain.dart 파일을 열고 build() 함수가 두 번째 탭을 눌렀을 때 CupertinoScondPage를 반환하도록 else 문을 채웁니다. 그리고 앱을 실행해 보면 마침내 iOS 스타일의 동물 추가 화면을 볼 수 있습니다.
[글상자] lib/cupertinoMain.dart
(...생략...)
import 'iosSub/cupertinoSecondPage.dart';
(...생략...)
@override
Widget build(BuildContext context) {
(...생략...)
tabBuilder: (context, value) {
if (value == 0) {
162
return CupertinoFirstPage(
animalList: animalList,
);
} else {
return CupertinoSecondPage(
animalList: animalList,
);
}
}),
(...생략...)
[글상자 끝]
[그림] 실행 결과


동물 추가
양서류/포유류/파충류
날개가 존재합니까?
dialog
동물 추가하기
[그림 끝]
163
06-3 그 밖의 쿠퍼티노 위젯
플러터는 앞에서 소개한 것 이외에도 다양한 쿠퍼티노 위젯을 제공합니다. 자주 사용하는 몇 가지 위젯을 간략하게 소개하는 것으로 이번 장을 마무리해 보겠습니다. 더 많은 위젯과 자세한 사용법은 다음 주소에서 확인할 수 있습니다.
? 쿠퍼티노 위젯 소개: https://flutter.dev/docs/development/ui/widgets/cupertino
버튼: CupertinoButton
일반 FlatButton이나 RaisedButton과 같은 기능의 iOS 스타일 버튼입니다.
[글상자] 버튼 예
CupertinoButton(
child: Text('button'),
color: Colors.blue,
onPressed: () {
}
[글상자 끝]
[그림 6-2] CupertinoButton 위젯


Button
[그림 끝]
로딩 표시기: CupertinoActivityIndicator
CupertinoActivityIndicator 위젯은 iOS 스타일의 로딩 표시기입니다. radius 속성을 이용해 크기를 조절할 수 있습니다.
[글상자] 로딩 표시기 예
child: Center(
child: CupertinoActivityIndicator(
radius: 20, // radius는 크기입니다.
)),
[글상자 끝]
[그림 6-3] CupertinoActivityIndicator 위젯


[그림 끝]
164
알림 창: CupertinoAlertDialog
CupertinoAlertDialog는 iOS 스타일의 알림 창입니다. 다음 그림을 보면 안드로이드와 디자인이 많이 다른 걸 알 수 있습니다. 다음은 예시 코드입니다.
[글상자] 알림 창 예
CupertinoButton(
child: Text('dialog'),
onPressed: () {
showCupertinoDialog(
context: context,
builder: (context) {
return CupertinoAlertDialog(
title: Text('Cupertino'),
content: Text('Cupertino 스타일의 위젯입니다'),
actions: [
CupertinoButton(
child: Text('확인'),
onPressed: () {
Navigator.of(context).pop();
})
],
);
});
},
)
[글상자 끝]
[그림 6-4] CupertinoAlertDialog 위젯


Cupertino, Cupertino 스타일의 위젯입니다
[그림 끝]
액션시트: CupertinoActionSheet
안드로이드는 알림 창으로 다양한 동작을 구현할 수 있다면, iOS는 알림 창 이외에 하단에 표시되는 액션시트를 이용해 선택 사항을 나열할 수 있습니다. 이때는 showCupertinoModalPopup() 함수를 통해 CupertinoActionSheet를 호출합니다.
165
[글상자] 액션시트 예
showCupertinoModalPopup(context: context, builder: (context){
return CupertinoActionSheet(
title: Text('Action'),
message: Text('좋아하는 색은'),
actions: [
CupertinoButton(child: Text('빨강'), onPressed: () {}),
CupertinoButton(child: Text('파랑'), onPressed: () {}),
],
cancelButton: CupertinoButton(child: Text('취소'), onPressed: () {
Navigator.of(context).pop();
})
);
});
[글상자 끝]
[그림 6-5] CupertinoActionSheet 위젯


Action, 좋아하는 색은, 빨강, 파랑, 취소
[그림 끝]
피커: CupertinoPicker
iOS에서는 화면 하단에 표시되는 창이 많은 편입니다. 그중에서 피커는 스크롤을 이용해 이벤트를 처리하는데, 액션시트처럼 showCupertinoModalPopup() 함수로 호출합니다. 보통 피커를 사용할 때는 컨테이너로 높이를 정하고 이 높이를 가득 채우는 Expanded() 함수를 호출해 스크롤하는 CupertinoPicker의 길이를 최대한 길게 설정합니다. 특히 scorllController를 이용해 Controller를 선언하고 초기화합니다.
[글상자] 피커 예
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
class CupertinoDesignPage extends StatefulWidget {
@override
State<StatefulWidget> createState() => _CupertinoDesignPage();
}
166
class _CupertinoDesignPage extends State<CupertinoDesignPage> {
FixedExtentScrollController firstController;
@override
void initState() {
super.initState();
firstController = FixedExtentScrollController(initialItem: 0);
}
@override
Widget build(BuildContext context) {
return Scaffold(
body: Container(
child: Center(
child: Column(children: [
CupertinoButton(
child: Text('PICKER'),
onPressed: () {
showCupertinoModalPopup(
context: context,
builder: (context) {
return Container(
height: 400,
child: Column(
children: [
Expanded(
child: CupertinoPicker(
itemExtent: 50,
backgroundColor: Colors.white,
scrollController: firstController,
onSelectedItemChanged: (index) {},
children: List<Widget>.generate(10, (index) {
return Center(
child: FlatButton(
onPressed: () {
Navigator.of(context).pop();
},
child: Text(
167
(++index).toString(),
)),
);
}),
),
),
FlatButton(
onPressed: () {
Navigator.of(context).pop();
},
child: Text('취소'))
],
),
);
},
);
}),
], mainAxisAlignment: MainAxisAlignment.spaceAround),
),
),
);
}
}
[글상자 끝]
[그림 6-6] CupertinoPicker 위젯


[그림 끝]
내비게이션바: CupertinoNavigationBar
내비게이션바를 표시하는 CupertinoNavigationBar는 스캐폴드에서 appBar 위치에 사용하는 위젯입니다.
168
[글상자] 내비게이션바 예
appBar: CupertinoNavigationBar(
leading: CupertinoButton(child: Icon(Icons.arrow_back_ios), onPressed: () {
}),
middle: Text('Cupertino Design'),
trailing: CupertinoButton(child: Icon(Icons.exit_to_app), onPressed: () {
}),
),
[글상자 끝]
[그림 6-7] CupertinoNavigationBar 위젯


Cupertino Design
[그림 끝]
슬라이더: CupertinoSlider
iOS 스타일의 슬라이더입니다. 기존의 머티리얼의 슬라이더와 사용법은 같습니다. 슬라이더를 이용하면 좀 더 쉽고 직관적으로 값을 전달받을 수 있습니다.
[글상자] 슬라이더 예
CupertinoSlider(
value: _value,
onChanged: (index) {
setState(() {
_value = index;
});
},
max: 100,
min: 1,
),
Text(_value.toString())
[글상자 끝]
[그림 6-8] CupertinoSlider 위젯


70.00033291903372
[그림 끝]
05~06장을 통해 플러터에서 위젯을 사용하는 방법을 배웠습니다. 이 책에서 플러터가 제공하는 모든 위젯을 사용해 볼 수는 없겠지만, 플러터의 핵심 기능을 공부하면서 자주 사용하는 위젯 위주로는 계속 살펴보겠습니다.
169
07 네트워크를 이용해 통신하기
지금까지 플러터에서 위젯을 이용해 앱을 만드는 방법을 배웠습니다. 이런 위젯만으로도 다양한 앱을 만들 수 있지만, 스마트폰이 통신 기기임을 생각하면 아무래도 데이터를 주고받는 네트워크 통신 기능을 빼놓을 수 없습니다.
이번 장에서는 외부에 공개된 패키지와 API를 이용해 데이터 통신을 구현한 앱을 만들어보면서 네트워크 프로그래밍의 기본을 살펴보겠습니다.
07-1 카카오 API를 이용해 책 정보 받아오기
07-2 이미지 파일 내려받기
170
07-1 카카오 API를 이용해 책 정보 받아오기
앱이 서버와 서로 통신하면서 데이터를 주고받으려면 네트워크로 연결해야 합니다. 이때 네트워크와 연결하는 통신 규약을 HTTP(hypertext transfer protocol)라고 합니다. 이번 절에서는 HTTP를 이용해 카카오 API 중 책 정보를 JSON으로 받아서 화면에 표시하는 앱을 만들어 보겠습니다.
외부 패키지를 이용하는 방법
앱을 만들 때 모든 기능을 직접 구현하려면 많은 시간과 노력이 필요합니다. 그래서 대부분 개발자는 이미 만들어진 패키지를 활용합니다. 플러터 역시 선구자들이 만들어 놓은 다양한 패키지가 있는데, pub.dev 사이트에 접속해보면 찾아볼 수 있습니다. 이곳에서 원하는 기능이 구현된 패키지를 찾아서 pubspec.yaml 파일에 그 이름을 등록하면 프로젝트에서 해당 기능을 사용할 수 있습니다.
그러면 pub.dev에서 필요한 패키지를 찾아볼까요? 여기서는 HTTP 데이터 통신 기능이 필요합니다. 그럼 pub.dev 사이트에 접속한 후 패키지 검색란에 ‘http’라고 입력해 보세요.
[그림 7-1] http로 검색


http - http로 검색
http / A composable, multi-platform, Future-based API for HTTP requests. 1473 LIKES|110 PUB POINTS|100% POPULARITY - 패키지 이름과 인기도 확인 후 클릭
[그림 끝]
맨 위에 http라는 패키지 이름이 보이나요? 그리고 오른쪽 끝에는 해당 패키지의 인기도를 알
171
수 있는 숫자들이 있습니다. 이 숫자들이 높을수록 사용자가 많고 관리가 잘되는 패키지라고 생각하면 됩니다. http 패키지를 클릭해 해당 패키지 정보로 이동합니다.
[그림 7-2] http 패키지 정보


[그림 끝]
http라는 이름 옆에 버전이 보입니다. 이 책의 출간 시점에 최신 버전은 0.12.2[각주*]입니다. 그리고 라이선스(License) 항목에 BSD라고 표기되어 있습니다. BSD(Berkeley software distribution license)란 자유롭게 만들고 배포할 수 있는 라이선스라는 의미입니다. 그리고 패키지 사용법은 Using 영역에 나와 있습니다.
[각주*] 버전이 약간 달라도 사용에는 큰 무리가 없어요.[각주 끝]
http 패키지를 살펴보니 인기도 높고 라이선스도 자유롭네요. 이 패키지를 사용해 네트워크 통신 앱을 구현해 보기로 하겠습니다.
[아하!] 라이선스가 뭔가요?
방금 살펴본 패키지처럼 웹에 공개된 소스를 사용할 때는 라이선스에 주의해야 합니다. 라이선스는 종류마다 허용 범위와 규칙이 있기 때문입니다. 어떤 패키지는 상업용으로는 사용하지 못하거나 공개된 소스를 이용해 완성한 소스를 모두 공개해야 하는 라이선스도 있습니다. 라이선스 종류와 허용 범위 등은 ‘오픈소스SW 라이선스 종합정보시스템’에서 확인할 수 있습니다.
? 오픈소스SW 라이선스 종합정보시스템: https://olis.or.kr/license/licenseOSI.do?page=1
[아하! 끝]
172
카카오 API를 이용하는 방법
데이터 통신을 구현하려면 서버와 데이터가 필요합니다. 서버를 직접 구축하고 통신으로 주고받을 데이터도 직접 생성할 수 있겠지만, 공개된 데이터를 활용하면 시간을 좀 더 아낄 수 있습니다. 그리고 앱의 목적에 따라 때로는 대중교통 정보, 날씨, 주식 등 시시각각 바뀌는 공공 데이터가 필요할 수도 있습니다. 따라서 여기서는 공개된 데이터를 이용하는 방법을 살펴보겠습니다.
카카오 API란 무엇일까?
여기서 이용하려는 데이터는 책 정보로, 카카오가 제공하는 검색 API를 이용해 얻습니다. 카카오톡과 포털 사이트 ‘다음(Daum)’으로 유명한 카카오는 국내에서 네이버와 함께 손꼽히는 IT 기업으로서 다양한 분야의 많은 데이터를 가지고 있습니다. 이들은 자사의 데이터를 개발자들이 사용할 수 있도록 여러 가지 API(application programming interface)를 제공합니다. 이처럼 공개된 API를 이용하면 개발 효율을 높일 뿐만 아니라 다양한 데이터를 쉽게 활용할 수 있습니다.
[그림 7-3] 카카오가 제공하는 다양한 API(출처: developers.kakao.com/)


[그림 끝]
카카오 API를 이용하려면 API 키를 얻어야 합니다. API 키(API key)란 애플리케이션이 서버의 문을 여는 열쇠라고 생각하면 쉽습니다. 즉, 애플리케이션이 API 키를 이용해 데이터를 요청하면 서버가 API 키를 분석해 데이터를 전송해도 되는 애플리케이션인지 확인합니다.
카카오 개발자 사이트에 애플리케이션 추가하기
카카오에서 API 키를 얻으려면 카카오 개발자 사이트에 로그인한 후 애플리케이션을 추가해
173
야 합니다. 카카오 로그인 기능이나 카카오맵처럼 운영체제별로 네이티브 플랫폼[각주*]을 등록해야 하는 API도 있지만, 여기서는 검색 API만 이용할 것이므로 따로 플랫폼을 추가하지 않아도 됩니다.
[각주*] 앱을 식별하는 아이디나 패키지명, 마켓 URL 등 각 플랫폼 정보를 의미합니다.[각주 끝]
먼저 카카오 개발자 사이트에 접속한 후 카카오 계정으로 로그인합니다. 만약 카카오 계정이 없으면 회원으로 가입해 계정을 만듭니다.
? 카카오 개발자 사이트: https://developers.kakao.com/
로그인 후 메뉴에서 [내 애플리케이션]을 클릭하고 <애플리케이션 추가하기>를 클릭합니다. 그림과 같은 대화상자가 나타나면 앱 이름에 “httpTest”를 입력하고 사업자명에 각자 이름을 입력합니다. <저장>을 누르면 애플리케이션이 추가됩니다.
[그림 7-4] 애플리케이션 추가하기


(1) 내 애플리케이션
(2) 애플리케이션 추가하기
(3) httpTest
(4) 이지스퍼블리싱
(5) 저장
[그림 끝]
카카오 API 키 얻기
내 애플리케이션에서 httpTest 애플리케이션이 추가된 것이 보이면 클릭해서 정보를 확인합니다.
[그림 7-5] 추가된 애플리케이션


httpTest
[그림 끝]
174
애플리케이션 정보 중 지금 필요한 것은 REST API 키[각주*]입니다. 이 키가 바로 우리가 만들 앱에서 카카오 API를 이용할 수 있게 해주는 열쇠입니다. 이 REST API 키는 잠시 후 살펴볼 「책 정보 가져오기」 실습에 필요합니다.
[각주*] 키는 무작위로 추출된 문자열입니다. 이 키를 노출하면 누군가가 사용할 수 있으므로 노출되지 않도록 주의합니다.[각주 끝]
[그림 7-6] API 키 확인


REST API 키 | 5425cf8f9c602…
[그림 끝]
앞서 말한 대로 여기서는 카카오 검색 API를 이용해 책 정보를 가져오는 앱을 만들어 볼 것입니다. 카카오 검색 API에서 책 검색을 이용하는 방법은 카카오에서 제공하는 개발 가이드에 자세하게 나와 있습니다. 이를 참고하기 바랍니다.
? 카카오 책 검색 개발 가이드: https://developers.kakao.com/docs/latest/ko/daum-search/dev-guide#search-book
[그림 7-7] 카카오 책 검색 개발 가이드


[그림 끝]
175
[Do it! 실습] HTTP 통신 연습하기
네트워크 통신을 하려면 HTTP를 이용해 서버에 접속하고 데이터를 가져오는 코드를 작성해야 합니다. 본격적으로 앱을 개발하기 전에 이 부분을 연습해 보겠습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] 안드로이드 스튜디오에서 http_example이라는 이름으로 새로운 프로젝트를 만듭니다. 그리고 pubspec.yaml 파일을 열고 dependencies 설정에 앞에서 소개한 http 패키지를 추가합니다.
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
cupertino_icons: ^0.1.3
http: ^0.12.2
(...생략...)
[글상자 끝]
패키지를 등록할 때는 패키지 이름 다음에 콜론(:)을 입력하고 캐럿(^) 다음에 버전[각주*]을 입력합니다. pubspec.yaml 파일을 수정하면 다음처럼 플러터 명령 줄이 나타나는데, 앞에서와 마찬가지로 <Pub get>을 클릭해 패키지를 가져옵니다.
[각주*] pub.dev 사이트에서 확인한 패키지 버전을 정확히 입력하세요. 버전을 잘못 입력하면 오류가 발생해요.[각주 끝]
[그림 7-8] pubspec.yaml 파일에서 패키지 가져오기


Pub get
[그림 끝]
<Pub get>을 클릭하면 메시지 창에 패키지가 설치되는 과정을 보여줍니다.
[그림 7-9] 패키지 설치 과정


Running "flutter pub get" in http_example...
Process finish with exit code 0
[그림 끝]
176
[2단계] 이제 main.dart 파일을 열고 새로운 스테이트풀 위젯을 만들어서 화면을 구성해 보겠습니다. 스캐폴드를 이용해 앱바와 플로팅 버튼을 만들고 body에는 텍스트 위젯을 배치합니다.
[글상자] lib/main.dart
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http; // http 패키지 불러오기
void main() => runApp(MyApp());
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
home: HttpApp(),
);
}
}
class HttpApp extends StatefulWidget {
@override
State<StatefulWidget> createState() => _HttpApp();
}
class _HttpApp extends State<HttpApp> {
String result = '';
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Http Example'),
),
body: Container(
child: Center(
child: Text('$result'),
),
177
),
floatingActionButton: FloatingActionButton(
onPressed: () {},
child: Icon(Icons.file_download), // 내려받는 모양의 아이콘 표시
),
);
}
}
[글상자 끝]
[3단계] 네트워크 통신을 하려면 접속할 대상 URL이 있어야 합니다. 우선 연습으로 구글 사이트에 접속해 보겠습니다.
[글상자] lib/main.dart
(...생략...)
floatingActionButton: FloatingActionButton(
onPressed: () async {
var url = 'http://www.google.com';
var response = await http.get(url);
setState(() {
result = response.body;
});
},
child: Icon(Icons.file_download),
),
(...생략...)

http.get(url); → GET 방식으로 URL에 접속하는 코드
[글상자 끝]
사용자가 버튼을 누르면 http.get을 통해 url에 입력한 주소에 데이터를 요청합니다. 해당 주소의 서버가 응답하면 가져온 데이터를 result에 넣고 그중 본문을 텍스트 위젯에 출력합니다. 코드에서 async 키워드는 「02-2」절에서 배웠던 비동기 처리 방식입니다. 즉, onPressed() 함수가 비동기로 동작한다는 의미입니다. 따라서 await를 통해 서버가 데이터를 넘겨줄 때까지 대기합니다. 그리고 서버로부터 데이터를 받으면 HTML로 구성된 본문(response.body)을 출력합니다.
네트워크 통신은 속도나 데이터양 같은 외부 요인 때문에 정확한 데이터를 받아온 다음에 처리해야 합니다. 따라서 네트워크 프로그래밍을 할 때는 이처럼 비동기 방식으로 구현합니다.
178
이대로 앱을 실행하고 플로팅 버튼을 눌러보세요. google.com에 접속할 때 얻는 데이터 중 본문이 화면에 표시됩니다.
[그림] 실행 결과


Http Example
[그림 끝]
[Do it! 실습] 책 정보 가져오기
앱에서 서버와 데이터 통신을 할 때 기존에는 일반 문자열이나 XML 형식을 이용했지만 요즘은 JSON을 많이 이용합니다. JSON은 파일 크기도 작으면서 태그를 이용해 값을 확인할 수 있기 때문입니다.
앞에서 카카오 API를 이용하는 방법을 살펴봤습니다. 여기서는 카카오에서 발급받은 REST API 키를 이용해 책 정보를 표시하는 앱을 만들어 보겠습니다.
[1단계] 먼저 기존 코드에서 floatingActionButton의 onPressed 이벤트 처리 함수를 다음처럼 변경합니다. JSON 데이터를 이용할 것이므로 convert 패키지도 불러옵니다.
[글상자] lib/main.dart
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
void main() => runApp(MyApp());
179
class MyApp extends StatelessWidget { ...생략... }
class HttpApp extends StatefulWidget { ...생략... }
class _HttpApp extends State<HttpApp> {
String result = '';
@override
Widget build(BuildContext context) {
(...생략...)
floatingActionButton: FloatingActionButton(
onPressed: () 〔async〕 {
getJSONData();
},
child: Icon(Icons.file_download),
),
);
}
Future<String> getJSONData() async {
var url = 'https://dapi.kakao.com/v3/search/book?target=title&query=doit';
var response = await http.get(Uri.encodeFull(url),
headers: {"Authorization": "KakaoAK ##REST API 키 넣기##"});
print(response.body);
return "Successfull";
}
}

##REST API 키 넣기## → 이곳에 카카오에서 발급받은 REST API 키를 넣으세요!
[글상자 끝]
플로팅 버튼을 누르면 getJSONData() 함수를 호출하도록 수정합니다. 비동기로 데이터를 주고받기 위해 getJSONData() 함수에 async를 선언하고 await를 이용해 통신합니다. 그리고 Future를 반환합니다. Future는 비동기 처리에서 데이터를 바로 처리할 수 없을 때 사용합니다.
url 변수에는 카카오 API에 데이터를 요청하는 URL을 넣습니다. 코드에 삽입한 URL은 다음과 같은 의미가 있습니다.
* 제작자 주: 강조 표시는 ‘검정대괄호’로 입력함.
【https://dapi.kakao.com/v3/search/book】(1)?【target=title】(2)&【query=doit】(3)
(1) 요청할 도메인입니다. 카카오에서 책을 검색하는 API를 나타냅니다.
(2) 도메인에 요청할 파라미터입니다. target 파라미터에 title을 전달합니다.
(3) query 파라미터에 검색어 doit을 전달합니다.
180
도메인에 ? 이후의 파라미터를 전달해서 데이터를 요청합니다. 파라미터는 & 기호로 구분하여 여러 개를 지정할 수 있습니다. target과 query 등 파라미터 이름은 API 개발사가 제공하는 문서에 나와 있으므로 참고해서 사용하면 됩니다. 이 URL의 전체 의미는 다음과 같습니다.

“dapi.kakao.com 서버에 있는 v3/search/book API야!
제목에 doit이 포함된 책을 알려줘!”

이때 카카오 API를 이용해 서버랑 직접 통신하므로 앞서 「카카오에서 API 키 얻기」에서 발급받은 REST API 키를 넣어야 합니다. 헤더에 키를 입력하고 http.get 코드로 HTTP 통신을 이용해 GET 방식으로 호출하면 서버에서 책 정보를 가져옵니다. 이를 print로 출력했으므로 실행 창을 통해 내용을 확인할 수 있습니다.
앱을 실행하고 플로팅 버튼을 누르면 서버에서 가져온 데이터가 JSON 형태로 출력되는 것을 볼 수 있습니다.
[그림] 실행 결과


I/flutter (14891): {"documents":[{"authors":["송호정", "이범근"], "contents":"어떤 앱에서든 써먹는 빈출 기능부터 배워야 효율적! 처음부터 예제로 만들면서 배우는 《Do it! 스위프트로 아이폰 앱 만들기 ? 입문》이 Swift 4.0 최신 버전을 반영해 돌아왔다! 프로그래밍의 높은 장벽을 확 낮춰주는 이 책은 프로그래머가 아니어도 볼 수 있다. 문법부터 시작하는 다른 책들과 달리 예제로 바로 접근하기 때문이다. 이 책의 엄선된 17개 실습 예제에는 어떤 앱에서든 한 번은 써야 할 기능들이 녹아있다. 내 손으로 만든 앱이 바로 눈", "datetime":"2017-12-12T00:00:00.000+09:00", "isbn": "118861214X 9791188612147", "price":28000, "publisher":"이지스퍼블리싱", "sale_price":25200, "status":"정상판매", "thumbnail": "https://search1.kakaockn.net/thumb/R120x174.q85/?fname=http%3A%2F%2Ft1.daumcdn.net%2F1book%2Fimage%2F1649857%3Ftimestamp%3D20200717133457", "title": "스위프트로 아이폰 앱 만<?>
[그림 끝]
[2단계] 이제 이 데이터를 List 형태의 data 변수에 넣겠습니다. initState() 함수에서 data 변수를 초기화하는 것도 잊지 않도록 합니다.
[글상자] lib/main.dart
(...생략...)
class _HttpApp extends State<HttpApp> {
String result = '';
List data;
181
@override
void initState() {
super.initState();
data = new List();
}
@override
Widget build(BuildContext context) { ...생략... }
Future<String> getJSONData() async {
(...생략...)
〔print(response.body);〕
setState(() {
var dataConvertedToJSON = json.decode(response.body);
List result = dataConvertedToJSON['documents'];
data.addAll(result);
});
return response.body;
}
}
[글상자 끝]
[3단계] 서버에서 가져온 데이터를 준비했으니 이제 리스트 형태로 화면에 출력해 봅시다.
build() 함수에서 ListView를 선언합니다.
[글상자] lib/main.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar( ...생략... ),
body: Container(
child: Center(
child: data.length == 0
? Text(
'데이터가 없습니다.',
182
style: TextStyle(fontSize: 20),
textAlign: TextAlign.center,
)
: ListView.builder(
itemBuilder: (context, index) {
return Card(
child: Container(
child: Column(
children: <Widget>[
Text(data[index]['title'].toString()),
Text(data[index]['authors'].toString()),
Text(data[index]['sale_price'].toString()),
Text(data[index]['status'].toString()),
Image.network(
data[index]['thumbnail'],
height: 100,
width: 100,
fit: BoxFit.contain,
)
],
),
),
);
},
itemCount: data.length),
),
),
floatingActionButton: FloatingActionButton( ...생략... ),
);
} // build() 함수 종료
(...생략...)
[글상자 끝]
data가 0일 때는 Text 위젯을 이용해 데이터가 없다는 문구를 표시합니다. 그리고 데이터가 0이 아니면, 즉 서버로부터 데이터를 받으면 ListView.builder로 표시하게 합니다. itemCount에 data의 길이만큼 아이템 개수를 지정하고 Column을 만들어서 data에서 JSON 키값에 해당하는 값을 화면에 출력합니다.
183
Image.network는 네트워크에 있는 이미지를 가져오는 위젯입니다. 이 위젯을 이용하면 data[index]['thumbnail']에서 가져온 URL을 이용해 간단하게 화면에 이미지를 출력할 수 있습니다. 소스를 저장하고 앱을 실행해 보면 다음처럼 도서 목록이 보입니다.
[그림] 실행 결과


(↓) - 클릭
→ Http Example
스위프트로 아이폰 앱 만들기: 입문(Do it!)(개정판 2판), [송호정, 이범근], 25200, 정상판매
Do it! 점프 투 파이썬, [박응용], 16920, 정상판매
Do it! 자바 프로그래밍 입문, [박은종], 22500, 정상판매
Do it! C언어 입문, [김성엽], 22500, 정상판매
[그림 끝]
카드 위젯을 좀 더 꾸며서 화면을 정돈해 보겠습니다. _HttpApp 클래스의 build() 함수에서 카드 위젯을 구현한 부분을 다음처럼 수정합니다.
[Do it! 실습] 카드 위젯 꾸미기
[글상자] lib/main.dart
(...생략...)
return Card(
child: Container(
child: Row(
children: <Widget>[
// 여기에 있던 Text 위젯 삭제
Image.network(
data[index]['thumbnail'],
height: 100,
184
width: 100,
fit: BoxFit.contain,
),
Column(
children: <Widget>[
Container(
width: MediaQuery.of(context).size.width - 150,
child: Text(
data[index]['title'].toString(),
textAlign: TextAlign.center,
),
),
Text('저자 : ${data[index]['authors'].toString()}'),
Text('가격 : ${data[index]['sale_price'].toString()}'),
Text('판매중 : ${data[index]['status'].toString()}'),
],
)
],
mainAxisAlignment: MainAxisAlignment.start,
), // Row
), // Container
); // Card
(...생략...)
[글상자 끝]
[그림] 실행 결과


Http Example
스위프트로 아이폰 앱 만들기: 입문(Do it!)(개정판 2판)
저자: [송호정, 이범근]
가격: 25200
판매중: 정상판매
Do it! 점프 투 파이썬
저자: [박응용]
가격: 16920
판매중: 정상판매
Do it! 자바 프로그래밍 입문
저자: [박은종]
가격: 22500
판매중: 정상판매
Do it! C언어 입문
저자: [김성엽]
가격: 22500
판매중: 정상판매
Do it! 쉽게 배우는 R 데이터 분석
저자: [김영우]
가격: 18000
판매중: 정상판매
Do it! 자바스크립트+제이쿼리 입문(전면 개정판)
저자: [정인용]
가격: 18000
판매중: 정상판매
[그림 끝]
카드 위젯에서 Row와 Column을 이용해 화면을 배치합니다. 이때 MediaQuery.of(context).size는 지금 스마트폰의 화면 크기를 의미합니다. 스마트폰별로 화면의 크기가 조금씩 다르기 때문에 화면의 넓이에서 이미지를 뺀 나머지만큼만 제목을 입력하도록 합니다. 만약 제목을 그냥 출력하면 영역을 벗어난 부분에 노란색 빗금으로 영역 넘김 오류 표시[각주*]가 보일 겁니다.
[각주*] 영역 넘김 오류는 05장 「리스트에 동물 추가하기」에서 살펴봤습니다.[각주 끝]
185
[Do it! 실습] 검색 기능 추가하기
지금까지는 url에 ‘doit’이라는 질의를 넣어서 책 제목에 ‘doit’이 포함된 책만 가져왔습니다. 이번에는 텍스트필드를 이용해 사용자가 직접 검색어를 입력할 수 있게 해보겠습니다. 즉, 사용자가 입력한 단어가 제목에 포함된 책을 찾아서 표시해주는 기능입니다.
[1단계] 텍스트필드 위젯을 만들고 initState() 함수에서 TextEditingController를 초기화 합니다.
[글상자] lib/main.dart
(...생략...)
class _HttpApp extends State<HttpApp> {
String result = '';
List data;
TextEditingController _editingController;
@override
void initState() {
super.initState();
data = new List();
_editingController = new TextEditingController();
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: TextField(
controller: _editingController,
style: TextStyle(color: Colors.white),
keyboardType: TextInputType.text,
decoration: InputDecoration(hintText: '검색어를 입력하세요'),
),
),
body: Container(
(...생략...)
[글상자 끝]
186
앱바의 title:에 텍스트필드를 넣고 컨트롤러와 스타일, 키보드 유형 등을 설정합니다. 모두 05장에서 사용해 봤으므로 어렵지 않게 이해할 수 있을 것입니다. 이와 더불어 decoration은 텍스트필드 위젯에 보이는 텍스트를 꾸미는 옵션입니다. 여기에 사용한 hintText는 사용자에게 텍스트필드에 무엇을 입력해야 하는지를 알려주는 역할을 합니다.
[2단계] 이제 컨트롤러에서 받은 데이터를 URL 질의에 적용할 수 있도록 getJSONData() 함수에 있는 url을 수정합니다.
[글상자] lib/main.dart
(...생략...)
Future<String> getJSONData() async {
var url =
'https://dapi.kakao.com/v3/search/book?'
'target=title&query=${_editingController.value.text}';
(...생략...)
[글상자 끝]
앱을 다시 실행한 후 검색란에 ‘바빠’를 입력해 보세요. 이후 플로팅 버튼을 누르면 다음처럼 출력되는 것을 확인할 수 있습니다.
[그림] 실행 결과


바빠
바쁜 초등학생을 위한 빠른 구구단(바빠 학습법 시리즈)
저자: [강난영, 이은영, 정미란]
가격: 8100
판매중: 정상판매
바쁜 초등학생을 위한 빠른 급수 한자 7급. 1(바빠 급수한자 시리즈)
저자: [김정미, 강민]
가격: 8100
판매중: 정상판매
바쁜 3 4학년을 위한 빠른 연산법: 나눗셈 편(바빠 연산법 시리즈)
저자: [스쿨피아 연구소, 최순미]
가격: 8100
판매중: 정상판매
바쁜 5 6학년을 위한 빠른 연산법: 분수 편(바빠 연산법 시리즈)
저자: [스쿨피아 연구소]
가격: 8100
판매중: 정상판매
바쁜 나 혼자 푼다! 수학 문장제 1학년 2학기(바빠 학습법 시리즈)
저자: [최순미]
가격: 8100
판매중: 정상판매
바빠요 바빠(도토리 계절 그림책)
저자: [윤구병]
가격: 8100
판매중: 정상판매
[그림 끝]
187
[Do it! 실습] 스크롤로 책 정보 가져오기
앞에서 만든 앱은 플로팅 버튼을 누를 때마다 제목에 검색어가 포함된 총 10권의 책을 서버로부터 받아서 표시합니다. 이를 개선해 플로팅 버튼을 한 번 누른 다음에는 스크롤을 내릴 때마다 이어서 새로운 책을 받아서 표시해 보겠습니다. 이 기능은 리스트뷰를 끝으로 옮기면 자동으로 다음 API를 호출하는 방법으로 구현할 수 있습니다.
[1단계] 먼저 데이터를 요청하는 URL 구성을 다음처럼 페이지 단위로 불러올 수 있게 수정합니다.
[글상자] lib/main.dart
(...생략...)
var url = 'https://dapi.kakao.com/v3/search/book?'
'target=title&page=$page&query=${_editingController.value.text}';
(...생략...)
[글상자 끝]
요청 URL에 page 파라미터를 추가했습니다. 이 파라미터를 이용해 페이지 단위로 데이터를 가져올 수 있게 구현해 보겠습니다. 한 페이지당 책 정보는 10권씩 받아옵니다.
[2단계] 화면에서 목록을 가장 밑으로 내리면 page 숫자를 증가한 후 서버에 이를 다시 요청하는 코드를 작성합니다. 먼저 _HttpApp 클래스에서 스크롤 컨트롤러와 페이지에 해당하는 변수를 선언합니다.
[글상자] lib/main.dart
(...생략...)
class _HttpApp extends State<HttpApp> {
String result = '';
List data;
TextEditingController _editingController;
ScrollController _scrollController;
int page = 1;
@override
void initState() {
super.initState();
188
data = new List();
_editingController = new TextEditingController();
_scrollController = new ScrollController();
_scrollController.addListener(() {
if (_scrollController.offset >=
_scrollController.position.maxScrollExtent &&
!_scrollController.position.outOfRange) {
print('bottom'); // 리스트의 마지막일 때 실행
page++;
getJSONData();
}
});
}
(...생략...)
[글상자 끝]
initState() 함수에서 new로 생성한 스크롤 컨트롤러의 addListener() 함수를 이용해 스크롤할 때 이벤트를 받도록 처리합니다. offset은 목록에서 현재 위치를 double형 변수로 나타냅니다. 스크롤할 때마다 offset을 검사해 maxScrollExtent보다 크거나 같고 스크롤 컨트롤러의 position에 정의된 범위를 넘어가지 않으면 목록의 마지막이라고 인식합니다. 그러면 page를 1만큼 증가한 후 getJSONData() 함수를 호출합니다.
[3단계] 이렇게 정의한 스크롤 컨트롤러를 ListView.build() 함수의 controller 옵션에 입력합니다. 이제 목록에서 스크롤을 내려 마지막에 닿을 때마다 API를 호출해 새로운 책을 출력합니다.
[글상자] lib/main.dart
(...생략...)
},
itemCount: data.length,
controller: _scrollController,
),
),
),
floatingActionButton: FloatingActionButton(
(...생략...)
[글상자 끝]
189
[4단계] 버튼을 누를 때마다 기존 내용을 지우고 페이지를 1로 초기화하는 코드도 추가합니다.
[글상자] lib/main.dart
(...생략...)
floatingActionButton: FloatingActionButton(
onPressed: () {
page = 1;
data.clear();
getJSONData();
},
child: Icon(Icons.file_download),
),
(...생략...)
[글상자 끝]
소스를 저장하고 앱을 실행합니다. 그러면 검색 후 보이는 책 목록을 스크롤할 때마다 새로운 책을 받아서 보여줍니다.
[그림] 실행 결과


Do it!
Do it! 점프 투 파이썬
저자: [박응용]
가격: 16920
판매중: 정상판매
Do it! 자바 프로그래밍 입문
저자: [박은종]
가격: 22500
판매중: 정상판매
Do it! C언어 입문
저자: [김성엽]
가격: 22500
판매중: 정상판매
Do it! 쉽게 배우는 R 데이터 분석
저자: [김영우]
가격: 18000
판매중: 정상판매
Do it! 자바스크립트+제이쿼리 입문(전면 개정판)
저자: [정인용]
가격: 18000
판매중: 정상판매
Do it! 오라클로 배우는 데이터베이스 입문
저자: [이지훈]
가격: 22500
판매중: 정상판매
[그림 끝]
지금까지 네트워크를 이용해 서버에서 데이터를 가져와 표시하는 앱을 만들어 봤습니다. 그러면서 외부 패키지와 API를 이용하는 방법도 알아보았습니다. 대부분 앱이 네트워크를 사용해 데이터를 주고받으며 서비스를 제공하므로 이번 장에서 살펴본 주요 위젯이나 함수 등은 잘 알아두기 바랍니다.
190
07-2 이미지 파일 내려받기
앱을 사용하다 보면 용량이 큰 파일을 내려받아야 할 때가 있습니다. 사용자는 파일을 다 내려받을 때까지 기다려야 하는데, 이때 화면에 아무런 정보가 표시되지 않는다면 앱이 멈춘 것으로 생각할 수 있습니다. 어떤 통계에서는 3초 이상 아무런 반응이 없으면 사용자들은 앱이 멈춘 것으로 안다고 합니다. 그러므로 파일을 내려받을 때 진행 상황을 표시해 주면 사용자가 안심하고 기다릴 수 있습니다. 이번 절에서는 외부 패키지를 사용해 파일을 내려받는 앱을 구현해 보겠습니다.
[Do it! 실습] 내려받기 진행 상황 표시하기
서버에서 이미지 파일을 내려받는 앱을 만들어 보겠습니다. 이번 실습에서는 파일을 내려받는 데 도움을 주는 dio라는 패키지와 내부 저장소를 이용하는 path_provider라는 패키지를 이용해 보겠습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] 먼저 largefile_download라는 이름으로 새로운 플러터 프로젝트를 만듭니다. 그리고 pubspec.yaml 파일을 열고 다음처럼 dio, path_provider 패키지를 추가합니다. 패키지를 추가했으면 소스 편집 창 위쪽에 보이는 플러터 명령 줄에서 <Pub get>을 눌러 패키지를 내려받습니다.
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
cupertino_icons: ^1.0.0
dio: ^3.0.10
path_provider: ^1.6.24
(...생략...)
[글상자 끝]
191
[2단계] lib 폴더에 largeFileMain.dart 파일을 만들고 다음 코드를 작성합니다.
[글상자] lib/largeFileMain.dart
import 'package:flutter/material.dart';
import 'package:dio/dio.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:io';
class LargeFileMain extends StatefulWidget {
@override
State<StatefulWidget> createState() => _LargeFileMain();
}
class _LargeFileMain extends State<LargeFileMain> {
// 내려받을 이미지 주소
final imgUrl =
'https://images.pexels.com/photos/240040/pexels-photo-240040.jpeg'
'?auto=compress';
bool downloading = false; // 지금 내려받는 중인지 확인하는 변수
var progressString = ""; // 현재 얼마나 내려받았는지 표시하는 변수
var file; // 내려받은 파일
@override
Widget build(BuildContext context) {
return null;
}
}
[글상자 끝]
앞에서 추가한 두 패키지를 import로 불러옵니다. 더불어 파일 입출력을 돕는 io 패키지도 불러옵니다. 그리고 StatefulWidget을 상속받는 LargeFileMain 클래스를 생성한 후 _LargeFileMain() 함수를 반환하도록 합니다. _LargeFileMain은 State<LargeFileMain>을 상속받는 클래스입니다. 여기에 이번 실습에서 사용할 4가지 변수를 선언합니다. 이미지 파일은 무료 스톡 사진을 제공하는 Pexels 사이트에서 pexels-photo-240040.jpeg라는 이름의 이미지[각주*]를 내려받도록 했습니다.
[각주*] 따사로운 숲 사진이며 용량은 약 2.8?로 그렇게 크지 않지만 빠른 실습을 위해 예로 사용했습니다.[각주 끝]
192
[3단계] 파일을 내려받는 downloadFile() 함수를 _LargeFileMain 클래스에 작성합니다.
[글상자] lib/largeFileMain.dart
(...생략...)
Future<void> downloadFile() async {
Dio dio = Dio();
try {
var dir = await getApplicationDocumentsDirectory();
await dio.download(imgUrl, '${dir.path}/myimage.jpg',
onReceiveProgress: (rec, total) {
print('Rec: $rec , Total: $total');
file = '${dir.path}/myimage.jpg';
setState(() {
downloading = true;
progressString = ((rec / total) * 100).toStringAsFixed(0) + '%';
});
});
} catch (e) {
print(e);
}
setState(() {
downloading = false;
progressString = 'Completed';
});
print('Download completed');
}
} // _LargeFileMain 클래스를 마치는 괄호
[글상자 끝]
dio를 선언한 후 내부 디렉터리를 가져옵니다. getApplicationDocumentsDirectory() 함수는 path_provider 패키지가 제공하며 플러터 앱의 내부 디렉터리를 가져오는 역할을 합니다. dio.download를 이용해 url에 담긴 주소에서 파일을 내려받습니다. 내려받는 파일은 내부 디렉터리 안에 myimage.jpg라는 이름으로 저장합니다. 이때 데이터를 받을 때마다 onReceiveProgress() 함수를 실행해 진행 상황을 표시합니다. 이 함수가 전달받은 rec는 지금까지 내려받은 데이터, total은 파일의 전체 크기입니다.
내려받기가 시작되면 downloading = true를 선언하고 얼마나 받았는지 계산한 후 프로그레
193
스에 표시할 문자열에 입력합니다. 다 내려받았으면 downloading = false로 고친 후 프로그레스 문자열을 ‘Completed’로 바꿔줍니다.
[4단계] build() 함수에서 스캐폴드를 이용해 머티리얼 형태로 표시하고 앱바와 플로팅 버튼을 만듭니다. 플로팅 버튼을 누르면 파일을 내려받는 downloadfile() 함수를 실행합니다. body는 downloading이 true인지 false인지에 따라서 위젯을 구성합니다. 먼저 true일 때는 다음처럼 작성합니다.
[글상자] lib/largeFileMain.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Large File Example'),
),
body: Center(
child: downloading
? Container(
height: 120.0,
width: 200.0,
child: Card(
color: Colors.black,
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: <Widget>[
CircularProgressIndicator(),
SizedBox(
height: 20.0,
),
Text(
'Downloading File: $progressString',
style: TextStyle(
color: Colors.white,
),
)
],
194
),
),
)
: // downlading이 false일 때 코드는 다음 단계에서 작성함
floatingActionButton: FloatingActionButton(
onPressed: () {
downloadFile();
},
child: Icon(Icons.file_download),
),
);
}
(...생략...)
[글상자 끝]
downloading이 true라는 의미는 파일을 내려받고 있다는 의미입니다. 이때는 현재 얼마나 진행되었는지 확인할 수 있는 위젯을 설정합니다. SizedBox 위젯을 이용하면 고정된 높이와 넒이 안에서 네모난 형태의 위젯을 만들 수 있습니다. 위젯을 구성한 화면은 다음과 같습니다.
[그림 7-10] 진행 상황을 알려주는 위젯 구성


Downloading File: 41%
[그림 끝]
[5단계] 이제 downloading이 false일 때 보일 위젯을 만듭니다.
[글상자] lib/largeFileMain.dart
(...생략...)
body: Center(
child: downloading
? Container( ...생략... )
: FutureBuilder(
builder: (context, snapshot) {
switch (snapshot.connectionState) {
case ConnectionState.none:
print('none');
return Text('데이터 없음');
case ConnectionState.waiting:
print('waiting');
return CircularProgressIndicator();
195
case ConnectionState.active:
print('active');
return CircularProgressIndicator();
case ConnectionState.done:
print('done');
if (snapshot.hasData) {
return snapshot.data;
}
}
print('end process');
return Text('데이터 없음');
},
future: downloadWidget(file),
)),
(...생략...)
[글상자 끝]
FutureBuilder 위젯을 이용해 이미지 내려받기 화면을 만들었습니다. 이 책에서 처음 등장한 FutureBuilder 위젯은 아직은 데이터가 없지만 앞으로 데이터를 받아서 처리한 후에 만들겠다는 의미입니다.
파일 입출력이나 네트워크 통신을 구현할 때는 대부분 비동기 방식[각주*]으로 처리하기 때문에 Future를 이용합니다. FutureBuilder는 builder에서 snapshot이라는 변수를 반환하는데, snapshot은 FutureBuilder.future에서 받아온 데이터를 저장한 dynamic 형태의 변수입니다. snapshot.connectionState를 이용해 switch 문으로 데이터를 받을 때, 오류가 발생할 때, 데이터가 완료되었을 때를 나누어 처리합니다. 즉, connectionState값이 done이면 snapshot.data를 반환합니다.
[각주*] 비동기 방식 처리에 관한 자세한 내용은 「02-2」절에서 다루었어요.[각주 끝]
[표 7-1] ConnectionState값
ConnectionState

설명

none

FutureBuilder.future가 null일 때

waiting

연결되기 전(FutureBuilder.future에서 데이터를 반환받지 않았을 때)

active

하나 이상의 데이터를 반환받을 때

done

모든 데이터를 받아서 연결이 끝날 때

196
[6단계] snapshot.data는 downloadWidget(file) 함수가 반환하는 데이터입니다. 이 함수를 _LargeFileMain 클래스에 다음처럼 작성합니다.
[글상자] lib/largeFileMain.dart
(...생략...)
Future<Widget> downloadWidget(String filePath) async {
File file = File(filePath);
bool exist = await file.exists();
new FileImage(file).evict(); // 캐시 초기화하기
if (exist) {
return Center(
child: Column(
children: <Widget>[Image.file(File(filePath))],
),
);
} else {
return Text('No Data');
}
}
(...생략...)
[글상자 끝]
downloadWidget() 함수는 이미지 파일이 있는지 확인해서 있으면 이미지를 화면에 보여주는 위젯을 반환하고, 없으면 ‘No Data’라는 텍스트를 출력합니다.
그리고 evict() 함수는 캐시[각주*]를 초기화합니다. 플러터는 빠른 이미지 처리를 위해 캐시에 같은 이름의 이미지가 있으면 이미지를 변경하지 않고 해당 이미지를 사용합니다. 이때 evict() 함수를 호출해 캐시를 비우면 같은 이름이어도 이미지를 갱신합니다.
[각주*] 데이터를 빠르게 처리하기 위해 임시로 저장하는 메모리입니다.[각주 끝]
[7단계] 마지막으로 앱을 실행할 main.dart 파일을 다음처럼 작성합니다. home에 지금까지 작성한 내용이 담긴 LargeFileMain 클래스를 입력합니다.
197
[글상자] lib/main.dart
import 'package:flutter/material.dart';
import 'largeFileMain.dart';
void main() => runApp(MyApp());
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
home: LargeFileMain(),
);
}
}
[글상자 끝]
이제 앱을 실행하고 플로팅 버튼을 누르면 이미지를 내려받습니다. 그리고 프로그레스가 동작하면서 진행 상황이 퍼센티지로 보이다가 100%가 되면 비로소 내려받은 이미지가 화면에 나타납니다.
[그림] 실행 결과


Large File Example - Downloading File: 35%
Large File Example
[그림 끝]
198
[Do it! 실습] URL을 직접 입력해 내려받기
앞에서 만든 앱에 텍스트필드를 추가해 이미지 위치를 직접 입력해서 내려받는 기능을 추가해 보겠습니다.
[1단계] 먼저 텍스트필드를 사용하기 위해 TextEditcontroller를 선언하고 initState() 함수를 호출해 _editingController를 생성합니다. 그리고 앱바에 「07-1」절에서 만들었던 책 검색을 이용하여 화면을 만듭니다.
[글상자] lib/largeFileMain.dart
(...생략...)
class _LargeFileMain extends State<LargeFileMain> {
(...생략...)
〔final imgUrl =〕
〔'https://images.pexels.com/photos/240040/pexels-photo-240040.jpeg'〕
〔'?auto=compress';〕
TextEditingController _editingController;
@override
void initState() {
super.initState();
_editingController = new TextEditingController(
text: 'https://images.pexels.com/photos/240040/pexels-photo-240040.jpeg'
'?auto=compress');
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: TextField(
controller: _editingController,
style: TextStyle(color: Colors.white),
keyboardType: TextInputType.text,
decoration: InputDecoration(hintText: 'url 입력하세요'),
),
),
(...생략...)
[글상자 끝]
199
새로운 TextEditingController를 생성할 때 text 인자를 사용했습니다. text 인자에 앞에서 사용했던 이미지 URL을 기본값으로 넣었습니다. 그리고 사용자가 새로운 URL을 입력할 수 있도록 텍스트필드를 만들고 컨트롤러에 _editingController를 연결했습니다.
즉, 앱을 실행하고 바로 내려받기 버튼을 누르면 기본적으로 TextEditingController의 text 인자에 넣은 주소에서 이미지를 내려받고, 텍스트필드에 다른 이미지 URL을 넣으면 해당 주소에서 내려받습니다.
[2단계] 사용자가 텍스트필드에 입력한 주소에 있는 이미지를 내려받으려면 downloadFile() 함수에서 dio.download() 함수의 첫 번째 인자로 사용자가 입력한 주소를 전달해야 합니다. 앞 단계에서 설정한 _editingController를 전달하도록 코드를 수정합니다.
[글상자]
(...생략...)
Dio dio = Dio();
try {
var dir = await getApplicationDocumentsDirectory();
await dio.download(_editingController.value.text, '${dir.path}/myimage.jpg',
onReceiveProgress: (rec, total) {
(...생략...)
[글상자 끝]
앱을 실행하고 바로 내려받기 버튼을 누르면 이전 실습과 마찬가지로 숲 이미지가 나타납니다. 이어서 텍스트필드에 새로운 이미지가 있는 주소를 입력하고 버튼을 누르면 새로운 이미지를 내려받아 이미지를 변경합니다.
[그림] 실행 결과


(1) (↓)
(2) https://images.pexels.com/photos/3334482/pexel
(3) (↓) → 사진
[그림 끝]
200
지금까지 HTTP를 이용해 서버와 데이터를 주고받는 기능과 이미지 파일을 내려받으면서 진행 상황을 표시하는 기능을 만들어 봤습니다. 참고로 한 번 내려받은 파일을 내부 스토리지에 저장해 놓으면 필요할 때 다시 내려받지 않고 바로 사용할 수 있습니다.
[아하!] 에뮬레이터에서 복사와 붙여넣기는 어떻게 하나요?
에뮬레이터에서 텍스트를 붙여 넣으려면 텍스트필드에서 더블클릭을 이용합니다. 그러면 복사와 붙여넣기 등 텍스트를 편집할 수 있는 기능이 나타납니다.
[그림 7-11] 에뮬레이터에서 복사와 붙여넣기


https://images.pexels.com/photos/240040/pexels
Cut, Copy, Paste, Select all
[그림 끝]
그렇다면 새로운 이미지가 있는 주소를 복사한 다음 에뮬레이터에 붙여 넣으려면 어떻게 해야 할까요? 먼저 기존 주소가 입력된 텍스트필드를 마우스 왼쪽 버튼으로 더블클릭한 다음 <Select all>을 눌러 전체 텍스트를 선택하고 지웁니다. 그리고 새 이미지가 있는 주소를 복사한 다음, 다시 빈 텍스트필드를 더블클릭하고 <Paste>를 누르면 복사한 주소를 붙여 넣을 수 있습니다.
[아하! 끝]
201
08 내비게이션 활용하기
지금까지는 대부분 한 페이지로 구성된 플러터 앱을 만들었습니다. 한 페이지로도 훌륭한 앱을 만들 수 있지만 기능이 많으면 화면을 구성하기가 어렵고 로딩이 느려지기도 합니다. 이럴 때는 내비게이션 기능을 이용하면 됩니다. 내비게이션 기능은 앱이 제공하는 기능이나 메뉴별로 화면을 분리해서 개발하는 방법으로, 사용자에게 체계적인 서비스 구성을 제공해 앱을 사용할 때 길을 헤매지 않게 합니다. 이번 장에서는 내비게이션 기능을 이해하고 이를 활용해 페이지끼리 데이터를 주고받으면서 할 일을 기록하는 앱을 만들어 보겠습니다.
08-1 내비게이션 이해하기
08-2 할 일을 기록하는 앱 만들기
202
08-1 내비게이션 이해하기
자동차에 달린 내비게이션은 “500미터 앞에서 우회전하세요”, “지하 차도를 이용하세요” 등 그때 그때 길을 알려주기 때문에 처음 가는 길이라도 정확하게 목적지까지 갈 수 있습니다. 앱에도 이러한 내비게이션 역할을 하는 기능이 있습니다. 한 페이지로 앱을 만들면 페이지 이동이 필요 없으므로 내비게이션이 필요 없지만 여러 페이지로 만들 때는 어떤 버튼을 누르면 어디로 이동할지, 이때 어떤 데이터를 주고받을지 등을 고려해서 내비게이션을 설계해야 합니다.
이미 05장에서 두 페이지를 만들고 탭바를 이용해 페이지를 이동하는 기능을 구현해 보면서 맛보기로 내비게이션 기능을 사용해 보았습니다. 이번 절에서는 내비게이션이 어떻게 동작하는지 좀 더 자세하게 알아보겠습니다.
[Do it! 실습] 페이지 이동하기
[1단계] 먼저 페이지를 이동하는 기능을 만들어 내비게이션의 동작 원리를 살펴보겠습니다. subpage_example이라는 이름으로 새로운 플러터 프로젝트를 만듭니다. 그런 다음 main.dart 파일을 열고 다음과 같은 코드를 작성합니다. 첫 화면의 기본 골격은 지금까지 실습한 내용과 다르지 않으므로 자세한 설명은 생략합니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[글상자] lib/main.dart
import 'package:flutter/material.dart';
void main() {
runApp(MyApp());
}
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'SubPage Example',
203
theme: ThemeData(
primarySwatch: Colors.blue,
),
home: FirstPage(),
);
}
}
class FirstPage extends StatefulWidget {
@override
State<StatefulWidget> createState() => _FirstPage();
}
class _FirstPage extends State<FirstPage> {
@override
Widget build(BuildContext context) {
return null;
}
}
[글상자 끝]
[2단계] 다음은 _FirstPage 클래스에 위젯으로 화면을 만듭니다. 스캐폴드를 이용해 뼈대를 만들고 앱바와 플로팅 버튼을 만듭니다.
[글상자] lib/main.dart
(...생략...)
class _FirstPage extends State<FirstPage> {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Sub Page Main'),
),
body: Container(
child: Center(
child: Text('첫 번째 페이지'),
),
204
),
floatingActionButton: FloatingActionButton(
onPressed: () {},
child: Icon(Icons.add),
),
);
}
}
(...생략...)
[글상자 끝]
[3단계] 이번에는 두 번째 페이지를 만들어 보겠습니다. main.dart에서 _FirstPage 클래스 아래에 StatelessWidget을 상속받는 SecondPage 클래스를 만듭니다.
[글상자] lib/main.dart
(...생략...)
class SecondPage extends StatelessWidget {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Second Page'),
),
body: Container(
child: Center(
child: RaisedButton(
onPressed: () {},
child: Text('돌아가기'),
),
),
),
);
}
}
(...생략...)
[글상자 끝]
205
[4단계] _FirstPage 클래스에 만든 플로팅 버튼을 눌렸을 때 호출되는 onPressed 이벤트 처리 함수를 작성합니다.
[글상자] lib/main.dart
(...생략...)
floatingActionButton: FloatingActionButton(
onPressed: () {
Navigator.of(context)
.push(MaterialPageRoute(builder: (context) => SecondPage()));
},
child: Icon(Icons.add),
),
(...생략...)
[글상자 끝]
Navigator는 스택(stack)을 이용해 페이지를 관리할 때 사용하는 클래스입니다. Navigator 클래스의 of(context) 함수는 현재 페이지를 나타내고 push() 함수는 스택에 페이지를 쌓는 역할을 합니다. 따라서 위의 코드는 현재 페이지 위에 SecondPage를 쌓는 것으로 해석할 수 있습니다.
다음은 플로팅 버튼을 눌렀을 때 스택 메모리에 페이지가 쌓이는 구조를 나타낸 그림입니다.
[그림 8-1] push() 함수 호출 시 스택 구조의 변화


main: FirstPage → main: SecondPage, FirstPage
[그림 끝]
push() 함수에 전달한 MaterialPageRoute() 함수는 머티리얼 스타일로 페이지를 이동하게 해줍니다. 앱을 실행해서 플로팅 버튼을 누르면 페이지가 이동하는 애니메이션을 볼 수 있습니다.
206
[그림] 실행 결과


Sub Page Mane: 첫 번째 페이지
← 뒤로 가기 버튼
[그림 끝]
실행 결과를 보면 두 번째 페이지 제목 줄에 화살표 모양(←)의 뒤로 가기 버튼이 보입니다. 이 버튼은 안드로이드나 iOS 모두 기본으로 제공하며 버튼을 누르면 이전 페이지로 이동합니다. 이처럼 기본으로 뒤로 가기 버튼이 있기는 하지만 여기서는 학습을 위해 <돌아가기> 버튼에 이전 페이지로 이동하는 기능을 넣어 보겠습니다. 그래야지만 내비게이션을 조작하는 코드를 이해할 수 있습니다.
[5단계] 3단계에서 작성한 secondPage 클래스에 <돌아가기> 버튼을 눌렀을 때 호출되는 onPressed 이벤트 처리 함수를 다음처럼 작성합니다.
[글상자] lib/main.dart
(...생략...)
child: RaisedButton(
onPressed: () {
Navigator.of(context).pop(); // 지금 페이지를 종료
},
child: Text('돌아가기'),
),
(...생략...)
[글상자 끝]
207
Navigator.of() 함수에 이어서 호출한 pop() 함수는 스택 메모리에서 맨 위에 있는 페이지를 제거합니다. 두 번째 페이지가 보인다는 것은 현재 스택 메모리 맨 위에는 SecondPage가 있다는 의미입니다. 따라서 두 번째 페이지에 있는 <돌아가기> 버튼을 누르면 두 번째 화면이 사라지고 첫 번째 화면이 보이게 됩니다.
[그림 8-2] pop() 함수 호출 시 스택 구조의 변화


main: SecondPage, FirstPage → main: FirstPage
[그림 끝]
[Do it! 실습] 라우트로 페이지 이동하기
라우트(route)는 통신에서 이동 경로를 의미하는 용어입니다. 네트워크 프로그래밍에서는 요청 URL을 해석해 정해진 경로로 이동하는 기능을 라우트라고 합니다. 이러한 라우트 기능을 이용하면 페이지 이동 기능을 좀 더 편리하게 구현할 수 있습니다.
[1단계] 라우트를 이용해 페이지를 이동해 보겠습니다. main.dart에서 MaterialApp을 선언하는 부분에 home을 지우고 다음과 같이 코드를 작성합니다.
[글상자] lib/main.dart
(...생략...)
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'SubPage Example',
theme: ThemeData(
primarySwatch: Colors.blue,
208
),
initialRoute: '/',
routes: {'/': (context) => FirstPage (),
'/second': (context) => SecondPage()},
);
}
}
(...생략...)
[글상자 끝]
home 대신에 initialRoute와 routes를 사용했습니다. routes에는 <String : Widget> 형태로 경로를 선언합니다. String에 경로로 사용할 문자열을 입력하고 Widget에는 해당 경로가 가리키는 위젯을 지정합니다. 코드에서는 '/'와 '/second'에 각각 첫 번째 페이지(FirstPage)와 두 번째 페이지(SecondPage)를 지정했습니다. 그리고 initialRoute에는 처음 앱을 시작했을 때 보여 줄 경로를 지정합니다. '/'라고 입력했으므로 앱을 실행하면 첫 번째 페이지가 보입니다.
[2단계] 이제 플로팅 버튼의 기존 내비게이션 코드를 다음처럼 바꿉니다.
[글상자] lib/main.dart
(...생략...)
floatingActionButton: FloatingActionButton(
onPressed: () {
Navigator.of(context).pushNamed('/second');
},
child: Icon(Icons.add),
),
(...생략...)
[글상자 끝]
Navigator와 of()까지는 기존과 같고 push() 대신에 pushNamed() 함수로 변경했습니다. 이 함수는 페이지를 이동할 때 routes에 선언한 경로를 이용합니다. 따라서 첫 번째 페이지에서 플로팅 버튼을 누르면 /second라는 경로를 지정한 두 번째 페이지로 이동합니다. 앱을 실행하면 이전과 똑같이 동작합니다.
209
08-2 할 일을 기록하는 앱 만들기
이번 절에서는 내비게이션으로 페이지를 이동할 때 데이터를 함께 전달하는 방법을 살펴보겠습니다. 이러한 기능을 이용해 할 일을 기록하는 To Do 앱을 만들어 보겠습니다.
[Do it! 실습] 페이지 이동 기능 만들기
본격적으로 To Do 앱을 만들기 전에 이 앱에서 사용할 페이지 이동 기능을 구현해 보겠습니다. 앞의 실습에서 다룬 내용이므로 빠르게 진행해 보겠습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] todo_list라는 이름으로 새로운 플러터 프로젝트를 만듭니다. 그리고 subDetail.dart 파일을 만들어 다음처럼 기본 클래스를 작성합니다.
[글상자] lib/subDetail.dart
import 'package:flutter/material.dart';
class SubDetail extends StatefulWidget {
@override
State<StatefulWidget> createState() => _SubDetail();
}
class _SubDetail extends State<SubDetail> {
@override
Widget build(BuildContext context) {
return null;
}
}
[글상자 끝]
[2단계] 이제 _SubDetail 클래스의 build() 함수 안에 Container를 이용해 버튼을 만듭니다.
이 버튼을 누르면 내비게이션을 이용해 페이지를 이동하도록 만듭니다. 페이지 이동 처리는 앞에서 배운 라우트 기능을 이용합니다. 여기서 사용한 pushReplacementNamed() 함수는 스택 메모리에 있는 자료를 교체합니다.
210
[글상자] lib/subDetail.dart
(...생략...)
class _SubDetail extends State<SubDetail> {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Sub Detail Example'),
),
body: Container(
child: Center(
child: RaisedButton(
onPressed: () {
Navigator.of(context).pushReplacementNamed('/second'); // 스택 메모리에 있는 자료를 교체하는 코드
},
child: Text('두 번째 페이지로 이동하기'),
),
),
),
);
}
}
[글상자 끝]
[3단계] secondDetail.dart 파일을 만들고 앞의 실습에서 만든 SecondPage 클래스와 똑같은 코드를 SecondDetail 클래스로 만듭니다. 앞의 실습과 마찬가지로 버튼을 눌렀을 때 pop() 함수를 호출해 첫 번째 페이지로 이동합니다.
[글상자] lib/secondDetail.dart
import 'package:flutter/material.dart';
class SecondDetail extends StatelessWidget {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Second Page'),
211
),
body: Container(
child: Center(
child: RaisedButton(
onPressed: () {
Navigator.of(context).pop();
},
child: Text('첫 번째 페이지로 돌아가기'),
),
),
),
);
}
}
[글상자 끝]
[4단계] main.dart 파일을 열고 전체 코드를 다음처럼 수정합니다. 앞에서 살펴본 코드이므로 자세한 설명은 생략합니다.
[글상자] lib/main.dart
import 'package:flutter/material.dart';
import 'subDetail.dart';
import 'secondDetail.dart';
void main() => runApp(MyApp());
class MyApp extends StatelessWidget {
static const String _title = 'Widget Example';
@override
Widget build(BuildContext context) {
return MaterialApp(
title: _title,
initialRoute: '/',
routes: {
'/': (context) => SubDetail(),
'/second': (context) => SecondDetail(),
212
},
);
}
}
[글상자 끝]
이제 앱을 실행하면 다음과 같은 화면이 출력됩니다. 첫 화면에서 <두 번째 페이지로 이동하기> 버튼을 눌러 다음 페이지로 이동 후 다시 <첫 번째 페이지로 돌아가기> 버튼을 눌러 보세요.
[그림] 실행 결과


Sub Detail Example, 두 번째 페이지로 이동하기
Second Page, 첫 번째 페이지로 돌아가기
[그림 끝]
그런데 예상과 달리 첫 페이지로 이동하지 않고 화면이 까맣게 변합니다. 이유는 지금 스택에 위젯이 하나도 없기 때문입니다.
[5단계] 앞서 _SubDetail 클래스에서 사용한 pushReplacementNamed() 함수는 스택에 자료를 추가하지 않고 기존 자료를 교체합니다. 이 내용을 좀 더 살펴보고자 thirdPage.dart 파일을 만든 후 ThirdPage 클래스를 다음처럼 작성합니다.
213
[글상자] lib/thirdPage.dart
import 'package:flutter/material.dart';
class ThirdDetail extends StatelessWidget {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Third Page'),
),
body: Container(
child: Center(
child: RaisedButton(
onPressed: () {
Navigator.of(context).pop();
},
child: Text('첫 번째 페이지로 돌아가기'),
),
),
),
);
}
}
[글상자 끝]
[6단계] 그리고 _SubDetail 클래스의 버튼 이벤트도 다음처럼 수정합니다. 기존에는 스택에서 자료를 교체하는 pushReplacementNamed() 함수를 호출했지만, 여기서는 새로운 자료를 추가하는 pushNamed() 함수로 바꿉니다.
[글상자] lib/subDetail.dart
(...생략...)
child: RaisedButton(
onPressed: () {
Navigator.of(context).pushNamed('/second');
},
child: Text('두 번째 페이지로 이동하기'),
),
(...생략...)
[글상자 끝]
214
[7단계] SecondDetail 클래스에서 버튼 이벤트도 다음처럼 수정합니다. 스택에서 현재 위치의 자료를 세 번째 페이지로 교체하는 코드입니다.
[글상자] lib/secondDetail.dart
(...생략...)
child: RaisedButton(
onPressed: () {
Navigator.of(context).pushReplacementNamed('/third');
},
child: Text('세 번째 페이지로 이동하기'),
),
(...생략...)
[글상자 끝]
[8단계] 이제 main.dart 파일에서 routes에 /third 경로를 선언하고 여기에 ThirdDetail 위젯을 추가합니다.
[글상자] lib/main.dart
import 'thirdPage.dart';
(...생략...)
routes: {
'/': (context) => SubDetail(),
'/second': (context) => SecondDetail(),
'/third' : (context) => ThirdDetail()
},
(...생략...)
[글상자 끝]
이제 앱을 실행해 보면 이전과 다르게 모든 버튼이 제대로 동작하는 모습을 볼 수 있습니다. 지금 만든 앱의 스택 구조를 그림으로 나타내면 다음과 같습니다.
215
[그림 8-3] pushReplacementNamed() 함수 호출 시 스택 구조의 변화


main: subDetail → main: SecondDetail, subDetail → main: ThirdDetail, subDetail
[그림 끝]
첫 번째 페이지에서 pushNamed() 함수를 호출하면 스택에 두 번째 페이지가 쌓입니다. 그리고 두 번째 페이지에서 pushReplacementNamed() 함수를 호출하면 스택에 쌓인 두 번째 페이지는 세 번째 페이지로 교체됩니다. 그 후 세 번째 페이지에서 pop() 함수를 호출하면 스택에 있는 세 번째 페이지가 제거됩니다.
이처럼 내비게이션을 이용해 스택에 위젯을 넣고, 교체하고, 빼는 함수를 활용하면 페이지의 이동 경로를 목적에 맞게 구현할 수 있습니다.
[Do it! 실습] 할 일 보기 기능 만들기
[1단계] 이제 To Do 목록을 만들면서 페이지에 데이터를 전달하는 방법을 알아보겠습니다. subDetail.dart 파일에서 _SubDetail 클래스에 List를 선언하고 기본 내용을 추가합니다.
[글상자] lib/subDetail.dart
(...생략...)
class _SubDetail extends State<SubDetail> {
List<String> todoList = new List();
@override
void initState() {
super.initState();
todoList.add('당근 사오기');
todoList.add('약 사오기');
todoList.add('청소하기');
todoList.add('부모님께 전화하기');
}
(...생략...)
[글상자 끝]
216
[2단계] 그리고 스캐폴드에서 ListView를 만들어 표시합니다.
[글상자] lib/subDetail.dart
(...생략...)
return Scaffold(
appBar: AppBar(
title: Text('Sub Detail Example'),
),
body: ListView.builder(
itemBuilder: (context, index) {
return Card(
child: InkWell(
child: Text(
todoList[index],
style: TextStyle(fontSize: 30),
),
onTap: () {
Navigator.of(context)
.pushNamed('/third', arguments: todoList[index]);
},
),
);
},
itemCount: todoList.length,
),
floatingActionButton: FloatingActionButton(
onPressed: () {},
child: Icon(Icons.add),
),
);
(...생략...)
[글상자 끝]
리스트뷰에 할 일을 보여주는 기능을 구현했습니다. 이때 처음 등장하는 InkWell 위젯을 사용했습니다. 이 위젯은 탭, 더블탭, 롱탭 등 다양한 터치 이벤트를 처리할 수 있습니다.
onTap 이벤트 처리 함수에 앞에서 배운 내비게이션 코드가 나옵니다. pushNamed() 함수로 페이지를 이동하면서 첫 번째 인자로 지정한 경로로 두 번째 인자(arguments)로 지정한 데이터를 전달하는 코드입니다.
217
이때 경로는 '/third'로 지정했으므로 세 번째 페이지로 이동하며 여기에 두 번째 인자로 전달한 todoList[index], 즉 사용자가 선택한 할 일(문자열)을 전달합니다.
[3단계] 이제 ThirdDetail 클래스에서 데이터를 받아서 처리하는 코드를 작성합니다.
[글상자] lib/thirdDetail.dart
import 'package:flutter/material.dart';
class ThirdDetail extends StatelessWidget {
@override
Widget build(BuildContext context) {
final String args = ModalRoute.of(context).settings.arguments;
return Scaffold(
appBar: AppBar(
title: Text('Third Page'),
),
body: Container(
child: Center(
child: Text(
args,
style: TextStyle(fontSize: 30),
),
),
(...생략...)

ModalRoute.of(context).settings.arguments; → 라우터로 전달받은 데이터 가져오기
[글상자 끝]
args 변수에 ModalRoute.of(context).settings.arguments 코드를 이용해 두 번째 페이지에서 보낸 arguments값을 입력하고 이 값을 텍스트 위젯에 출력합니다. 라우트를 이용해 전달한 데이터를 어떻게 가져오는지 눈여겨보길 바랍니다.
앱을 실행하고 할 일 목록이 보이면 그중 하나를 선택해 보세요. 그러면 선택한 할 일이 세 번째 페이지에 표시됩니다.
218
[그림] 실행 결과


부모님께 전화하기
→ 부모님께 전화하기
[그림 끝]
[Do it! 실습] 할 일 추가 기능 만들기
이제 할 일 목록에 데이터를 추가해 보겠습니다. 이 기능은 첫 번째 페이지에서 플로팅 버튼을 눌렀을 때 동작하도록 구현하겠습니다.
[1단계] 플로팅 버튼을 누르면 두 번째 페이지로 이동하고 여기서 반환하는 값을 저장해 할 일 목록에 추가하는 _addNavigation() 함수를 정의합니다. 이 함수는 데이터를 받은 다음에 처리해야 하므로 비동기 방식으로 구현합니다.
[글상자] lib/subDetail.dart
(...생략...)
class _SubDetail extends State<SubDetail> {
List<String> todoList = new List();
@override
void initState() { ...생략... }
@override
219
Widget build(BuildContext context) { ...생략... }
void _addNavigation(BuildContext context) async {
final result = await Navigator.of(context).pushNamed('/second');
setState(() {
todoList.add(result);
});
}
}
[글상자 끝]
pushNamed() 함수 호출문 앞에 await 키워드를 붙여서 이 함수가 끝날 때까지 기다립니다. 그리고 반환값을 result에 넣고 이 값을 todoList에 추가합니다.
[2단계] 이어서 floatingActionButton의 이벤트 처리 함수 onPressed에서 방금 만든 _addNavigation() 함수를 호출합니다.
[글상자] lib/subDetail.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar( ...생략... ),
body: ListView.builder( ...생략... ),
floatingActionButton: FloatingActionButton(
onPressed: () {
_addNavigation(context);
},
child: Icon(Icons.add),
),
);
}
(...생략...)
[글상자 끝]
220
[3단계] 이제 두 번째 페이지를 수정해 보겠습니다. SecondDetail 클래스에 할 일을 등록하는 텍스트필드와 버튼을 추가합니다. 텍스트필드에 할 일을 입력한 후 버튼을 누르면 데이터를 전달한 후 현재 화면을 종료합니다.
[글상자] lib/secondDetail.dart
import 'package:flutter/material.dart';
class SecondDetail extends StatelessWidget {
@override
Widget build(BuildContext context) {
TextEditingController controller = new TextEditingController();
return Scaffold(
appBar: AppBar(
title: Text('Second Page'),
),
body: Container(
child: Center(
child: Column(
children: <Widget>[
TextField(
controller: controller,
keyboardType: TextInputType.text,
),
child: RaisedButton(
onPressed: () {
Navigator.of(context).pop(controller.value.text);
},
child: Text('저장하기'),
),
],
),
)));
}
}
[글상자 끝]
221
앱을 실행한 후 플로팅 버튼을 누르면 할 일을 등록하는 화면으로 이동합니다. 여기서 할 일을 입력하고 <저장하기>를 누르면 첫 번째 화면으로 이동하고 목록에 방금 등록한 할 일이 추가됩니다.
[그림] 실행 결과


(+) → 저장하기 → Do it! 플러터 책 읽기
[그림 끝]
이번 장에서는 페이지를 이동하는 방법과 서로 데이터를 주고받는 방법을 알아봤습니다. 이를 활용하면 한 화면에 기능을 몰아넣지 않고 페이지를 분리해서 유기적으로 동작하는 앱을 만들 수 있습니다. 다만 용량이 큰 이미지나 동영상 데이터를 주고받을 때는 메모리를 많이 차지하므로 성능이 떨어질 수 있습니다. 이럴 때는 기기 내부에 파일로 저장하고 경로만 주고받는 방식을 이용하면 더 효율적으로 구현할 수 있습니다. 다음 장에서는 이러한 내용을 다뤄보겠습니다.
222
[아하!] 어디서나 호출할 수 있는 InheritedWidget 클래스
일반적으로 다른 클래스에 있는 데이터에 접근할 때 해당 클래스를 상속받아야 합니다. 그런데 클래스가 늘고 복잡해지면 상속 관계를 관리하면서 데이터를 이용하는 것이 쉽지 않습니다. 이럴 때 InheritedWidget 클래스를 사용할 수 있습니다. InheritedWidget 클래스는 어느 클래스에서나 접근할 수 있습니다. 예를 들어 데이터 통신을 할 때 필요한 암호나 사용자 정보 같은 데이터를 InheritedWidget 클래스를 이용해 저장해 놓으면 다른 위젯에서 쉽게 사용할 수 있습니다.
다음 그림처럼 InheritedWidget 클래스를 가장 먼저 호출한 후에 이어서 기존에 사용하려던 위젯을 호출하면 InheritedWidget 클래스에 선언된 변수를 모든 위젯에서 사용할 수 있습니다.
[그림 8-4] InheritedWidget 클래스의 변수를 여러 위젯에서 이용하는 구조


[전체 흐름]
1 → 2 → 4 → 6 → 7
1 → 2 → 3 → 4 → 5 → 6 → 7
1. InheritedWidget
2. Widget
3. Widget
4. Widget
5. Widget
6. Widget
7. Widget
[그림 끝]
이 책에서는 플러터의 기초를 다루고 있어서 다루지는 않지만 플러터를 좀 더 깊이 공부하게 된다면 Provider 패키지나 BLOC 패턴도 알게 됩니다. 이때 InheritedWidget 클래스는 코드를 구조화하는 데 도움이 됩니다.
InheritedWidget 클래스에 관한 좀 더 제사한 소개는 플러터 공식 웹 사이트를 확인하기 바랍니다.
? InheritedWidget 클래스 소개: https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html
[아하! 끝]
223
셋째마당 플러터 고급 기능 배우기
둘째마당까지 마쳤으면 이제 플러터의 기본적인 위젯은 익힌 것입니다. 셋째마당에서는 좀 더 고급 기능을 이용해서 완성도가 더 높은 앱을 만들어 보겠습니다. 먼저 즉 데이터를 내부 저장소나 데이터베이스에 저장하는 방법을 살펴봅니다. 그리고 애니메이션과 네이티브 API 연동 기능을 살펴봅니다. 마지막으로 구글의 클라우드 플랫폼인 파이어베이스와 앱에 광고를 넣어 수익화를 돕는 애드몹까지 살펴보겠습니다. 그럼 흥미진진한 내용이 가득한 이번 마당을 시작해 보겠습니다.
09 내부 저장소 이용하기
10 데이터베이스에 데이터 저장하기
11 애니메이션 활용하기
12 네이티브 API와 통신하기
13 파이어베이스와 광고 수입 얻기
224
09 내부 저장소 이용하기
앱을 개발하다 보면 앱에서 발생하는 데이터를 저장해야 할 때가 있습니다. 예를 들어 어떤 설정이나 알림 수신 여부, 그리고 북마크나 메모처럼 앱을 사용할 때 발생하는 다양한 데이터 등을 저장해 두면 앱 종료 후에 다시 실행해도 데이터가 사라지거나 초기화되지 않습니다. 이번 장에서는 이러한 데이터를 내부 저장소에 보관해 두었다가 다시 활용하는 방법을 살펴보겠습니다.
09-1 공유 환경설정에 데이터 저장하기
09-2 파일에 데이터 저장하기
225
09-1 공유 환경설정에 데이터 저장하기
플러터에서 앱의 데이터를 저장하는 방법은 크게 세 가지입니다. ① 공유 환경설정, ② 파일, ③ 데이터베이스를 이용하는 방법입니다. 이 중 공유 환경설정과 파일에 데이터를 저장하는 방법을 이번 장에서 살펴보고 데이터베이스를 이용하는 방법은 10장에서 살펴보겠습니다.
먼저 공유 환경설정은 비교적 적은 양의 간단한 데이터를 저장하는 용도로, SharedPreferences라는 클래스를 이용합니다. 이 클래스는 키-값 쌍으로 구성된 공유 환경설정 파일을 가리키며 이 파일에 데이터를 읽거나 쓰는 함수를 제공합니다. 그럼 SharedPreferences 클래스를 이용해 데이터를 저장하는 앱을 만들어 보겠습니다.
[Do it! 실습] 데모 앱의 카운트값 저장하기
새로운 플러터 프로젝트를 생성하면 기본으로 만들어지는 데모 앱에서 플로팅 버튼을 누르면 증가하는 카운트값을 공유 환경설정에 저장해 보겠습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] internal_example이라는 이름으로 새로운 플러터 프로젝트를 생성합니다. 기본으로 만들어지는 데모 앱은 오른쪽 아래에 + 모양의 플로팅 버튼이 있고 이 버튼을 누르면 화면의 카운트값이 증가합니다.
[그림] 실행 결과


Flutter Demo Home Page
You have pushed the button this many times: 8
[그림 끝]
226
그런데 카운트값이 증가한 상태에서 앱을 종료하고 다시 실행하면 숫자가 0으로 초기화됩니다. 데이터를 저장하지 않았기 때문입니다. 이 카운트값을 공유 환경설정에 저장해서 앱을 종료해도 숫자가 초기화되지 않도록 해보겠습니다.
[아하!] 앱을 종료하고 다시 실행하는 방법
앱을 강제로 종료하려면 스마트폰 아래쪽에 있는 내비게이션 버튼에서 ‘최근 앱(■)’을 누릅니다. 최근에 사용한 앱의 화면들이 나오면 종료하고 싶은 앱을 위로 쓸어올립니다. 그러면 앱이 강제로 종료됩니다. 그리고 앱을 다시 실행하려면 바탕화면을 위로 쓸어 올려 전체 앱 목록을 확인합니다. 그중에서 프로젝트 이름으로 된 앱을 선택하면 실행할 수 있습니다.
[그림 9-1] 앱 강제 종료와 실행하기


(1) ■ 버튼
(2) 화면 쓸어 올리기
(3) internal_...
[그림 끝]
[아하! 끝]
[2단계] 데이터를 공유 환경설정에 저장하는 SharedPreferences 클래스를 플러터에서 손쉽게 사용하려면 shared_preferences라는 패키지를 이용합니다. pubspec.yaml 파일에 shared_preferences 패키지[각주*]를 등록합니다. 그리고 플러터 명령 줄에서 <Pub get>을 클릭해 패키지를 내려받습니다.
[각주*] 집필 시점의 최신 버전은 0.5.12입니다.[각주 끝]
227
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
cupertino_icons: ^1.0.0
shared_preferences: 0.5.12
(...생략...)
[글상자 끝]
[3단계] main.dart 파일을 열고 앞에서 등록한 shared_preferences 패키지를 가져오는 코드를 추가합니다. 그리고 _MyHomePageState 클래스에 카운트값을 저장하는 함수 _setData()와 가져오는 함수 _loadData()를 만듭니다. 이 함수들은 언제 처리를 완료할지 예측할 수 없으므로 async를 이용해 비동기 함수로 만듭니다.
[글상자] lib/main.dart
import 'package:shared_preferences/shared_preferences.dart';
(...생략...)
class _MyHomePageState extends State<MyHomePage> {
int _counter = 0;
// 데이터를 저장하는 함수
void _setData(int value) async {
var key = 'count';
SharedPreferences pref = await SharedPreferences.getInstance();
pref.setInt(key, value);
}
// 데이터를 가져오는 함수
void _loadData() async {
var key = 'count';
SharedPreferences pref = await SharedPreferences.getInstance();
setState(() {
var value = pref.getInt(key);
if (value == null) {
_counter = 0;
228
} else {
_counter = value;
}
});
}
void _incrementCounter() { ...생략... }
@override
Widget build(BuildContext context) { ...생략... }
}
[글상자 끝]
앞에서 잠시 언급했지만 공유 환경설정에 저장하는 데이터는 키-값 쌍으로 구성되어야 합니다. 이때 키는 중복되지 않는 고유한 값이어야 합니다. 그래야 키에 대응하는 값을 읽을 수 있습니다. 공유 환경설정에 저장할 수 있는 값의 유형에는 int, String, bool, double, StringList 등이 있습니다.
앞의 코드를 보면 _setData() 함수에서 'count'라는 키값을 저장한 key 변수를 선언했습니다. 그리고 SharedPreferences 클래스의 인스턴스를 생성한 후 key와 카운트값 value를 인자로 setInt() 함수를 호출합니다. setInt() 함수는 SharedPreferences 클래스가 제공하는 세터[각주*] 함수입니다. 이로써 count라는 키에 대응하는 카운트값을 공유 환경설정에 저장합니다.
[각주*] 세터(setter)는 데이터를 저장하는 역할을 하는 함수를 의미합니다.[각주 끝]
공유 환경설정에 저장된 데이터를 가져오는 코드는 _loadData() 함수에 작성했습니다. SharedPreferences 클래스의 인스턴스를 생성한 후 이를 통해 getInt()라는 게터[각주*] 함수를 호출합니다. 이때 키값으로 데이터를 찾기 위해 key를 인자로 넣습니다. 이렇게 가져온 데이터가 null이 아니면 카운트값을 나타내는 _counter 변수에 넣습니다.
[각주*] 게터(getter)는 데이터를 불러오는 역할을 하는 함수를 의미합니다.[각주 끝]
[4단계] 앞에서 정의한 두 함수를 호출하는 코드를 작성합니다. 카운트값을 가져오는 _loadData() 함수는 앱이 처음 실행될 때 호출하도록 initState() 함수에 넣고, 카운트값을 저장하는 _setData() 함수는 버튼을 누를 때마다 호출되는 _incrementCounter() 함수에서 카운트값을 증가하는 _counter++ 코드 다음에 넣습니다. 그러면 사용자가 버튼을 눌러 카운트값이 증가할 때마다 공유 환경설정에 값을 저장합니다.
229
[글상자] lib/main.dart
(...생략...)
class _MyHomePageState extends State<MyHomePage> {
(...생략...)
@override
void initState() {
super.initState();
_loadData();
}
void _incrementCounter() {
setState(() {
_counter++;
_setData(_counter);
});
}
(...생략...)
[글상자 끝]
[그림] 실행 결과


Flutter Demo Home Page
You have pushed the button this many times: 7
[그림 끝]
이제 앱을 실행 후 버튼을 눌러 숫자를 증가시키고 앱을 종료했다가 다시 실행해 봅시다. 증가한 숫자가 그대로 보이는 것을 확인할 수 있습니다.
이처럼 간단한 데이터는 SharedPreferences를 이용해 몇 줄 안되는 코드로 손쉽게 저장할 수 있습니다. 다음 절에서는 좀 더 다양한 데이터를 저장하도록 파일을 이용한 입출력 방법을 살펴보겠습니다. 공유 환경설정을 이용하는 것도 결국 내부 저장소에 파일 형태로 데이터를 저장하는 것이지만, 공유 환경설정 파일은 앱에서만 접근할 수 있는 특수한 목적의 데이터 저장소라는 점에서 차이가 있습니다.
230
09-2 파일에 데이터 저장하기
이번 절에서는 파일에 데이터를 저장하고 불러오는 방법을 살펴보겠습니다. 파일을 이용하면 앞에서 살펴본 공유 환경설정보다 더 복잡하고 다양한 데이터를 다룰 수 있습니다. JPG나 비트맵 같은 이미지, MP3, MP4 같은 음성, 동영상, 그리고 긴 텍스트도 저장하고 불러올 수 있습니다.
[Do it! 실습] 파일 입출력 연습하기
[1단계] 먼저 fileio_example이라는 이름으로 새로운 플러터 프로젝트를 만듭니다. 이어서 pybspec.yaml 파일을 열고 파일 입출력을 돕는 path_provider[각주*]라는 패키지를 등록한 후 <Pub get>을 클릭해 패키지를 내려받습니다.
[각주*] 집필 시점의 최신 버전은 1.6.24입니다.[각주 끝]
[QR 코드] 소스 보기


[QR 코드 끝]
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
cupertino_icons: ^1.0.0
path_provider: ^1.6.24
(...생략...)
[글상자 끝]
[2단계] fileApp.dart라는 새로운 다트 파일을 만들고 StatefulWidget을 상속받는 FileApp 클래스를 작성합니다.
231
[글상자] lib/fileApp.dart
import 'package:flutter/material.dart';
class FileApp extends StatefulWidget {
@override
State<StatefulWidget> createState() => _FileApp();
}
class _FileApp extends State<FileApp> {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('File Example'),
),
body: Container(),
);
}
}
[글상자 끝]
[3단계] _FileApp 클래스에서 파일을 읽고 쓸 수 있는 함수를 만들어 보겠습니다. 이때 1단계에서 내려받은 패키지를 이용할 것이므로 import 구문으로 이를 추가합니다.
[글상자] lib/fileApp.dart
import 'package:flutter/material.dart';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
class FileApp extends StatefulWidget { ...생략... }
class _FileApp extends State<FileApp> {
int _count = 0;
@override
void initState() {
super.initState();
232
readCountFile();
}
@override
Widget build(BuildContext context) { ...생략... }
void writeCountFile(int count) async {
var dir = await getApplicationDocumentsDirectory();
File(dir.path + '/count.txt').writeAsStringSync(count.toString());
}
void readCountFile() async {
try {
var dir = await getApplicationDocumentsDirectory();
var file = await File(dir.path + '/count.txt').readAsString();
print(file);
setState(() {
_count = int.parse(file);
});
} catch (e) {
print(e.toString());
}
}
}
[글상자 끝]
파일 입출력 또한 환경에 따라 작업이 언제 끝날지 예측할 수 없으므로 async를 이용해 비동기 함수로 만듭니다. 그리고 path_provider 패키지에 들어 있는 getApplicationDocumentsDirectory() 함수를 이용해 내부 저장소의 경로를 가져와서 그곳에 파일을 읽거나 씁니다.
writeCountFile() 함수는 매개변수로 전달받은 count값을 count.txt라는 이름의 파일로 만들어 문자열 형태로 저장하고, readCountFile() 함수는 이 파일을 읽어 다시 정수형으로 변환한 후 _count 변수에 저장합니다. 그리고 앱이 실행될 때 파일에서 가져온 데이터를 표시하기 위해 initState() 함수에서 readCountFile() 함수를 호출합니다.
233
[아하!] 임시 디렉터리를 이용하는 방법
내부 저장소의 경로를 가져올 때 getApplicationDocumentsDirectory() 함수 외에 getTemporaryDirectory() 함수를 이용할 수도 있습니다. 이 함수는 임시 디렉터리 경로를 가져옵니다. 다만, 임시 디렉터리는 캐시(cache)를 이용하므로 앱이 종료되고 일정시간이 지나면 사라질 수 있습니다.
[아하! 끝]
[4단계] build() 함수는 다음처럼 작성해 화면을 설계합니다.
[글상자] lib/fileApp.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('File Example'),
),
body: Container(
child: Center(
child: Text(
'$_count',
style: TextStyle(fontSize: 40),
),
),
),
floatingActionButton: FloatingActionButton(
onPressed: () {
setState(() {
_count++;
});
writeCountFile(_count);
},
child: Icon(Icons.add),
),
);
}
(...생략...)
[글상자 끝]
234
텍스트 위젯에 카운트값을 넣고 플로팅 버튼을 누를 때마다 값을 증가합니다. 그리고 증가한 카운트값을 파일에 저장하도록 writeCountFile() 함수를 호출합니다.
[5단계] 마지막으로 main.dart 파일을 열고 방금 작성한 fileApp.dart 파일을 추가합니다. 그리고 MyApp 클래스에 home값을 FileApp 클래스로 수정하고 MyApp 클래스 아래에 나머지 코드는 지웁니다.
[글상자] lib/main.dart
import 'package:flutter/material.dart';
import 'fileApp.dart';
void main() {
runApp(MyApp());
}
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(
primarySwatch: Colors.blue,
visualDensity: VisualDensity.adaptivePlatformDensity,
),
home: FileApp(),
);
}
} // 이하 코드는 불필요하므로 모두 지우기
[글상자 끝]
[그림] 실행 결과


File Example
[그림 끝]
이제 앱을 실행하고 플로팅 버튼을 눌러 카운트값을 증가합니다. 그리고 앱을 종료하고 다시 실행하면 카운트값이 초기화되지 않고 누적되는 것을 확인할 수 있습니다.
235
[Do it! 실습] 좋아하는 과일 표시하기 - 파일 읽기
지금까지 앱에서 직접 입력한 데이터를 파일로 만들어서 내부 저장소에 저장하고 이를 읽는 법을 배웠습니다. 이처럼 앱에서 파일을 직접 만들 수도 있지만 데이터의 양이 많고 또 자주 갱신하지 않아도 되는 데이터라면 앱 안에 미리 파일로 만들어 놓고 이를 사용할 수도 있습니다. 이번 실습에서는 프로젝트 폴더에 있는 텍스트 파일을 읽어서 앱 화면에 표시해 보겠습니다.
[1단계] 앞의 실습에서 만든 fileio_example 프로젝트에 이어서 진행해 보겠습니다. 프로젝트 아래 repo라는 이름으로 새 폴더를 만들고 그 아래 fruit.txt라는 이름으로 텍스트 파일을 만듭니다. 그리고 해당 파일을 열어 좋아하는 과일 이름을 한 줄에 하나씩 적습니다.
[그림 9-2] repo/fruit.txt 파일 만들기


repo - fruit.txt - 사과, 바나나, 포도, 배
[그림 끝]
[2단계] pubspec.yaml 파일을 열고 「09-1」절에서 다룬 공유 환경설정을 사용하기 위해 dependencies: 항목에 shared_preferences 패키지를 추가합니다. 그리고 flutter: 항목에 방금 만든 fruit.txt 파일을 애셋으로 등록합니다.
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
cupertino_icons: ^1.0.0
path_provider: ^1.6.24
shared_preferences: 0.5.12
236
(...생략...)
flutter:
uses-material-design: true
assets:
- repo/fruit.txt
[글상자 끝]
[3단계] fileApp.dart 파일을 열고 _FileApp 클래스에서 readListFile() 함수를 생성합니다. 이 함수는 fruit.txt 파일에서 데이터를 읽어와 내부 저장소인 공유 환경설정에 저장한 다음 리스트를 만듭니다.
[글상자] lib/fileApp.dart
import 'package:flutter/material.dart';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
class FileApp extends StatefulWidget { ...생략... }
class _FileApp extends State<FileApp> {
int _count = 0;
Future<List<String>> readListFile() async {
List<String> itemList = new List();
var key = 'first';
SharedPreferences pref = await SharedPreferences.getInstance();
bool firstCheck = pref.getBool(key);
var dir = await getApplicationDocumentsDirectory();
bool fileExist = await File(dir.path + '/fruit.txt').exists();
if (firstCheck == null || firstCheck == false || fileExist == false) {
pref.setBool(key, true);
var file =
await DefaultAssetBundle.of(context).loadString('repo/fruit.txt');
File(dir.path + '/fruit.txt').writeAsStringSync(file);
237
var array = file.split('\n');
for (var item in array) {
print(item);
itemList.add(item);
}
return itemList;
} else {
var file = await File(dir.path + '/fruit.txt').readAsString();
var array = file.split('\n');
for (var item in array) {
print(item);
itemList.add(item);
}
return itemList;
}
}
(...생략...)
[글상자 끝]
readListFile() 함수를 처음 실행하면 애셋에 등록한 파일을 읽어서 내부 저장소에 다시 저장합니다. 그리고 다음 실행부터는 내부 저장소에 있는 파일을 대상으로 데이터를 불러와 리스트를 만듭니다. readListFile() 함수의 핵심 부분을 좀 더 자세하게 살펴보겠습니다.
다음 코드는 「09-1」절에서 다룬 공유 환경설정에서 'first'라는 키를 이용해 bool값을 가져와 firstCheck 변수에 저장합니다. firstCheck 변수는 이후에 파일을 처음 열었는지 확인하는 용도로 사용합니다.
[글상자]
var key = 'first';
SharedPreferences pref = await SharedPreferences.getInstance();
bool firstCheck = pref.getBool(key);
[글상자 끝]
다음 코드는 지정한 경로에 파일이 있는지를 확인합니다. File().exists() 함수로 내부 저장소에 fruit.txt 파일이 있는지를 확인한 후 fileExist 변수에 bool값으로 저장합니다. fileExist 변수는 이후에 파일이 있는지를 확인하는 용도로 사용합니다.
[글상자]
bool fileExist = await File(dir.path + '/fruit.txt').exists();
[글상자 끝]
238
firstCheck, fileExist 변수는 파일이 있는지, 처음 열었는지 등을 확인해 로직을 둘로 나누어 처리하고자 만들었습니다. 만약 파일을 처음 열었거나 없으면 공유 환경설정에 true값을 저장해 파일을 연 것으로 기록하고 애셋에 등록한 repo/fruit.txt 파일을 읽어서 내부 저장소에 똑같은 파일을 만듭니다. 그리고 해당 파일의 데이터를 줄바꿈 문자('\n')를 기준으로 나누어(sprit) 배열 형태로 만든 다음, 각 아이템을 리스트에 넣어서 반환합니다.
[글상자]
if (firstCheck == null || firstCheck == false || fileExist == false) {
pref.setBool(key, true);
var file =
await DefaultAssetBundle.of(context).loadString('repo/fruit.txt');
File(dir.path + '/fruit.txt').writeAsStringSync(file);
var array = file.split('\n');
for (var item in array) {
print(item);
itemList.add(item);
}
return itemList;
[글상자 끝]
만약 파일을 처음 연 것이 아니라면 위와 같이 파일의 데이터를 리스트로 만들어서 반환하되 대상 파일을 내부 저장소의 fruit.txt 파일로 지정합니다.
[글상자]
} else {
var file = await File(dir.path + '/fruit.txt').readAsString();
var array = file.split('\n');
for (var item in array) {
print(item);
itemList.add(item);
}
return itemList;
}
[글상자 끝]
종합해 보면 readListFile() 함수는 데이터를 리스트로 만들어 반환하는데, 처음 호출되었을 때는 애셋에 등록한 파일을 읽어 내부 저장소에 똑같은 파일을 만들어서 동작하고 이후부터는 내부 저장소에 저장된 파일을 읽어서 동작합니다.
239
[4단계] 앱을 실행할 때 방금 만든 readListFile() 함수를 실행하도록 다음 코드를 추가합니다.
[글상자] lib/fileApp.dart
(...생략...)
class _FileApp extends State<FileApp> {
int _count = 0;
List<String> itemList = new List();
TextEditingController controller = new TextEditingController();
@override
void initState() {
super.initState();
readCountFile();
initData();
}
void initData() async {
var result = await readListFile();
setState(() {
itemList.addAll(result);
});
}
Future<List<String>> readListFile() async {
(...생략...)
[글상자 끝]
이때 initState() 함수에는 async 키워드를 사용할 수 없으므로 별도의 initData() 함수를 만듭니다. 그리고 그 안에 readListFile() 함수를 호출하고 setState() 함수를 이용해 리스트를 만듭니다. 이것으로 데이터 준비 작업은 끝납니다.
[5단계] 이제 화면을 어떻게 표시할지를 작성합니다. build() 함수를 다음 코드로 대체합니다.
240
[글상자] lib/fileApp.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('File Example'),
),
body: Container(
child: Center(
child: Column(
children: <Widget>[
TextField(
controller: controller,
keyboardType: TextInputType.text,
),
ListView.builder(
itemBuilder: (context, index) {
return Card(
child: Center(
child: Text(
itemList[index],
style: TextStyle(fontSize: 30),
),
),
);
},
itemCount: itemList.length,
)
],
),
),
),
floatingActionButton: FloatingActionButton(
onPressed: () {},
child: Icon(Icons.add),
),
);
}
(...생략...)
[글상자 끝]
241
이 코드는 앞에서 준비한 리스트 데이터를 ListView.builder를 이용해 화면에 표시합니다. 아울러 다음 실습에서 텍스트필드에 입력받은 데이터를 리스트에 추가하는 기능을 만들려고 위젯을 미리 만들어 두었습니다. 이제 빌드 후 앱을 실행해 보세요.
[그림] 실행 결과


Vertical viewport was given unbounded height.
[그림 끝]
빌드에 성공해 앱은 실행되지만 원하는 화면이 나오지 않고 실행 창에 렌더링 오류가 발생합니다. Column이나 Row 위젯은 내용에 따라 알아서 크기를 조절해서 배치하지만, ListView는 길이를 가늠할 수 없기 때문입니다.
[6단계] 이럴 때는 Expended 위젯을 이용하면 됩니다. Expended 위젯은 남은 공간을 모두 사용합니다. 즉, 텍스트필드 이외에 나머지 부분은 모두 ListView로 사용하겠다는 의미입니다.
[글상자] lib/fileApp.dart
(...생략...)
children: <Widget>[
TextField(
controller: controller,
keyboardType: TextInputType.text,
),
Expanded(
child: ListView.builder(
itemBuilder: (context, index) {
return Card(
child: Center(
child: Text(
itemList[index],
style: TextStyle(fontSize: 30),
),),);
},
242
itemCount: itemList.length,
),)],
(...생략...)
[글상자 끝]
[그림] 실행 결과


File Example: 사과, 바나나, 포도, 배
[그림 끝]
[Do it! 실습] 좋아하는 과일 추가하기 - 파일 쓰기
이제 텍스트필드에 좋아하는 과일 이름을 넣고 플로팅 버튼을 누르면 리스트에 해당 과일을 추가하는 기능을 만들어 보겠습니다.
[1단계] 사용자가 등록한 과일 이름을 내부 저장소에 있는 fruit.txt 파일에 추가하는 writeFruit() 함수를 _FirstApp 클래스에 작성합니다.
[글상자] lib/firstApp.dart
(...생략...)
void writeFruit(String fruit) async {
var dir = await getApplicationDocumentsDirectory();
var file = await File(dir.path + '/fruit.txt').readAsString();
file = file + '\n' + fruit;
File(dir.path + '/fruit.txt').writeAsStringSync(file);
}
(...생략...)
[글상자 끝]
243
writeFruit() 함수는 현재 fruit.txt 파일의 내용을 가져와서 매개변수로 전달받은 과일 이름 fruit를 추가한 후 다시 파일에 기록합니다. 과일 이름을 추가할 때는 반드시 '\n'으로 구분자를 넣습니다.
[2단계] writeFruit() 함수를 플로팅 버튼의 onPressed 이벤트 처리 함수에서 호출합니다. 이때 사용자가 입력한 값이 들어 있는 controller.value.text를 넘깁니다. 그리고 이 값을 리스트에 추가합니다.
[글상자] lib/firstApp.dart
(...생략...)
floatingActionButton: FloatingActionButton(
onPressed: () {
writeFruit(controller.value.text);
setState(() {
itemList.add(controller.value.text);
});
},
child: Icon(Icons.add),
),
(...생략...)
[글상자 끝]
[그림] 실행 결과


File Example: 사과, 바나나, 포도, 배, 딸기
[그림 끝]
이제 앱을 실행하고 텍스트필드에 좋아하는 과일을 입력하고 플로팅 버튼을 눌러보세요. 이후 앱을 종료했다 다시 실행해도 추가한 과일이 그대로 표시되는 것을 확인할 수 있습니다.
244
[Do it! 실습] 내려받은 이미지를 로고로 사용하기
대부분 앱은 실행 후 처음에 앱의 로고가 표시되는 인트로 화면이 나옵니다. 특별한 날이나 이벤트 등으로 인트로 화면을 수시로 변경하기도 하죠. 그런데 인트로 화면을 바꾸고 싶을 때마다 매번 앱을 업데이트하면 비효율적이겠죠? 이럴 때는 서버에서 이미지를 내려받는 식으로 처리하면 앱을 업데이트 하지 않아도 됩니다. 이번 실습에서는 서버에서 이미지를 내려받아 인트로 화면을 변경하는 방법을 알아보겠습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] 07장에서 배운 데이터 통신을 활용해 서버에서 내려받은 이미지 파일을 저장해 보겠습니다. 먼저 intro_example이라는 이름으로 새 프로젝트를 만들고 07장에서 만든 largeFileMain.dart 파일을 복사해 lib 폴더 안에 붙여 넣습니다. 그리고 pubspec.yaml 파일에 다음처럼 패키지를 추가하고 <Pub get>을 눌러 설치합니다.
[글상자] pubspec.yaml
(....생략...)
dependencies:
flutter:
sdk: flutter
cupertino_icons: ^1.0.0
path_provider: ^1.6.24
dio: ^3.0.10
(...생략...)
[글상자 끝]
[2단계] 이미지 파일을 내려받는 화면으로 갈 수 있는 ‘로고 바꾸기’ 버튼을 만듭니다. main.dart 파일을 열고 _MyHomePageState 클래스의 build() 함수 내용을 다음처럼 수정합니다.
[글상자] lib/main.dart
import 'largeFileMain.dart';
(...생략...)
class _MyHomePageState extends State<MyHomePage> {
(...생략...)
@override
245
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('로고바꾸기'),
actions: <Widget>[
FlatButton(
onPressed: () {
Navigator.of(context)
.push(MaterialPageRoute(builder: (context) => LargeFileMain()));
},
child: Text(
'로고 바꾸기',
style: TextStyle(color: Colors.white),
),)],),
body: Container(),
);
}
}

LargeFileMain() → 07장에서 만든 클래스 활용
[글상자 끝]
[그림] 실행 결과


로고바꾸기, https://images.pexels.com/photos/240040..., Downloading File: 3%
[그림 끝]
앱을 실행하고 내비게이션 바에 있는 <로고 바꾸기> 버튼을 누르면 07장에서 만들었던 이미지 내려받기 화면이 나옵니다. 텍스트 필드에 이미지가 있는 URL을 입력하고 내려받기 버튼을 누르면 해당 이미지를 내려받아서 출력합니다.
246
[3단계] 이미지를 내려받으면 자동으로 내부 저장소에 이미지 파일로 저장됩니다. 이 이미지 파일을 이용해 인트로 화면을 만들어 보기 위해 lib 폴더에 introPage.dart라는 이름으로 새로운 다트 파일을 만들고 다음과 같은 코드를 작성합니다.
[글상자] lib/introPage.dart
import 'dart:io';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'main.dart';
class IntroPage extends StatefulWidget {
@override
State<StatefulWidget> createState() => _IntroPage();
}
class _IntroPage extends State<IntroPage> {
Widget logo = Icon(
Icons.info,
size: 50,
);
@override
void initState() {
super.initState();
initData();
}
@override
Widget build(BuildContext context) {
return Scaffold(
body: Container(
child: Center(
child: Column(
children: [
logo,
RaisedButton(
onPressed: () {
247
Navigator.of(context)
.pushReplacement(MaterialPageRoute(builder: (context) {
return MyHomePage();
}));
},
child: Text('다음으로 가기'),
)
],
mainAxisAlignment: MainAxisAlignment.center,
),),),);
}
void initData() async {
var dir = await getApplicationDocumentsDirectory();
bool fileExist = await File(dir.path + '/myimage.jpg').exists();
if (fileExist) {
setState(() {
logo = Image.file(
File(dir.path + '/myimage.jpg'),
height: 200,
width: 200,
fit: BoxFit.contain,
);
});
}
}
}
[글상자 끝]
처음에 initState() 함수에서 initData() 함수를 호출해서 파일이 있는지 확인하고 있으면 logo 위젯에 이미지를 넣습니다.
[4단계] 앱이 처음 시작될 때 introPage.dart 파일을 실행해야 하므로 main.dart 파일을 열어서 MyApp 클래스의 build() 함수를 다음처럼 변경합니다.
248
[글상자] lib/main.dart
import 'introPage.dart';
(...생략...)
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
(...생략...)
),
home: IntroPage(),
);
}
}
(...생략...)
[글상자 끝]
[그림] 실행 결과


다음으로 가기
[그림 끝]
이제 빌드 후 앱을 실행하면 이전에 내려받은 이미지가 표시된 인트로 화면을 볼 수 있습니다.
이상으로 공유 환경설정과 파일 입출력을 이용해 데이터를 저장하고 불러오는 방법을 살펴봤습니다. 다음 장에서는 데이터베이스를 사용해 데이터를 저장하고 출력하는 방법을 알아보겠습니다.
249
10 데이터베이스에 데이터 저장하기
데이터베이스는 공용 데이터를 운영할 수 있는 통합 관리 시스템으로, 데이터베이스를 이용하면 파일보다 빠르고 안전하게 데이터를 다룰 수 있습니다. 이러한 데이터베이스에서 데이터를 다루는 기본은 생성(create), 읽기(read), 갱신(update), 삭제(delete)입니다. 이를 영문의 머리글자를 따서 CRUD라고 합니다. 이번 장에서는 SQLite라는 데이터베이스 관리 시스템을 이용해 CRUD를 실행하는 플러터 앱을 만들어 보겠습니다.
10-1 데이터베이스 만들기
10-2 데이터베이스에서 데이터 처리하기
10-3 질의문으로 추가 기능 만들기
250
10-1 데이터베이스 만들기
데이터베이스 관리 시스템에는 여러 가지 종류가 있지만 모바일에서는 가볍고 빠른 SQLite를 주로 사용합니다. 이에 플러터는 SQLite를 사용하는 sqflite라는 패키지를 제공합니다. 이번 절에서는 08장에서 만들어 본 할 일 기록하기 앱을 데이터베이스를 이용해 다시 만들어 보겠습니다.
[Do it! 실습] SQLite 사용하기
[1단계] sql_example이라는 이름으로 새로운 플러터 프로젝트를 생성합니다. 그리고 pubspec.yaml 파일을 열어 SQLite 사용을 위한 sqflite와 내부 저장소 사용을 위한 path 패키지를 추가합니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
sqflite: ^1.3.0 # SQLite 관련 패키지
path: ^1.7.0 # 내부 저장소 관련 패키지
(...생략...)
[2단계] 이제 데이터베이스 구조를 만들어야 합니다. lib 폴더에 todo.dart 파일을 만들고 다음처럼 작성합니다.
.lib/todo.dart
class Todo {
String title;
String content;
bool active;
int id;
251
Todo({this.title, this.content, this.active, this.id});
Map<String, dynamic> toMap() {
return {
'id': id,
'title': title,
'content': content,
'active': active,
};
}
}
[글상자 끝]
이 앱에서는 할 일 데이터를 저장할 것이므로 데이터베이스에 넣을 데이터는 id, title, content, active로 구성했습니다. 각각은 순번, 제목, 내용, 완료 여부를 나타냅니다. 코드에서 toMap() 함수는 데이터를 Map 형태로 반환해 줍니다. 플러터의 sqflite 패키지는 데이터를 Map 형태로 다룹니다. 따라서 데이터 구조를 Map 형태로 만들어 주는 toMap() 함수를 정의해 활용합니다.
[3단계] 이제 main.dart 파일을 열고 코드를 다음처럼 수정합니다. 그리고 StatefulWidget을 상속받는 DatabaseApp 클래스를 작성합니다.
[글상자] lib/main.dart
import 'package:flutter/material.dart';
void main() {
runApp(MyApp());
}
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp( ...생략... ),
home: DatabaseApp(),
);
}
252
}
class DatabaseApp extends StatefulWidget {
@override
State<StatefulWidget> createState() => _DatabaseApp();
}
class _DatabaseApp extends State<DatabaseApp> {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(title: Text('Database Example'),),
body: Container(),
floatingActionButton: FloatingActionButton(
onPressed: () async {
final todo = await Navigator.of(context).pushNamed('/add');
},
child: Icon(Icons.add),),
floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
);
}
}
[글상자 끝]
DatabaseApp 클래스에는 데이터베이스에서 가져온 할 일 목록을 화면에 보여주는 UI를 구현해 보겠습니다. 그리고 앱이 시작할 때 MyApp 클래스에서 데이터베이스를 만들어서 DatabaseApp 클래스에 전달하겠습니다. 앱을 시작할 때 데이터베이스를 생성하는 이유는 추후에 다른 페이지에서도 동일하게 사용할 수 있게 하려는 의도입니다. 이러한 구조를 그림으로 보면 다음과 같습니다.
[그림 10-1] TodoList 앱 구조


MyApp: DatabaseApp, AddTodoApp
[그림 끝]
253
가장 먼저 생성되는 MyApp 클래스에 데이터베이스를 선언해 다른 클래스에서도 접근할 수 있도록 합니다. 그리고 DatabaseApp이라는 클래스를 만들어 데이터베이스의 데이터를 보여주는 메인 화면과 데이터를 조작하는 기능들을 구현하겠습니다. 데이터베이스에 데이터를 추가하는 기능은 AddTodoApp이라는 클래스에 구현하겠습니다.
[4단계] MyApp 클래스에 데이터베이스를 생성하는 initDatabase() 함수를 만듭니다. 데이터베이스 함수를 사용하는 데 필요한 패키지를 포함하는 import 구문도 넣습니다.
[글상자] lib/main.dart
import 'package:flutter/material.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
void main() {
runApp(MyApp());
}
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) { ...생략... }
Future<Database> initDatabase() async {
return openDatabase(
join(await getDatabasesPath(), 'todo_database.db'),
onCreate: (db, version) {
return db.execute(
"CREATE TABLE todos(id INTEGER PRIMARY KEY AUTOINCREMENT, "
"title TEXT, content TEXT, active BOOL)",
);
},
version: 1,
);
}
}
[글상자 끝]
254
initDatabase() 함수는 데이터베이스를 열어서 반환해 줍니다. 이때 데이터베이스는 getDatabasePath() 함수가 반환하는 경로에 todo_database.db라는 파일로 저장되어 있으며 이 파일을 불러와서 반환합니다.
만약 todo_database.db 파일에 테이블[각주*]이 없으면 onCreate를 이용해 새로운 데이터베이스 테이블을 만듭니다. 테이블 구조는 다음과 같습니다.
[각주*] 관련 있는 자료의 묶음입니다. 데이터베이스는 테이블 단위로 자료를 관리합니다.[각주 끝]
[표 10-1] todos 테이블 구조
칼럼명

형식

비고

id

INTEGER (기본 키, 자동 증가)

순번, 기본 키, 자동 증가

title

TEXT

제목

content

TEXT

내용

active

BOOL

완료 여부

[5단계] 이제 build() 함수에서 방금 만든 initDatabase() 함수를 호출하도록 코드를 추가합니다. 이 코드를 추가하면 몇 곳에서 오류가 발생하지만 이후에 코드를 추가할 것이므로 지금은 무시합니다.
[글상자] lib/main.dart
(...생략...)
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
Future<Database> database = initDatabase();
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(
primarySwatch: Colors.blue,
visualDensity: VisualDensity.adaptivePlatformDensity,
),
initialRoute: '/',
routes: {
'/': (context) => DatabaseApp(database),
'/add': (context) => AddTodoApp(database)
255
},
〔home: DatabaseApp(),〕
);
}
(...생략...)
[글상자 끝]
「08-2」절에서 할 일 앱을 만들면서 경로를 이용해 화면을 이동하는 라우트 기능을 알아보았습니다. 라우트를 이용하면 routes로 한 곳에서 모든 경로를 관리하므로 편리하게 화면 이동을 구현할 수 있습니다. 여기서는 /와 /add 두 경로를 등록했으며 각 경로를 요청할 때 실행할 클래스를 지정했습니다.
이때 각 클래스를 호출하면서 database 객체를 전달하도록 합니다. 이렇게 하면 한 곳에서 데이터베이스를 호출하고 페이지별로 한 번 호출된 데이터베이스를 사용할 수 있습니다. 참고로 AddTodoApp 클래스는 이후 7단계에서 만들므로 아직은 오류가 표시됩니다.
[6단계] 앞에서 DatabaseApp 클래스를 호출할 때 database 객체를 전달했으므로 DatabaseApp 클래스도 다음처럼 수정합니다.
[글상자]
(...생략...)
class DatabaseApp extends StatefulWidget {
final Future<Database> db;
DatabaseApp(this.db);
@override
State<StatefulWidget> createState() => _DatabaseApp();
}
(...생략...)
[글상자 끝]
[7단계] AddTodoApp 클래스도 작성해 보겠습니다. 이 클래스에서는 할 일 목록에 데이터를 입력하는 화면을 만들겠습니다. addTodo.dart 파일을 새로 만들고 파일 안에 StatefulWidget을 상속받는 AddTodoApp 클래스를 작성합니다. 이때 AddTodoApp 클래스에서도 데이터베이스를 사용할 수 있도록 db를 만들어 줍니다.
256
[글상자] lib/addTodo.dart
import 'package:flutter/material.dart';
import 'package:sqflite/sqlite_api.dart';
import 'todo.dart';
class AddTodoApp extends StatefulWidget {
final Future<Database> db;
AddTodoApp(this.db);
@override
State<StatefulWidget> createState() => _AddTodoApp();
}
class _AddTodoApp extends State<AddTodoApp> {
@override
void initState() {
super.initState();
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Todo 추가'),
),
body: Container(
child: Center(
child: Column(
children: <Widget>[],
),),),
);
}
}
[글상자 끝]
이제 데이터베이스를 사용할 준비를 마쳤습니다. 다음 절에서는 데이터베이스를 이용해 CRUD를 구현해 보겠습니다.
257
10-2 데이터베이스에서 데이터 처리하기
앞서 이야기한 대로 데이터베이스에서 데이터를 다루는 기본은 생성(create), 읽기(read), 갱신(update), 삭제(delete)입니다. 이를 영문의 머리글자를 따서 CRUD라고 하며 각각은 입력, 검색, 수정, 삭제에 대응합니다. 여기서는 앞 절에서 만든 데이터베이스에 할 일을 입력, 검색, 수정, 삭제하는 기능을 구현해 보겠습니다.
[Do it! 실습] 데이터 입력하기
메인 화면에서 플로팅 버튼을 클릭하면 데이터를 입력하는 화면으로 이동하고 여기서 데이터를 입력 후 <저장하기>를 누르면 데이터베이스에 저장하는 기능을 만들어 보겠습니다.
[1단계] 먼저 데이터를 입력하려면 텍스트필드가 필요하므로 입력할 수 있는 위젯을 Column에 만들어 줍니다. 텍스트필드를 이용하려면 TextEditingController를 사용합니다. add Todo.dart 파일을 열고 _AddTodoApp 클래스에 두 개의 TextEditingController를 선언한 후에 build() 함수를 다음처럼 작성합니다.
[글상자] lib/addTodo.dart
(...생략...)
class _AddTodoApp extends State<AddTodoApp> {
TextEditingController titleController;
TextEditingController contentController;
@override
void initState() {
super.initState();
titleController = new TextEditingController();
contentController = new TextEditingController();
}
@override
Widget build(BuildContext context) {
258
return Scaffold(
appBar: AppBar(
title: Text('Todo 추가'),
),
body: Container(
child: Center(
child: Column(
children: <Widget>[
Padding(
padding: EdgeInsets.all(10),
child: TextField(
controller: titleController,
decoration: InputDecoration(labelText: '제목'),
),
),
Padding(
padding: EdgeInsets.all(10),
child: TextField(
controller: contentController,
decoration: InputDecoration(labelText: '할일'),
),
),
RaisedButton(
onPressed: () {
Todo todo = Todo(
title: titleController.value.text,
content: contentController.value.text,
active: false);
Navigator.of(context).pop(todo);
},
child: Text('저장하기'),
)
],
),),),
);
}
}
[글상자 끝]
259
두 개의 텍스트필드에는 각각 제목과 내용을 입력하고 버튼은 데이터를 저장하는 기능입니다. 버튼을 눌렀을 때 pop() 함수를 호출하면서 데이터를 메인에 전달합니다.
[2단계] 이렇게 전달한 데이터를 데이터베이스에 입력해 봅시다. main.dart 파일을 열고 _DatabaseApp 클래스에 다음과 같은 _insertTodo() 함수를 만듭니다. 그리고 앞에서 만든 todo.dart, addTodo.dart 파일 등도 import 구문으로 추가합니다[각주*].
[각주*] import 구문은 안드로이드 스튜디오가 자동으로 삽입해 주기도 합니다. 이 책의 실습을 진행하다가 혹시 의도하지 않은 오류가 발생하면 필자가 제공한 전체 소스와 import 구문부터 비교해 보기 바랍니다.[각주 끝]
[글상자] lib/main.dart
import 'todo.dart';
import 'addTodo.dart';
(...생략...)
class _DatabaseApp extends State<DatabaseApp> {
@override
Widget build(BuildContext context) { ...생략... }
void _insertTodo(Todo todo) async {
final Database database = await widget.db;
await database.insert('todos', todo.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace);
}
}
[글상자 끝]
_insertTodo() 함수는 widget.db[각주*]를 이용해 database 객체를 선언하고 insert() 함수를 이용해 매개변수로 전달받은 데이터를 입력합니다. insert() 함수의 첫 번째 인자로 전달한 todos는 「10-1」절에서 테이블을 생성할 때 명시한 테이블 이름입니다. 그리고 두 번째 인자로 전달한 todo.toMap() 함수는 Todo 클래스를 Map 형태로 바꿔 줍니다.
[각주*] widget을 이용하면 현재 State 상위에 있는 StatefulWidget에 있는 db 변수를 사용할 수 있습니다.[각주 끝]
세 번째 인자로 전달한 conflictAlgorithm은 충돌이 발생할 때를 대비한 것입니다. 예를 들어 「10-1」절에서 todos 테이블의 칼럼 중 id값은 자동으로 증가하는(AUTOINCREMENT) 기본 키(PRIMARY KEY)로 선언했습니다. 그런데 만약 새로 입력하려는 데이터의 id값이 이미 저장되어
260
있으면 충돌이 발생합니다. 이처럼 테이블에 데이터를 입력하는 과정에서 충돌이 발생하면 새 데이터로 교체하고자 replace로 선언했습니다.
[3단계] 플로팅 버튼을 클릭하면 방금 만든 _insertTodo() 함수에 데이터를 전달하도록 플로팅 버튼의 onPressed 이벤트 처리 함수에 호출문을 추가합니다.
[글상자] lib/main.dart
(...생략...)
floatingActionButton: FloatingActionButton(
onPressed: () async {
final todo = await Navigator.of(context).pushNamed('/add');
_insertTodo(todo);
},
child: Icon(Icons.add),
),
(...생략...)
[글상자 끝]
[그림] 실행 결과


Todo 추가
제목: 심부름
할 일: 당근 사오기
저장하기
[그림 끝]
데이터베이스에 데이터를 입력하는 기능을 만들었습니다. 이제 앱을 실행하고 <+> 버튼을 누르면 데이터를 추가하는 화면이 나옵니다. 여기에 제목과 할 일을 입력하고 <저장하기>를 누르면 데이터베이스에 입력한 데이터가 저장됩니다.
261
[Do it! 실습] 데이터 검색하기
이번에는 데이터를 검색하는 기능을 만들어 보겠습니다. 여기서 검색이란 데이터베이스에 저장된 데이터를 찾아 표시해주는 것을 의미합니다.
[1단계] main.dart 파일을 열고 데이터베이스에서 데이터를 가져오는 getTodos() 함수를 _DatabaseApp 클래스에 작성합니다.
[글상자] lib/main.dart
(...생략...)
Future<List<Todo>> getTodos() async {
final Database database = await widget.db;
final List<Map<String, dynamic>> maps = await database.query('todos');
return List.generate(maps.length, (i) {
bool active = maps[i]['active'] == 1 ? true : false;
return Todo(
title: maps[i]['title'].toString(),
content: maps[i]['content'].toString(),
active: active,
id: maps[i]['id']);
});
}
(...생략...)
[글상자 끝]
getTodos() 함수는 widget.db를 가져와서 database를 선언합니다. 그리고 query('todos') 함수로 todos 테이블을 가져와서 maps 목록에 넣습니다. 이 maps 목록을 활용해 List.generate() 함수에서 할 일 목록에 표시할 각 아이템을 만듭니다.
SQLite는 bool형을 0이나 1로 표시합니다. 0은 false이고 1은 true로 표시하므로 active 변수를 선언해 Todo에 넣어서 반환합니다.
[2단계] Future로 선언할 할 일 목록은 계속 값이 변하므로 따로 변수를 선언해 initState() 함수에서 호출하도록 합니다.
262
[글상자] lib/main.dart
(...생략...)
class _DatabaseApp extends State<DatabaseApp> {
Future<List<Todo>> todoList;
@override
void initState() {
super.initState();
todoList = getTodos();
}
(...생략...)
[글상자 끝]
[3단계] build() 함수에서 body는 다음처럼 작성합니다. 할 일 목록을 Future로 선언했으므로 FutureBuilder를 이용해서 화면에 표시할 위젯을 배치합니다.
[글상자] lib/main.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold( ...생략... ),
body: Container(
child: Center(
child: FutureBuilder(
builder: (context, snapshot) {
switch (snapshot.connectionState) {
case ConnectionState.none:
return CircularProgressIndicator();
case ConnectionState.waiting:
return CircularProgressIndicator();
case ConnectionState.active:
return CircularProgressIndicator();
case ConnectionState.done:
if (snapshot.hasData) {
return ListView.builder(
itemBuilder: (context, index) {
Todo todo = snapshot.data[index];
return Card(
263
child: Column(
children: <Widget>[
Text(todo.title),
Text(todo.content),
Text(todo.active.toString()),
],),
);
},
itemCount: snapshot.data.length,
);
} else {
return Text('No data');
}
}
return CircularProgressIndicator();
},
future: todoList,
),),),
floatingActionButton: FloatingActionButton( ...생략... ),
floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
);
}
(...생략...)
[글상자 끝]
[그림] 실행 결과


Database Example
심부름, 당근 사오기, false
[그림 끝]
FutuerBuilder 위젯은 서버에서 데이터를 받거나 파일에 데이터를 가져올 때 사용합니다. 데이터를 가져오는 동안에 시간이 걸리기 때문에 그 사이에 표시할 위젯을 만들기 위해 switch 문으로 snapshot.connectionState를 이용해 지금 상태를 확인합니다. 상태가 done이 되면 가져온 데이터를 바탕으로 ListView.builder를 이용해 화면에 표시합니다.
앱을 빌드한 후 다시 실행하면 조금 전에 저장한 데이터가 목록으로 표시됩니다.
264
[4단계] 그런데 새로운 데이터를 입력해도 할 일 목록에 나타나지 않습니다. 원인은 todoList를 갱신하지 않아서 그렇습니다. _insertTodo() 함수에 todoList를 갱신하는 코드를 추가합니다.
[글상자] lib/main.dart
(...생략...)
void _insertTodo(Todo todo) async {
final Database database = await widget.db;
await database.insert('todos', todo.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace);
setState(() {
todoList = getTodos();
});
}
(...생략...)
[글상자 끝]
[Do it! 실습] 데이터 수정하기
할 일 목록에서 아이템을 클릭하면 알림 창으로 할 일을 완료했는지 묻고 사용자의 선택에 따라 데이터베이스의 내용을 수정하는 기능을 만들어 보겠습니다. 이때 ListTile이라는 새로운 위젯을 사용해 보겠습니다. ListTile 위젯은 클릭할 수 있는 onTap() 함수가 포함된 목록을 만들어 줍니다.
[1단계] 먼저 main.dart 파일을 열고 _DatabaseApp 클래스의 build() 함수에서 할 일 목록을 표시하는 ListView.builder의 내용을 수정해 보겠습니다. 기존의 Card 위젯을 다음처럼 ListTile로 수정합니다.
[글상자] lib/main.dart
(...생략...)
return ListView.builder(
itemBuilder: (context, index) {
Todo todo = snapshot.data[index];
return ListTile(
title: Text(
todo.title,
265
style: TextStyle(fontSize: 20),
),
subtitle: Container(
child: Column(
children: <Widget>[
Text(todo.content),
Text('체크 : ${todo.active.toString()}'),
Container(
height: 1,
color: Colors.blue,
)
],
),
),
);
},
itemCount: snapshot.data.length,
);
(...생략...)
[글상자 끝]
ListTile 위젯의 옵션은 기존의 Card 위젯과 다릅니다. Card 위젯이 칸막이를 만들고 그 안에서 위젯을 자유롭게 꾸밀 수 있었다면 ListTile은 title, subtitle, leading(앞에 넣을 위젯), trailing(뒤에 넣을 위젯) 옵션으로 위젯의 위치를 지정할 수 있습니다. 여기서는 title에 할 일 제목을, subtitle에 할 일 내용과 완료 여부를 넣었습니다.
[2단계] 이제 ListTile 위젯의 아이템을 터치하면 알림 창이 실행되도록 onTap 이벤트를 작성합니다.
[글상자] lib/main.dart
(...생략...)
return ListTile(
title: Text( ...생략... ),
subtitle: Container( ...생략... ),
onTap: () async {
Todo result = await showDialog(
266
context: context,
builder: (BuildContext context) {
return AlertDialog(
title: Text('${todo.id} : ${todo.title}'),
content: Text('Todo를 체크하시겠습니까?'),
actions: <Widget>[
FlatButton(
onPressed: () {
setState(() {
todo.active == true
? todo.active = false
: todo.active = true;
});
Navigator.of(context).pop(todo);
},
child: Text('예')),
FlatButton(
onPressed: () {
Navigator.of(context).pop();
},
child: Text('아니요')),
],
);
});
if (result != null) {
_updateTodo(result);
}
},
);
(...생략...)
[글상자 끝]
먼저 showDialog() 함수를 이용해 알림 창을 호출합니다. 이때 async와 await를 이용해 비동기로 호출합니다. 실제 알림 창은 AlertDialog로 만드는데, title과 content를 입력한 후에 actions를 이용해 이벤트를 생성합니다. FlatButton으로 <예>, <아니요> 버튼을 만든 후 <아니오>를 고르면 알림 창을 종료하고 <예>를 고르면 todo값을 변경한 후 pop() 함수로 데이터를 전달합니다.
267
반환한 데이터는 result 변수로 입력받아서 다음 단계에서 정의할 _updateTodo() 함수에 넣습니다. 이때 if 문의 조건식으로 사용한 reuslt != null은 <아니요>를 고를 때도 todo값을 갱신하면 오류가 발생할 수 있어서 이를 방지하려는 의도입니다.
[3단계] 이어서 _updateTodo() 함수를 정의합니다. 이 함수는 데이터베이스에 접속한 후 데이터를 수정합니다.
[글상자] lib/main.dart
(...생략...)
void _updateTodo(Todo todo) async {
final Database database = await widget.db;
await database.update(
'todos',
todo.toMap(),
where: 'id = ?', // id값으로 수정할 데이터 찾기
whereArgs: [todo.id], // id값으로 수정할 데이터 찾기
);
setState(() {
todoList = getTodos();
});
}
(...생략...)
[글상자 끝]
데이터베이스에서 데이터를 수정할 때는 database.update() 함수를 이용합니다. 이때 where와 whereArgs에 전달할 인자가 중요합니다. where는 어떤 데이터를 수정할 것인지 나타내는 것인데, 이를 잘 설정해야 다른 데이터가 수정되지 않습니다. 할 일 데이터 중 id값은 기본 키로 설정했으므로 중복되지 않고 유일합니다. 따라서 id값으로 수정할 데이터를 찾습니다.
매개변수 todo로 전달받은 할 일 데이터의 id값을 whereArgs에 설정하고 이 값으로 데이터베이스에서 수정할 데이터를 찾을 수 있도록 where에 'id = ?'를 입력합니다. 이때 ?는 whereArgs에 입력한 값에 대응합니다.
268
[4단계] 이제 빌드 후 앱을 실행합니다. 할 일 목록이 보이면 그중 하나를 클릭해 보세요. 그리고 알림 창에서 <예>를 클릭하면 목록에서 체크 항목이 true로 변하는 것을 확인할 수 있습니다.
[그림] 실행 결과


3: 연락 - Todo를 체크하시겠습니까? [예]
→ 체크: true
[그림 끝]
[5단계] 이번에는 알림 창 안의 내용도 수정해서 할 일의 내용도 고칠 수 있게 바꿔봅시다. onTap 이벤트 처리 함수에 텍스트 위젯 대신 텍스트필드를 넣고 TextEditingController를 선언해서 넣습니다.
[글상자] lib/main.dart
(...생략...)
onTap: () async {
TextEditingController controller =
new TextEditingController(text: todo.content);
Todo result = await showDialog(
context: context,
builder: (BuildContext context) {
return AlertDialog(
title: Text('${todo.id} : ${todo.title}'),
269
content: TextField(
controller: controller,
keyboardType: TextInputType.text,
),
actions: <Widget>[
FlatButton(
onPressed: () {
todo.active == true
? todo.active = false
: todo.active = true;
todo.content =
controller.value.text;
Navigator.of(context).pop(todo);
},
child: Text('예')),
(...생략...)
[글상자 끝]
이제 아이템을 클릭해 알림 창을 열면 할 일의 내용도 수정할 수 있는 것을 확인할 수 있습니다.
[그림] 실행 결과


4: 선물 - 친구 생일선물 사기(수정 완료) [예]
→ 친구 생일선물 사기(수정 완료) - 체크: true
[그림 끝]
270
[Do it! 실습] 데이터 삭제하기
마지막으로 할 일을 삭제하는 기능을 만들어 보겠습니다. ListTile 위젯은 아이템을 한 번 터치하면 발생하는 onTap 외에도 길게 터치할 때 발생하는 onLongPress 이벤트도 제공합니다. onLongPress 이벤트를 이용해 삭제 기능을 만들어 보겠습니다.
[1단계] onTap 이벤트 처리 함수 아래 onLongPress 이벤트 처리 함수를 다음처럼 작성합니다.
[글상자] lib/main.dart
(...생략...)
return ListTile(
title: Text( ...생략... ),
subtitle: Container( ...생략... ),
onTap: () async { ...생략... },
onLongPress: () async {
Todo result = await showDialog(
context: context,
builder: (BuildContext context) {
return AlertDialog(
title: Text('${todo.id} : ${todo.title}'),
content: Text('${todo.content}를 삭제하시겠습니까?'),
actions: <Widget>[
FlatButton(
onPressed: () {
Navigator.of(context).pop(todo);
},
child: Text('예')),
FlatButton(
onPressed: () {
Navigator.of(context).pop();
},
child: Text('아니요')),
],);});
if (result != null) {
_deleteTodo(result);
}
},
); // ListTile 닫는 괄호
(...생략...)
[글상자 끝]
271
onLongPress 이벤트가 발생하면 아이템을 길게 눌렀을 때 알림 창이 뜨고 <예>를 누르면 가져온 할 일 아이템을 다음 단계에서 작성할 _deleteTodo() 함수에 전달해 삭제합니다.
[2단계] 매개변수로 전달받은 할 일 아이템을 데이터베이스에서 삭제하는 _deleteTodo() 함수를 _DatabaseApp 클래스에 추가합니다.
[글상자] lib/main.dart
(...생략...)
void _deleteTodo(Todo todo) async {
final Database database = await widget.db;
await database.delete('todos', where: 'id=?', whereArgs: [todo.id]);
setState(() {
todoList = getTodos();
});
}
(...생략...)
[글상자 끝]
데이터베이스에서 데이터를 삭제하려면 database.delete() 함수를 호출합니다. 이때 데이터를 수정할 때와 마찬가지로 id값으로 찾아서 해당 데이터를 지웁니다. 삭제 후 getTodos() 함수를 호출해 현재 목록을 새로 고침 합니다.
앱을 다시 빌드 후 실행하고 삭제하려는 아이템을 길게 클릭해 보세요. 삭제를 묻는 알림 창이 나타나고 <예>를 누르면 해당 데이터가 없어진 목록을 확인할 수 있습니다.
[그림] 실행 결과


4: 선물 - 친구 생일선물 사기(수정 완료)를 삭제하시겠습니까? [예]
→ 내용 없음
[그림 끝]
272
10-3 질의문으로 추가 기능 만들기
기본적으로 데이터베이스는 요청에 응답하는 식으로 데이터를 처리합니다. 앞에서 구현한 CRUD 기능도 데이터의 생성, 읽기, 수정, 삭제 등을 요청해서 그 응답을 받는 식으로 구현한 것이죠. 이때 데이터베이스에 데이터 조작을 요청하는 것을 질의(query)라고 하며 SQLite 데이터베이스 관리 시스템은 SQL(Structured Query Language)이라는 질의어를 통해 데이터를 처리합니다.
앞에서는 질의문을 직접 작성하지 않고 데이터를 Map 형태로 만들어서 사용했지만, 이번 절에서는 직접 질의문을 작성해서 데이터를 처리하는 방법을 살펴보겠습니다.
[Do it! 실습] 완료한 일만 모아서 보기 - 검색 질의
[1단계] 할 일 목록에서 완료한 일만 모아서 보는 기능을 만들어 보면서 데이터베이스에 검색 질의문을 어떻게 작성하는지 살펴보겠습니다. main.dart 파일을 열고 _DatabaseApp 클래스에서 appBar에 버튼을 하나 추가합니다.
[글상자] lib/main.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Database Example'),
actions: <Widget>[
FlatButton(
onPressed: () {},
child: Text(
'완료한 일',
style: TextStyle(color: Colors.white),
))
],
),
(...생략...)
[글상자 끝]
273
[2단계] <완료한 일>을 눌렀을 때 완료한 일만 보여주는 화면으로 이동해 보겠습니다. 새로운 화면을 만들기 위해 lib 폴더에 clearList.dart라는 이름으로 새 파일을 생성하고 StatefulWidget을 상속받는 ClearListApp 클래스를 만듭니다. 그리고 이 클래스는 State를 상속받는 _ClearListApp 클래스를 반환하도록 합니다.
[글상자] lib/clearList.dart
import 'package:flutter/material.dart';
import 'package:sqflite/sqlite_api.dart';
import 'todo.dart';
class ClearListApp extends StatefulWidget {
Future<Database> database;
ClearListApp(this.database);
@override
State<StatefulWidget> createState() => _ClearListApp();
}
class _ClearListApp extends State<ClearListApp> {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('완료한 일'),
),
);
}
}
[글상자 끝]
[3단계] 새로운 페이지를 만들었으므로 main.dart 파일에서 MyApp 클래스의 routes에도 경로를 추가합니다.
274
[글상자] lib/main.dart
import 'clearList.dart';
(...생략...)
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
Future<Database> database = initDatabase();
return MaterialApp(
(...생략...)
routes: {
'/': (context) => DatabaseApp(database),
'/add': (context) => AddTodoApp(database),
'/clear': (context) => ClearListApp(database)
},
(...생략...)
[글상자 끝]
[4단계] 이제 appBar에서 FlatButton을 눌렀을 때 ClearListApp으로 이동하는 코드를 작성합니다.
[글상자] lib/main.dart
(...생략...)
appBar: AppBar(
title: Text('Database Example'),
actions: <Widget>[
FlatButton(
onPressed: () async {
await Navigator.of(context).pushNamed('/clear');
setState(() {
todoList = getTodos();
});
},
child: Text(
'완료한 일',
style: TextStyle(color: Colors.white),
))
],
),
(...생략...)
[글상자 끝]
275
[5단계] 다시 clearList.dart 파일을 열고 데이터베이스에서 완료한 일만 불러오는 getClearList() 함수를 _ClearListApp 클래스에 작성합니다.
[글상자] lib/clearList.dart
import 'todo.dart';
(...생략...)
class _ClearListApp extends State<ClearListApp> {
@override
Widget build(BuildContext context) { ...생략... }
Future<List<Todo>> getClearList() async {
final Database database = await widget.database;
List<Map<String, dynamic>> maps = await database
.rawQuery('select title, content, id from todos where active=1');
return List.generate(maps.length, (i) {
return Todo(
title: maps[i]['title'].toString(),
content: maps[i]['content'].toString(),
id: maps[i]['id']);
});
}
}
[글상자 끝]
「10-2」절에서 작성한 getTodos() 함수와는 다르게 rawQuery() 함수를 이용했습니다. 이 함수는 직접 SQL 질의문을 전달해 데이터베이스에 질의합니다. 여기에 작성한 질의문은 데이터베이스에서 데이터를 검색할 때 이용하는 select입니다. select 구문은 from 절에 지정한 테이블에서 where 절에 지정한 조건에 맞는 데이터를 검색해서 select 뒤에 나열한 칼럼을 가져 옵니다.
[글상자]
select title, content, id from todos where active=1
[글상자 끝]
위 질의문은 todos 테이블에 있는 데이터에서 active(완료 여부)가 1(참)인 데이터의 title, content, id값을 가져오라는 의미입니다. 즉, 완료한 일만 가져옵니다.
276
[6단계] 이제 _ClearListApp 클래스의 build() 함수에 body를 작성하고 FutureBuilder를 이용해 화면에 보일 위젯을 배치합니다.
[글상자] lib/clearList.dart
(...생략...)
class _ClearListApp extends State<ClearListApp> {
Future<List<Todo>> clearList;
@override
void initState() {
super.initState();
clearList = getClearList();
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('완료한 일'),
),
body: Container(
child: Center(
child: FutureBuilder(
builder: (context, snapshot) {
switch (snapshot.connectionState) {
case ConnectionState.none:
return CircularProgressIndicator();
case ConnectionState.waiting:
return CircularProgressIndicator();
case ConnectionState.active:
return CircularProgressIndicator();
case ConnectionState.done:
if (snapshot.hasData) {
return ListView.builder(
itemBuilder: (context, index) {
Todo todo = snapshot.data[index];
return ListTile(
title: Text(
todo.title,
277
style: TextStyle(fontSize: 20),
),
subtitle: Container(
child: Column(
children: <Widget>[
Text(todo.content),
Container(
height: 1,
color: Colors.blue,
)
],),),);
},
itemCount: snapshot.data.length,
);
}
}
return Text('No data');
},
future: clearList,
),),),
);
} // build() 함수 닫는 괄호
Future<List<Todo>> getClearList() async { ...생략... }
}
[글상자 끝]
[그림] 실행 결과


완료한 일
→ 완료한 일 - 연락: 어머님께 전화하기
[그림 끝]
앱을 빌드하고 실행하면 <완료한 일> 버튼이 보입니다. 이 버튼을 누르면 완료한 일만 보이는 화면으로 이동하는 것을 확인할 수 있습니다.
278
[Do it! 실습] 완료한 일 모두 지우기 - 삭제 질의
[1단계] 이제 버튼을 하나 더 만들어서 완료한 일을 모두 지우는 기능을 만들어 보겠습니다.
clearList.dart 파일을 열고 build() 함수에 floatingActionButton 위젯을 하나 만듭니다. 이 버튼을 클릭하면 알림 창이 표시되고 알림 창에서 <예>를 누르면 지정한 데이터를 삭제하는 코드를 작성합니다.
[글상자] lib/clearList.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('완료한 일'),
),
body: Container( ...생략... ),
floatingActionButton: FloatingActionButton(
onPressed: () async {
final result = await showDialog(
context: context,
builder: (BuildContext context) {
return AlertDialog(
title: Text('완료한 일 삭제'),
content: Text('완료한 일을 모두 삭제할까요?'),
actions: <Widget>[
FlatButton(
onPressed: () {
Navigator.of(context).pop(true);
},
child: Text('예')),
FlatButton(
onPressed: () {
Navigator.of(context).pop(false);
),
child: Text('아니요')),
],
);
279
});
if (result == true) {
_removeAllTodos();
}
},
child: Icon(Icons.remove),
),
);
}
void _removeAllTodos() async {
final Database database = await widget.database;
database.rawDelete('delete from todos where active=1');
setState(() {
clearList = getClearList();
});
}
[글상자 끝]
build() 함수 아래 작성한 _removeAllTodos() 함수는 데이터베이스에서 데이터를 삭제합니다. 데이터베이스에서 데이터를 삭제할 때는 delete 문을 사용합니다. 따라서 _removeAllTodos() 함수에서 호출한 rawDelete() 함수에 다음과 같은 질의문을 전달합니다.
[글상자]
delete from todos where active=1
[글상자 끝]
이 질의문은 todos 테이블에서 active가 1(참)인 모든 데이터를 삭제하라는 의미입니다. 질의 후 clearList를 새로 고침 했습니다.
[2단계] 앱을 빌드하고 실행한 후 완료한 일 목록에서 <-> 버튼을 눌러 보세요. 그리고 데이터 삭제 알림 창에서 <예>를 누르면 완료한 일이 모두 삭제됩니다. 또한, 완료한 일을 삭제한 후 화면 왼쪽 위에 뒤로 가기(←) 버튼을 누르면 메인 화면에서도 완료한 일이 사라진 것을 확인할 수 있습니다.
280
[그림] 실행 결과


데이터 삭제 - 모든 할 일을 삭제할까요? [예] (-)
→ [← 완료한 일]
→ Database Example(완료한 일) - 심부름: 당근 사오기, 체크: false
[그림 끝]
[Do it! 실습] 모두 완료로 수정하기 - 수정 질의
이번에는 메인 화면에 버튼을 하나 더 만들어서 모든 할 일을 완료로 처리하는 기능을 만들어 보겠습니다. main.dart 파일을 열고 _DatabaseApp 클래스의 build() 함수에서 floatingActionButton 위젯의 내용을 다음처럼 수정합니다.
[글상자] lib/main.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar( ...생략... ),
body: Container( ...생략... ),
floatingActionButton: Column(
children: <Widget>[
FloatingActionButton(
onPressed: () async {
final todo = await Navigator.of(context).pushNamed('/add');
281
if (todo != null) {
_insertTodo(todo);
}
},
heroTag: null,
child: Icon(Icons.add),
),
SizedBox(
height: 10,
),
FloatingActionButton(
onPressed: () async {
_allUpdate();
},
heroTag: null,
child: Icon(Icons.update),
),
],
mainAxisAlignment: MainAxisAlignment.end,
));
}
void _allUpdate() async {
final Database database = await widget.db;
await database.rawUpdate('update todos set active = 1 where active = 0');
setState(() {
todoList = getTodos();
});
}
(...생략...)
[글상자 끝]
플로팅 버튼에서 Column 위젯을 이용해 세로로 버튼을 나열했습니다. 위쪽 버튼은 할 일을 추가하고 아래쪽 버튼은 모든 할 일을 완료한 것으로 수정합니다.
Column 위젯에서 가장 중요한 코드는 heroTag를 null로 설정하는 것입니다. heroTag를 null로 설정하지 않으면 오류가 발생합니다. 이 오류는 화면을 넘길 때 플러터에서 자연스러운 애니메이션을 자동으로 추가하는데, 페이지가 넘어가는 위젯에 받아줄 태그가 없어서 발생합니다. 우선은 null로 설정해서 오류를 피합니다.
282
아래쪽 버튼을 누르면 _allUpdate() 함수를 호출하도록 작성합니다. 이 함수는 rawUpdate() 함수에 다음과 같은 질의문을 전달해 데이터를 수정하도록 했습니다. 데이터베이스에서 데이터를 수정할 때는 update 문을 이용합니다.
[글상자]
update todos set active = 1 where active = 0
[글상자 끝]
이 질의문은 todos 테이블에서 active가 0(false)인 데이터를 모두 찾아서 active를 1(true)로 변경(set)합니다.
이제 앱을 빌드 후 실행하고 아래쪽 버튼을 누르면 모든 할 일이 true로 변경되는 것을 확인할 수 있습니다.
[그림] 실행 결과


시계 모양 아이콘 → 연락 - 부모님께 안부 전화하기, 체크: true
[그림 끝]
지금까지 앱의 데이터를 데이터베이스에 저장해 관리하는 방법을 살펴보았습니다. 데이터베이스를 이용하면서 때로는 Map 형태로 데이터를 주고받을 수도 있고 때로는 질의문을 직접 작성해서 이용할 수도 있습니다. 다양한 방법을 익혀서 상황에 따라 응용하면 됩니다.
이 책에서는 기본적인 CRUD 기능만 살펴봤지만, 본격적인 앱을 만들고자 한다면 데이터베이스는 별도로 공부해야 하는 주제입니다. 예를 들어 어떻게 테이블을 만들고 어떻게 질의하느냐에 따라서 속도를 더 빠르게 할 수도 있고 더 다양한 데이터베이스 기능을 활용할 수도 있습니다. 이러한 내용은 이 책의 주제에 벗어나므로 다루지 않았지만 본격적으로 데이터베이스를 활용하는 앱을 만들 때는 필요한 내용입니다.
283
11 애니메이션 활용하기
이번 장의 주제는 앱에서 각종 동작을 매끄럽게 보여주는 애니메이션(animation)입니다. 애니메이션은 앱을 만드는 데 필수는 아니지만 화면 이동이나 위젯이 표시되고 사라지는 동작을 매끄럽게 표현해줌으로써 좀 더 섬세한 사용자 경험을 줄 수 있습니다.
“악마는 디테일에 있다”라는 말처럼 애니메이션은 쉬워 보이지만 제대로 구현하려면 많은 시간과 노력이 필요합니다. 그런데 플러터는 애니메이션을 비교적 쉽게 구현할 수 있는 기능을 제공합니다. 이번 장에서는 이런 기능을 이용해 애니메이션을 적용한 플러터 앱을 만들어 보겠습니다.
11-1 애니메이션 구현하기
11-2 나만의 인트로 화면 만들기
11-3 스크롤 시 역동적인 앱바 만들기
284
11-1 애니메이션 구현하기
애니메이션은 위젯이 처음 위치에서 마지막 위치까지 어떻게 이동할 것인지를 정의하는 것에서 출발합니다. 이러한 동작을 매끄럽게 표현하려면 프레임 단위로 위젯의 위치를 구현해야 하지만 그러려면 복잡한 계산식이 필요합니다. 그런데 플러터는 복잡한 계산식이 없이도 편리하게 애니메이션을 구현하는 기능을 제공합니다.
이번 절에서는 플러터가 제공하는 애니메이션 기능 중 하나인 AnimatedContainer 위젯을 사용해 보겠습니다. AnimatedContainer 위젯은 기존의 컨테이너 위젯과 똑같지만 애니메이션의 모양을 결정하는 curve와 재생 시간을 결정하는 duration 변수를 추가로 넣을 수 있습니다.
다음 주소에 접속하면 플러터 API의 Curves 클래스가 제공하는 다양한 애니메이션 모양을 확인할 수 있습니다.
[글상자]
https://api.flutter.dev/flutter/animation/Curves-class.html
[글상자 끝]
[그림 11-1] Curves 클래스가 제공하는 다양한 애니메이션 모양


[그림 끝]
플러터의 애니메이션은 선형보간법[각주*]을 활용해 다양한 모양을 만드는데 이런 수학적인 부분을 AnimatedContainer가 손쉽게 처리해 줍니다. 따라서 모양과 재생 시간만 정의하면 애니메이션을 구현할 수 있습니다.
[각주*] 두 개의 점이 주어졌을 때에 그 두 점을 지나는 함수를 직선의 방정식으로 나타내는 것을 말합니다.[각주 끝]
285
[아하!] Flutter Gallery 앱 소개
플러터는 Flutter Gallery라는 안드로이드 앱을 통해 플러터의 강력한 애니메이션 기능을 소개합니다. 이 앱을 내려받아 보면 플러터에서 어떤 식으로 애니메이션이 동작하는지 감을 잡을 수 있습니다.
[그림 11-2] 플러터에서 제공하는 Flutter Gallery 앱


갤러리: Reply - An efficient, focused email app
카테고리: MATERIAL, CUPERTINO, 스타일 및 기타
[그림 끝]
[아하! 끝]
[Do it! 실습] 그래프 애니메이션
이번 실습에서는 키와 몸무게를 이용해 체질량지수인 BMI(body mass index)[각주*]를 구하고 각 수치를 그래프로 표현하는 앱을 만들어 보겠습니다. 이 때 버튼을 이용해 각 수치가 변할 때마다 그래프의 높낮이가 변경되는 애니메이션을 적용해 보겠습니다.
[각주*] 키와 몸무게를 이용해 계산한 비만도 지수로, 체중(㎏)을 키(m)의 제곱으로 나눈 값입니다. 원래 체질량지수를 정확하게 계산하려면 성별과 나이 등도 고려해야 하지만 실습에서는 간략한 계산식으로 BMI를 계산해 그래프를 그리는 데 집중해 보겠습니다.[각주 끝]
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] 먼저 animation_example이라는 이름으로 새로운 플러터 프로젝트를 만들고 main.dart 파일을 다음처럼 수정해 기본 골격을 만듭니다. 기본 골격은 기존에 만들었던 앱과 크게 다르지 않습니다.
286
[글상자] lib/main.dart
import 'package:flutter/material.dart';
void main() => runApp(MyApp());
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(
primarySwatch: Colors.blue,
),
home: AnimationApp(),
);
}
}
class AnimationApp extends StatefulWidget {
@override
State<StatefulWidget> createState() => _AnimationApp();
}
class _AnimationApp extends State<AnimationApp> {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Animation Example'),
),
body: Container()
);
}
}
[글상자 끝]
287
[2단계] lib 폴더 아래 people.dart 파일을 새로 만들고 다음처럼 작성합니다. People 클래스는 이름, 키, 몸무게를 입력받아서 BMI를 계산해 입력하는 클래스입니다.
[글상자] lib/people.dart
class People {
String name;
double height;
double weight;
double bmi;
People(this.name, this.height, this.weight) {
bmi = weight / ((height / 100) * (height / 100));
}
}
[글상자 끝]
[3단계] main.dart 파일에서 _AnimationApp 클래스에 People 리스트를 만들고 초기화 함수 initState()에 다음과 같은 기초 데이터를 넣습니다.
[글상자] _AnimationApp class
import 'package:flutter/material.dart';
import 'people.dart';
(...생략...)
class _AnimationApp extends State<AnimationApp> {
List<People> peoples = new List();
int current = 0;
@override
void initState() {
peoples.add(People('스미스', 180, 92));
peoples.add(People('메리', 162, 55));
peoples.add(People('존', 177, 75));
peoples.add(People('바트', 130, 40));
peoples.add(People('콘', 194, 140));
peoples.add(People('디디', 100, 80));
super.initState();
}
(...생략...)
[글상자 끝]
288
[4단계] _AnimationApp 클래스의 build() 함수를 다음처럼 작성합니다. 키와 몸무게 그리고 BMI 등 3개의 그래프를 보여주고 각 그래프에는 bounceIn, easeInCubic, pinkAccent라는 애니메이션 효과를 2초씩 설정합니다.
[글상자] lib/main.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Animation Example'),
),
body: Container(
child: Center(
child: Column(
children: <Widget>[
SizedBox(
child: Row(
children: <Widget>[
SizedBox(width: 100, child: Text('이름 : ${peoples[current].name}')),
AnimatedContainer(
duration: Duration(seconds: 2), // 애니메이션 모양과 재생 시간 설정
curve: Curves.bounceIn, // 애니메이션 모양과 재생 시간 설정
color: Colors.amber,
child: Text(
'키 ${peoples[current].height}',
textAlign: TextAlign.center,
),
width: 50,
height: peoples[current].height,
),
AnimatedContainer(
duration: Duration(seconds: 2),
curve: Curves.easeInCubic,
color: Colors.blue,
child: Text(
'몸무게 ${peoples[current].weight}',
textAlign: TextAlign.center,
289
),
width: 50,
height: peoples[current].weight,
),
AnimatedContainer(
duration: Duration(seconds: 2),
curve: Curves.linear,
color: Colors.pinkAccent,
child: Text(
'bmi ${peoples[current].bmi.toString().substring(0, 2)}',
textAlign: TextAlign.center,
),
width: 50,
height: peoples[current].bmi,
),
],
mainAxisAlignment: MainAxisAlignment.spaceAround,
crossAxisAlignment: CrossAxisAlignment.end,
),
height: 200,
),
RaisedButton(
onPressed: () {
setState(() {
if (current < peoples.length - 1) {
current++;
}
});
},
child: Text('다음'),
),
RaisedButton(
onPressed: () {
setState(() {
if (current > 0) {
current--;
}
});
290
},
child: Text('이전'),
)
],
mainAxisAlignment: MainAxisAlignment.center,
),),),
);
}
(...생략...)
[글상자 끝]
스캐폴드의 본문에는 Column을 이용해 위젯을 세로로 만들고 SizedBox와 RaisedButton을 두 개 배치합니다. SizedBox 안에는 Row를 이용해 텍스트 위젯과 애니메이션을 구현하는 AnimatedContainer를 만듭니다. 버튼을 누르면 current값이 바뀌면서 그래프의 높이가 변경되도록 코드를 작성합니다.
AnimatedContainer는 애니메이션에 특화된 컨테이너로 다양한 옵션을 이용해 애니메이션을 간편하게 구현할 수 있습니다. duration 옵션에 지정한 Duration(second: 2)는 2초 동안 애니메이션을 재생하는 코드입니다. second 대신에 days, hours, milliseconds 등 다양한 시간 단위를 사용할 수 있습니다. 그리고 curve 옵션에는 앞에서 잠깐 소개한 플러터의 Curves 클래스가 제공하는 애니메이션 모양을 골라 지정합니다.
이제 앱을 빌드한 후 실행하면 그래프가 보입니다. <다음> 버튼을 누르면 세 개의 그래프가 값이 바뀌면서 각기 다른 애니메이션 효과를 볼 수 있습니다.
[그림] 실행 결과


Animation Example
이름: 스미스, 키 180.0, 몸무게 92.0, bmi 28
[다음], [이전]
[그림 끝]
291
[Do it! 실습] 색상 변경 애니메이션
[1단계] 이번에는 그래프의 색상이 바뀌는 애니메이션을 구현해 보겠습니다. peoples를 선언한 곳에 다음처럼 Color값을 하나 선언합니다.
[글상자] lib/main.dart
(...생략...)
class _AnimationApp extends State<AnimationApp> {
List<People> peoples = new List();
Color weightColor = Colors.blue;
int current = 0;
(...생략...)
[글상자 끝]
그리고 이 색상값을 몸무게 그래프를 나타내는 AnimatedContainer의 color 옵션에 입력합니다.
[글상자] lib/main.dart
(...생략...)
AnimatedContainer(
duration: Duration(seconds: 2),
curve: Curves.easeInCubic,
color: weightColor,
child: Text(
'몸무게 ${peoples[current].weight}',
textAlign: TextAlign.center,
),
(...생략...)
[글상자 끝]
[2단계] 몸무게에 따라 색상을 바꿔주는 _changeWeightColor() 함수를 다음처럼 추가합니다.
[글상자] lib/main.dart
(...생략...)
void _changeWeightColor(double weight) {
if (weight < 40) {
weightColor = Colors.blueAccent;
292
} else if (weight < 60) {
weightColor = Colors.indigo;
} else if (weight < 80) {
weightColor = Colors.orange;
} else {
weightColor = Colors.red;
}
}
(...생략...)
[글상자 끝]
[3단계] <다음>이나 <이전> 버튼을 누르면 실행되는 onPressed 이벤트 핸들러에서 방금 정의한 _changeWeightColor() 함수를 호출합니다. 이때 인자로 현재 인물의 몸무게를 전달합니다.
[글상자] lib/main.dart
(...생략...)
RaisedButton(
onPressed: () {
setState(() {
(...생략...)
_changeWeightColor(peoples[current].weight);
});
},
child: Text('다음'),
),
RaisedButton(
onPressed: () {
setState(() {
(...생략...)
_changeWeightColor(peoples[current].weight);
});
},
child: Text('이전'),
)
(...생략...)
[글상자 끝]
293
이제 앱을 빌드 후 실행하면 버튼을 눌러 몸무게가 바뀔 때마다 그래프의 색상이 자연스럽게 바뀌는 것을 확인할 수 있습니다.
[그림] 실행 결과


이름: 콘 - 몸무게 140.0 → 이름: 바트 - 몸무게 40.0
[그림 끝]
[Do it! 실습] 불투명도 애니메이션
이번에는 위젯이 서서히 사라지는 효과를 구현해 보겠습니다. 이러한 애니메이션은 AnimatedOpacity 위젯을 이용해 구현할 수 있습니다. AnimatedOpacity 위젯은 불투명도를 나타내는 opacity라는 옵션을 조절해 위젯을 투명하게, 또는 불투명하게 표현할 수 있습니다.
[1단계] _AnimationApp 클래스에 불투명도를 나타낼 _opacity 변수를 double형으로 선언하고 1로 초기화합니다. 그리고 앞의 실습에서 만들어 두었던 SizedBox 위젯을 AnimatedOpacity 위젯으로 감싼 후에 opacity와 duration 옵션에 값을 넣어 줍니다.
294
[글상자] lib/main.dart
(...생략...)
class _AnimationApp extends State<AnimationApp> {
double _opacity = 1;
(...생략...)
body: Container(
child: Center(
child: Column(
children: <Widget>[
AnimatedOpacity(
opacity: _opacity,
duration: Duration(seconds: 1),
child: SizedBox(
child: Row(
children: <Widget>[ ...생략... ],
mainAxisAlignment: MainAxisAlignment.spaceAround,
crossAxisAlignment: CrossAxisAlignment.end,
),
height: 200,
),
),
RaisedButton( ...생략... ),
RaisedButton( ...생략... ),
],
(...생략...)
[글상자 끝]
[2단계] 위젯을 서서히 사라지게 하고 나타나게 하는 <사라지기> 버튼을 새로 만들고 불투명도를 나타내는 _opacity값이 1이면 0으로(사라지게), 그렇지 않으면 1로(나타나게) 설정합니다.
[글상자] lib/main.dart
(...생략...)
RaisedButton( ...생략... ),
RaisedButton( ...생략... ),
RaisedButton(
onPressed: () {
295
setState(() {
_opacity == 1 ? _opacity = 0 : _opacity = 1;
});
},
child: Text('사라지기'),
),
],
(...생략...)
[글상자 끝]
이제 앱을 빌드한 후 실행하면 <사라지기> 버튼을 눌렀을 때 그래프 등이 서서히 사라지는 효과를 확인할 수 있습니다.
[그림] 실행 결과


[사라지기] → 내용이 사라짐
[그림 끝]
296
11-2 나만의 인트로 화면 만들기
이번 절에서는 애니메이션을 좀 더 세밀하게 조절하는 법과 페이지를 이동할 때 사용하는 애니메이션을 알아보고 이를 활용해 나만의 인트로 화면을 만들어 보겠습니다.
[Do it! 실습] 페이지 이동 애니메이션
페이지를 이동할 때 애니메이션을 적용하려면 Hero 위젯을 사용합니다. 이 위젯은 페이지 간의 이미지를 자연스럽게 애니메이션으로 연결해 줍니다.
[1단계] 먼저 main.dart 파일을 열고 <사라지기> 버튼 아래에 두 번째 페이지로 이동하는 버튼을 새로 만듭니다.
[글상자] lib/main.dart
import 'secondPage.dart';
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
(...생략...)
children: <Widget>[
AnimatedOpacity( ...생략... ),
RaisedButton( ...생략... ),
RaisedButton( ...생략... ),
RaisedButton( ...생략... ),
RaisedButton(
onPressed: () {
Navigator.of(context).push(MaterialPageRoute(builder:
(context) => SecondPage()));
},
child: SizedBox(
width: 200,
297
child: Row(
children: <Widget>[
Hero(tag: 'detail', child: Icon(Icons.cake)),
Text('이동하기')
],
),),),
],
mainAxisAlignment: MainAxisAlignment.center,
(...생략...)
[글상자 끝]
이 버튼은 아이콘과 텍스트로 이루어지는데 아이콘은 Hero 위젯으로 감쌌습니다. 그리고 tag를 'detail'이라고 설정한 후 아이콘을 넣습니다. 이렇게 하면 같은 태그의 다른 Hero 위젯과 연결됩니다. 이때 Hero 위젯에 텍스트를 넣으면 글꼴과 크기 등 외부 요인 때문에 오류가 발생할 수 있으니 주의해야 합니다.
[2단계] lib 폴더에 secondPage.dart 파일을 만들고 StatefulWidget을 상속받는 SecondPage 클래스를 생성합니다. build() 함수에서는 Hero 위젯으로 감싼 아이콘을 화면 가운데에 표시합니다. 이때 tag 옵션을 'detail'로 지정해 앞에서 정의한 Hero 위젯과 연결합니다.
[글상자] secondPage.dart
import 'package:flutter/material.dart';
class SecondPage extends StatefulWidget {
@override
State<StatefulWidget> createState() => _SecondPage();
}
class _SecondPage extends State<SecondPage> {
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(title: Text('Animation Example2'),),
body: Container(
child: Center(
298
child: Column(
children: <Widget>[
Hero(tag: 'detail', child: Icon(Icons.cake , size: 150,) ) ,
],
mainAxisAlignment: MainAxisAlignment.center,
),),),);
}
}
[글상자 끝]
Hero 위젯이 어떤 효과를 나타내는지 알아보고자 앱을 실행한 후 <이동하기> 버튼을 눌러보세요. 버튼에 있는 아이콘이 아래쪽으로 떨어져 나와 커진 다음 자연스럽게 두 번째 페이지의 가운데로 이동합니다. 그리고 내비게이션바의 <←> 버튼을 눌러 이전 페이지로 돌아갈 때도 아이콘이 자연스럽게 작아지면서 버튼으로 이동하는 것을 볼 수 있습니다.
[그림] 실행 결과


[그림 끝]
299
[Do it! 실습] 애니메이션을 세밀하게 조정하기
이번에는 앞에서 사용한 AnimatedContainer 위젯보다 좀 더 세밀하게 애니메이션을 조절하고 싶을 때 사용하는 AnimatedBuilder를 알아보겠습니다. AnimatedContainer 위젯이 이미 만들어진 인스턴트 식품이라면 AnimatedBuilder 위젯은 직접 조리해 먹는 음식에 비유할 수 있습니다.
이번 실습에서는 아이콘과 버튼을 하나 만들고 버튼을 누르면 아이콘이 작아지는 동시에 회전하면서 오른쪽 아래로 서서히 사라지는 효과를 AnimatedBuilder 위젯으로 구현해 보겠습니다.
[1단계] 앞의 실습에서 만든 secondPage.dart 파일을 열고 애니메이션 컨트롤러를 만들어 보겠습니다. 애니메이션 컨트롤러를 사용하려면 SingleTickerProviderStateMixin 클래스를 추가로 상속받아야 합니다.
State 클래스를 상속받은 _SecondPage 클래스에 with 키워드를 이용해 SingleTickerProviderStateMixin 클래스를 추가로 상속하고 각 애니메이션을 정의하는 다음 코드를 작성합니다.
[글상자] lib/secondPage.dart
import 'package:flutter/material.dart';
import 'dart:math';
(...생략...)
class _SecondPage extends State<SecondPage>
with SingleTickerProviderStateMixin {
AnimationController _animationController;
Animation _rotateAnimation;
Animation _scaleAnimation;
Animation _transAnimation;
@override
void initState() {
super.initState();
_animationController =
AnimationController(duration: Duration(seconds: 5), vsync: this);
_rotateAnimation =
300
Tween<double>(begin: 0, end: pi * 10).animate(_animationController);
_scaleAnimation =
Tween<double>(begin: 1, end: 0).animate(_animationController);
_transAnimation =
Tween<Offset>(begin: Offset(0, 0), end: Offset(200, 200))
.animate(_animationController);
}
@override
void dispose() {
_animationController.dispose();
super.dispose();
}
(...생략...)
}
[글상자 끝]
먼저 AnimationController 객체 1개와 Animation 객체 3개를 만들고 initState() 함수에서 초기화합니다. AnimationController는 프레임마다 새로운 값을 생성하는 특별한 애니메이션 클래스입니다. 애니메이션 컨트롤러는 지정된 시간 동안 선형보간법을 이용해 시작점부터 끝점 사이의 숫자를 초당 60개씩 생성합니다.
AnimationController 객체를 생성할 때는 애니메이션의 재생 시간을 나타내는 duration과 애니메이션을 표현할 대상을 나타내는 vsync 인수를 전달합니다. 위 코드에서는 5초 동안 현재 페이지(this)에서 애니메이션이 동작하도록 했습니다.
각 애니메이션은 Tween 클래스를 사용해 초기화했습니다. 기본적으로 애니메이션 컨트롤러가 생성해주는 숫자의 범위는 0.0~1.0입니다. 만약 다른 범위나 데이터 유형이 필요하면 Tween을 사용해 애니메이션을 구성할 수 있습니다.
Tween은 시작점을 나타내는 begin 인자와 끝점을 나타내는 end 인자만 있으면 되는 스테이트리스 객체입니다. 이 객체를 애니메이션에 사용하려면 애니메이션 컨트롤러 객체를 전달해 animate() 함수를 호출해야 합니다.
또한, 화면이 종료될 때 호출되는 dispose() 함수에서 _animationConroller.dispose() 함수를 호출해 애니메이션도 종료해 주어야 합니다. 그렇지 않으면 화면을 그리려고 하는데 대상이 없어서 오류가 발생합니다.
301
[2단계] 이제 build() 함수를 만들어 화면을 구현해 보겠습니다. build() 함수에서는 AnimatedBuilder 위젯을 이용해 앞에서 정의한 애니메이션을 화면에 표시합니다.
[글상자] lib/secondPage.dart
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Animation Example2'),
),
body: Container(
child: Center(
child: Column(
children: <Widget>[
AnimatedBuilder(
animation: _rotateAnimation,
builder: (context, widget) {
return Transform.translate(
offset: _transAnimation.value,
child: Transform.rotate(
angle: _rotateAnimation.value,
child: Transform.scale(
scale: _scaleAnimation.value,
child: widget,
)),
);
},
child: Hero(
tag: 'detail',
child: Icon(
Icons.cake,
size: 300,
)),
),
RaisedButton(
onPressed: () {
_animationController.forward();
},
302
child: Text('로테이션 시작하기'),
),
],
mainAxisAlignment: MainAxisAlignment.center,
),),),
);
}
[글상자 끝]
AnimatedBuilder는 다른 빌더처럼 애니메이션을 정의한 대로 화면에 그려줍니다. 먼저 builder 옵션에 애니메이션을 어떻게 보여줄지 정합니다. Transform의 translate() 함수는 위젯의 방향, rotate() 함수는 회전, scale() 함수는 크기를 조절합니다. 이로써 위젯이 offset에 지정한 방향으로 이동하면서 회전하고 점점 작아지는 애니메이션을 구현할 수 있습니다.
그리고 child 옵션에 앞의 실습에서 만들어 두었던 Hero 위젯으로 케이크 모양의 아이콘을 정의합니다.
이제 앱을 빌드 후 실행해 봅시다. <로테이션 시작하기> 버튼을 누르면 지금까지 정의한 대로 애니메이션이 동작하는 것을 확인할 수 있습니다.
[그림] 실행 결과


Animation Example2 - 로테이션 시작하기
Animation Example2 - 로테이션 시작하기
[그림 끝]
303
[Do it! 실습] 나만의 인트로 화면 만들기
앞의 실습에서 살펴본 것처럼 Hero를 이용하면 페이지 연결을 자연스럽게 표현할 수 있고, AnimatedBuilder와 Tween을 이용하면 원하는 동작으로 애니메이션을 만들 수 있습니다. 이번 실습에서는 이러한 내용을 바탕으로 나만의 인트로 화면을 만들어 보겠습니다. 보통 인트로 화면은 앱을 시작할 때 제작사의 로고나 앱의 정체성을 표시하는 데 사용합니다.
[1단계] 이번 실습에서는 원과 태양, 토성을 나타내는 총 3장의 이미지가 필요합니다. 프로젝트 아래 repo/images라는 새 폴더를 만들고 필자가 제공한 3개의 이미지 파일(circle.png, saturn.png, sunny.png)을 추가합니다.
[그림 11-3] 완성된 이미지 모습


[그림 끝]
그리고 pubspec.yaml 파일을 열고 방금 추가한 이미지 파일을 애셋으로 등록한 후 플러터 명령 줄이 나타나면 <Pub get>을 누릅니다.
[글상자] pubspec.yaml
(...생략...)
flutter:
uses-material-design: true
assets:
- repo/images/circle.png
- repo/images/saturn.png
- repo/images/sunny.png
[글상자 끝]
[2단계] lib 폴더에 saturnLoading.dart 파일을 새로 만들고 StatefulWidget을 상속받는 SaturnLoading 클래스를 작성합니다. 그다음 State 클래스를 상속받는 _SaturnLoading 클래스를 만든 후 AnimationController와 Animation 변수를 생성해 initState() 함수에서 초기화합니다. 애니메이션 컨트롤러는 3초 동안 현재 화면에서 동작하도록 설정합니다.
304
[글상자] lib/satrunLoading.dart
import 'package:flutter/material.dart';
import 'dart:math';
class SaturnLoading extends StatefulWidget {
_SaturnLoading _saturnLoading = _SaturnLoading();
@override
State<StatefulWidget> createState() => _saturnLoading;
}
class _SaturnLoading extends State<SaturnLoading>
with SingleTickerProviderStateMixin {
AnimationController _animationController;
Animation _animation;
@override
void initState() {
super.initState();
_animationController = // 3초 동안 동작하는 애니메이션 컨트롤러 정의
AnimationController(vsync: this, duration: Duration(seconds: 3)); // 3초 동안 동작하는 애니메이션 컨트롤러 정의
_animation = // 애니메이션 시작점과 끝점 정의
Tween<double>(begin: 0, end: pi * 2).animate(_animationController); // 애니메이션 시작점과 끝점 정의
_animationController.repeat();
}
@override
void dispose() {
_animationController.dispose();
super.dispose();
}
}
[글상자 끝]
[3단계] _SaturnLoading 클래스의 build() 함수에서는 AnimatedBuilder를 이용해 애니메이션 위젯을 구성합니다.
305
[글상자] lib/satrunLoading.dart
(...생략...)
@override
Widget build(BuildContext context) {
return AnimatedBuilder(
animation: _animationController,
builder: (context, child) {
return SizedBox(
width: 100,
height: 100,
child: Stack(
children: <Widget>[
Image.asset(
'repo/images/circle.png',
width: 100,
height: 100,
),
Center(
child: Image.asset(
'repo/images/sunny.png',
width: 30,
height: 30,
),
),
Padding(
padding: EdgeInsets.all(5),
child: Transform.rotate(
angle: _animation.value,
origin: Offset(35, 35), // 회전의 기준점 지정하기
child: Image.asset(
'repo/images/saturn.png',
width: 20,
height: 20,
),),)
],),);
},);
}
(...생략...)
[글상자 끝]
306
앞의 코드에서는 Stack이라는 위젯을 사용했습니다. Stack은 위젯을 겹쳐서 구성할 수 있는데 스택 자료구조의 특성상 먼저 넣을수록 뒤에 놓입니다. 따라서 원을 먼저 선언하고 이어서 태양, 토성 순서로 배치합니다.
Transform.rotate() 함수에서는 origin에 Offset을 지정하는 것을 볼 수 있습니다. origin은 회전의 기준점을 의미합니다. 토성 이미지의 크기가 가로세로 20픽셀이므로 이미지의 중심은 (10,10)입니다. 그런데 패딩값을 5로 설정했으므로 토성의 중심부는 (15,15)가 됩니다. 여기에서 가로세로 35픽셀만큼 오프셋한 곳을 기준으로 삼으면 X축 50, Y축 50이 됩니다. 즉, 토성 이미지는 태양으로부터 35픽셀 떨어져서 회전합니다.
[그림 11-4] 오프셋 설정에 대한 좌표


[그림 끝]
[4단계] 그다음 start(), stop() 함수를 만들어서 애니메이션을 시작하고 멈출 수 있게 합니다.
[글상자] saturnLoading.dart
(...생략...)
class SaturnLoading extends StatefulWidget {
(...생략...)
void start() {
_saturnLoading.start();
}
void stop() {
_saturnLoading.stop();
}
}
class _SaturnLoading extends State<SaturnLoading>
with SingleTickerProviderStateMixin {
(...생략...)
void stop() {
_animationController.stop(canceled: true);
307
}
void start() {
_animationController.repeat();
}
}
[글상자 끝]
[5단계] 앞에서 정의한 애니메이션을 보여줄 인트로 화면을 만들어 보겠습니다. lib 폴더에 intro.dart 파일을 새로 만듭니다. IntroPage 클래스를 만든 후 앱이 시작될 때 앞에서 정의한 애니메이션이 동작하는 인트로 화면이 보이다가 5초 후 메인 화면으로 넘어가는 코드를 작성합니다.
[글상자] lib/intro.dart
import 'package:flutter/material.dart';
import 'package:animation_example/saturnLoading.dart';
import 'dart:async';
import 'main.dart';
class IntroPage extends StatefulWidget {
@override
State<StatefulWidget> createState() => _IntroPage();
}
class _IntroPage extends State<IntroPage> {
@override
void initState() {
super.initState();
loadData();
}
Future<Timer> loadData() async { // 5초 후 메인 화면으로 이동하는 함수 정의
return Timer(Duration(seconds: 5), onDoneLoading); // 5초 후 메인 화면으로 이동하는 함수 정의
} // 5초 후 메인 화면으로 이동하는 함수 정의
onDoneLoading() async { // 5초 후 메인 화면으로 이동하는 함수 정의
Navigator.of(context) // 5초 후 메인 화면으로 이동하는 함수 정의
.pushReplacement(MaterialPageRoute(builder: (context) => AnimationApp())); // 5초 후 메인 화면으로 이동하는 함수 정의
} // 5초 후 메인 화면으로 이동하는 함수 정의
308
@override
Widget build(BuildContext context) {
return Scaffold(
body: Container(
child: Center(
child: Column(
children: <Widget>[
Text('애니메이션 앱'),
SizedBox(
height: 20,
),
SaturnLoading() // 애니메이션 불러오기
],
mainAxisAlignment: MainAxisAlignment.center,
),),),);
}
}
[글상자 끝]
[6단계] 이제 main.dart 파일에서 home 부분을 IntroPage()로 변경한 후 앱을 빌드합니다. 앱을 실행하면 토성이 태양 주위를 도는 애니메이션이 동작하는 인트로 화면이 나오고 5초 후에 메인 화면으로 변경되는 것을 확인할 수 있습니다.
[글상자] lib/main.dart
import 'intro.dart';
(...생략...)
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
(...생략...)
home: IntroPage(),
);
(...생략...)
[글상자 끝]
[그림] 실행 결과


애니메이션 앱
[그림 끝]
309
11-3 스크롤 시 역동적인 앱바 만들기
이번 절에서는 화면을 스크롤할 때 앱바의 크기를 변경하는 애니메이션을 구현해 보겠습니다. 이처럼 앱바나 리스트를 역동적으로 만들고 싶을 때는 슬리버(sliver)라는 위젯을 이용합니다.
[Do it! 실습] 슬리버를 사용한 스크롤뷰 만들기
이번 실습에서는 SliverAppBar, SliverList, SliverGrid 등 세 가지 슬리버를 사용해 확장 앱바와 리스트, 그리드가 차례로 포함된 스크롤뷰를 만들어 보겠습니다.
[1단계] 먼저 lib 폴더에 sliverPage.dart 파일을 새로 만듭니다. 그리고 StatefulWidget을 상속받는 SliverPage 클래스를 만들어 기본 골격을 갖춥니다.
[글상자] lib/sliverPage.dart
import 'package:flutter/material.dart';
class SliverPage extends StatefulWidget {
@override
State<StatefulWidget> createState() => _SliverPage();
}
class _SliverPage extends State<SliverPage> {
@override
Widget build(BuildContext context) {
return Scaffold(
body: CustomScrollView(
slivers: <Widget>[
SliverAppBar(
// 앱바의 높이 설정
expandedHeight: 150.0,
310
// SliverAppBar 공간에 어떤 위젯을 만들지 설정
flexibleSpace: FlexibleSpaceBar(
title: Text('Sliver Example'),
background: Image.asset('repo/images/sunny.png'),
),
backgroundColor: Colors.deepOrangeAccent,
),],),);
}
}
[글상자 끝]
body에 사용한 CustomScrollView는 슬리버를 사용해 사용자 정의 스크롤 효과를 만드는 위젯입니다. CustomScrollView의 slivers에 위젯을 지정하면 확장 앱바, 리스트, 그리드와 같은 다양한 스크롤 효과를 만들 수 있습니다.
먼저 CustomScrollView의 slivers에 SliverAppBar를 사용해 확장 앱바를 만듭니다. 슬리버가 들어가는 위젯을 이용할 때는 컨테이너나 텍스트 등 기본적인 위젯을 바로 사용할 수 없고 slivers 인자로 위젯을 묶어 주어야 합니다.
CustomScrollView의 slivers에 첫 번째 위젯으로 지정한 SliverAppBar는 특수한 위젯이라서 일반 칼럼이나 리스트뷰에서는 사용할 수 없습니다. 오직 CustomScrollView에서만 사용할 수 있으며 스크롤에 따라 높이가 달라지거나 다른 위젯 위에 표시되도록 스크롤뷰에 통합됩니다.
SliverAppBar에서는 expandedHeight를 이용해 앱바의 최대 높이를 설정하고 flexibleSpace를 이용해 유연하게 조절되는 공간을 만든 다음 FlexibleSpaceBar를 넣었습니다. FlexibleSpaceBar 위젯은 머티리얼 디자인 앱바를 확장하거나 축소, 스트레칭해 줍니다. 여기에는 제목(title)과 배경(background) 이미지를 설정해 스크롤에 따라 크기가 조절되도록 했습니다.
[2단계] main.dart 파일을 열고 _AnimationApp 클래스의 build() 함수에서 <이동하기> 버튼 아래에 SliverPage로 이동하는 버튼을 추가합니다.
311
[글상자] lib/main.dart
import 'sliverPage.dart';
(...생략...)
RaisedButton(
onPressed: () {
Navigator.of(context).push(
MaterialPageRoute(builder: (context) => SliverPage()));
},
child: Text('페이지 이동'),
),
(...생략...)
[글상자 끝]
[그림] 실행 결과


Sliver Example
[그림 끝]
앱을 빌드 후 실행합니다. <페이지 이동> 버튼을 클릭하면 다음과 같은 화면을 볼 수 있습니다.
[3단계] 그런데 지금은 본문에 스크롤할 만한 위젯이 없어서 스크롤이 되지 않습니다. 이제 스크롤되는 위젯을 넣어 보겠습니다. 먼저 텍스트를 전달하면 카드 위젯을 만들어 주는 customCard() 함수를 _SliverPage 클래스에 추가합니다.
[글상자] lib/sliverPage.dart
(...생략...)
Widget customCard(String text) {
return Card(
child: Container(
height: 120,
312
child: Center(
child: Text(
text,
style: TextStyle(fontSize: 40),
)),
),
);
}
(...생략...)
[글상자 끝]
[4단계] CustomScrollView의 slivers에 SliverList와 SliverGrid 위젯을 추가합니다. 이때 SliverChildListDelegate를 선언해 배열 안에 원하는 위젯을 넣을 수 있도록 함수를 참조하는 델리게이트를 만들어 줍니다.
[글상자] lib/sliverPage.dart
(...생략...)
body: CustomScrollView(
slivers: <Widget>[
SliverAppBar( ...생략... ),
SliverList(
delegate: SliverChildListDelegate([
// 위젯 넣을 곳
])),
SliverGrid(
delegate: SliverChildListDelegate([
// 위젯 넣을 곳
]),
gridDelegate:
SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2)),
],
),
(...생략...)
[글상자 끝]
313
[5단계] 위젯을 넣을 곳에 아까 만들어 두었던 customCard() 함수를 호출해 카드 위젯을 배치합니다.
[글상자] lib/sliverPage.dart
(...생략...)
body: CustomScrollView(
slivers: <Widget>[
SliverAppBar( ...생략... ),
SliverList(
delegate: SliverChildListDelegate([
customCard('1'),
customCard('2'),
customCard('3'),
customCard('4'),
])),
SliverGrid(
delegate: SliverChildListDelegate([
customCard('1'),
customCard('2'),
customCard('3'),
customCard('4'),
]),
gridDelegate:
SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2)),
],
),
(...생략...)
[글상자 끝]
이제 빌드한 후 슬리버 화면을 보면 다음처럼 리스트와 그리드가 표시되는 것을 볼 수 있습니다. 그리고 리스트를 쓸어 올려 스크롤을 내리면 앱바 영역이 점점 줄다가 사라지는 것을 확인할 수 있습니다.
314
[그림] 실행 결과


Sliver Example: 1, 2, 3, 4
Sliver Example: 1, 2, 3, 4, 1, 2
1, 2, 3, 4, 1, 2
[그림 끝]
[Do it! 실습] 위젯을 구분하는 머리말 추가하기
이번에는 앞에서 만든 리스트와 그리드를 구분하는 머리말을 추가해 보겠습니다. SliverPersistentHeader를 이용하면 슬리버 위젯별로 헤더를 지정할 수 있습니다. 그런데 SliverPersistentHeader를 사용하려면 SliverPersistentHeaderDelegate라는 델리게이트가 필요합니다.
[1단계] 먼저 sliverPage.dart 파일을 열고 SliverPersistentHeaderDelegate를 상속받는 _HeaderDelegate 클래스를 이용해 델리게이트를 만들어 줍니다. math 패키지가 제공하는 max() 함수를 사용하기 위해 import 문도 추가합니다.
[글상자] lib/sliverPage.dart
import 'dart:math' as math;
(...생략...)
class _HeaderDelegate extends SliverPersistentHeaderDelegate {
final double minHeight;
final double maxHeight;
315
final Widget child;
_HeaderDelegate({
@required this.minHeight,
@required this.maxHeight,
@required this.child,
});
@override
Widget build(BuildContext context, double shrinkOffset, bool overlapsContent) {
return SizedBox.expand(child: child);
}
@override
double get maxExtent => math.max(maxHeight, minHeight);
@override
double get minExtent => minHeight;
@override
bool shouldRebuild(_HeaderDelegate oldDelegate) {
return maxHeight != oldDelegate.maxHeight ||
minHeight != oldDelegate.minHeight ||
child != oldDelegate.child;
}
}
[글상자 끝]
_HeaderDelegate 클래스에서는 4개의 함수를 재정의했습니다. build() 함수에는 머리말을 만들 때 사용할 위젯을 배치합니다. maxExtent() 함수에는 해당 위젯의 최대 높이를 설정합니다. math.max() 함수를 이용해 가장 높은 값을 설정했습니다. minExtent() 함수에는 가장 작은 높이를 설정합니다. 이 높이 이하로는 머리말의 크기가 줄어들지 않습니다.
마지막으로 shouldRebuild() 함수에는 위젯을 계속 그릴 것인지를 정합니다. 만약 maxHeight나 minHeight, child가 달라진다면 true를 반환해 계속 다시 그릴 수 있게 설정합니다.
316
[2단계] 이제 앞의 실습에서 작성한 SliverList와 SliverGrid 위에 SliverPersistentHeader 위젯을 추가합니다. 그리고 슬리버 앱바에 pinned라는 옵션을 true로 설정해 앱바가 사라지지 않고 최소의 크기로 고정되도록 합니다.
[글상자] lib/sliverPage.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
body: CustomScrollView(
slivers: <Widget>[
SliverAppBar(
(...생략...)
backgroundColor: Colors.deepOrangeAccent,
pinned: true,
),
SliverPersistentHeader(
delegate: _HeaderDelegate(
minHeight: 50,
maxHeight: 150,
child: Container(
color: Colors.blue,
child: Center(
child: Column(
children: <Widget>[
Text(
'list 숫자',
style: TextStyle(fontSize: 30),
),
],
mainAxisAlignment: MainAxisAlignment.center,
),
),
)),
pinned: true,
),
SliverList( ...생략... ),
SliverPersistentHeader(
delegate: _HeaderDelegate(
317
minHeight: 50,
maxHeight: 150,
child: Container(
color: Colors.blue,
child: Center(
child: Column(
children: <Widget>[
Text(
'그리드 숫자',
style: TextStyle(fontSize: 30),
),
],
mainAxisAlignment: MainAxisAlignment.center,
),
),
)),
pinned: true,
),
SliverGrid( ...생략... ),
],),);
}
class _HeaderDelegate extends SliverPersistentHeaderDelegate {
(...생략...)
}
[글상자 끝]
[그림] 실행 결과


Sliver Example - list 숫자: 1, 2, 3
Sliver Example - list 숫자: 3, 4, 그리드 숫자: 1, 2
[그림 끝]
이제 앱을 빌드하고 실행합니다. 슬리버 화면에서 리스트를 스크롤해 보면 앱바가 사라지지 않고 고정되는 것을 확인할 수 있습니다. 그리고 리스트와 그리드가 나오기 전에 파랑 바탕의 머리말이 표시되고 스크롤하면 앱바처럼 줄어들다가 고정되는 것을 확인할 수 있습니다.
318
참고로 리스트를 빌더 형태로 생성할 수도 있습니다. 이때는 다음처럼 SliverChildBuilderDelegate를 사용합니다.
[글상자]
SliverList(
delegate: SliverChildBuilderDelegate((context, index) {
return Container(
child: customCard('list count : $index'),
);
}, childCount: 10)),
[글상자 끝]
[그림] 실행 결과


Sliver Example - list 숫자, 그리드 숫자: 3, 4, list count : 0, list count : 1, list count : 2
[그림 끝]
지금까지 애니메이션을 적용한 앱을 만들어 보았습니다. 애니메이션은 수학적인 계산과 상상이 필요한 부분입니다. 계산이나 작동 시간이 조금만 이상해도 어울리지 않는 느낌이 들기 때문입니다. 또한 애니메이션을 사용하면 그만큼 앱의 동작이 느려지므로 필요한 순간에만 사용하는 것이 좋습니다.
319
12 네이티브 API와 통신하기
플러터 패키지는 지금도 꾸준하게 만들어지고 있지만 운영체제별 네이티브 API를 완전히 대체할 수는 없습니다. 따라서 플러터 패키지와 각 운영체제에서 제공하는 API를 적절하게 혼합해서 사용하면 좀 더 완성도 높은 앱을 개발할 수 있습니다. 또한 기존의 네이티브 앱을 플러터 앱으로 변환하고자 할 때도 이번 장에서 다루는 내용을 활용할 수 있습니다.
12-1 안드로이드 네이티브와 통신하기
12-2 안드로이드 네이티브와 데이터 주고받기
320
12-1 안드로이드 네이티브와 통신하기
플러터로 앱을 개발할 때는 다양한 패키지를 사용합니다. 그런데 원하는 기능의 패키지가 없거나 버전이 낮아서 사용하기가 불안할 때도 있습니다. 예를 들면 기기 자체의 정보라든지 배터리 정보, 또는 운영체제에 맞게 개발된 오픈소스를 사용할 때도 마찬가지입니다. 이럴 때는 어쩔 수 없이 네이티브 언어로 작성된 API를 이용해야 합니다.
각 모바일 운영체제는 저마다 고유한 기능을 구현해 놓은 API를 제공합니다. 이 API는 안드로이드의 경우 자바나 코틀린, iOS의 경우 오브젝티브-C나 스위프트로 작성되어 있습니다. 이처럼 각 모바일 운영체제에 최적화된 언어로 작성된 소스를 네이티브(native)라고 합니다.
[그림 12-1] 안드로이드 API 소개(developer.android.com/about/versions/11/features?hl=ko)


[그림 끝]
플러터는 이러한 운영체제별 API를 메시지 전달 방식으로 사용할 수 있도록 지원합니다. 이번 절에서는 플러터 앱에서 안드로이드 네이티브와 통신하는 방법을 살펴봅니다.
이 책에서는 지면상 iOS 앱 개발 부분은 다루지 않지만 iOS 네이티브와 통신하는 방법도 안드로이드와 크게 다르지 않습니다. 따라서 플러터가 네이티브 API와 어떻게 통신하는지를 중심으로 살펴보면 iOS 앱 개발을 염두에 둔 독자에게도 충분히 도움이 될 것입니다. 더불어 이번 장 마지막에 iOS용 프로젝트 전체 소스가 있는 URL도 함께 제공합니다.
321
플러터 앱이 운영체제별 API와 통신하는 방법
그런데 다트 언어를 사용하는 플러터에서 운영체제별 네이티브 소스로 작성된 API를 어떻게 사용할 수 있을까요? 다음은 플러터 앱이 운영체제별 API를 사용하는 구조를 나타낸 그림입니다.
[그림 12-2] 플러터 앱의 운영체제별 API 사용 아키텍처


[전체 흐름]
플러터 앱(클라이언트) ↔ iOS 호스트, 안드로이드 호스트
[세부 내용]
1. 플러터 앱(클라이언트): State ←“MethodChannel”, →“FlutterMethodChannel” iOS 호스트
1) iOS 호스트: AppDelegate →“FlutterViewController” iOS platform APIs
2) iOS 호스트: AppDelegate →“FlutterViewController” 3rd-Party APIs for IOS
2. 플러터 앱(클라이언트): State ←“MethodChannel”, → “MethodChannel” 안드로이드 호스트
1) 안드로이드 호스트: Activity →“FlutterView” Android platform APIs
2) 안드로이드 호스트: Activity →“FlutterView” 3rd-Party APIs for Android
[그림 끝]
(출처: flutter-ko.dev/docs/development/platform-integration/platform-channels)
플러터 앱은 플랫폼 채널(platform channel)을 통해서 안드로이드나 iOS의 호스트(host)[각주*]에 메시지를 전달합니다. 메시지를 전달받은 호스트는 네이티브 언어를 사용해서 운영체제별 API를 호출하고 플러터 앱에 응답을 보냅니다. 즉, 플랫폼 채널이라는 창구를 이용해 운영체제별 호스트와 통신함으로써 API를 사용할 수 있습니다.
[각주*] 호스트는 양방향으로 데이터를 주고받는 통신 장치라고 생각하면 쉽습니다.[각주 끝]
322
이때 다트의 자료형을 각 플랫폼에서 조금씩 다르게 주고받습니다. 따라서 네이티브 API와 통신할 때는 기본적으로 플랫폼별 데이터 구조를 먼저 알아야 합니다.
[표 12-1] 다트 자료형에 대응하는 플랫폼별 자료형
타입

다트

안드로이드

iOS

공백

null

null

nil

참, 거짓

bool

java.lang.Boolean

NSNumber numberWithBool

정수형

int

java.lang.Integer

NSNumber numberWithInt

java.lnag.Long

NSNumber numberWithLong

부동소수점

double

java.lang.Double

NSNumber numberWithDouble

문자열

String

java.lang.String

NSString

바이트 배열

Uint8List

byte[]

FlutterStandardTypedData typedDataWithBytes

정수형 배열

Int32List

int[]

FlutterStandardTypedData typedDataWithInt32

Int64List

long[]

FlutterStandardTypedData typedDataWithInt64

부동소수점 배열

Float64List

double[]

FlutterStandardTypedData typedDataWithFloat64

List형 자료구조

List

java.util.ArrayList

NSArray

Map형 자료구조

Map

java.util.HashMap

NSDictionary

[Do it! 실습] 플러터 앱에서 네이티브 함수 호출하기
안드로이드 API와 통신하는 플러터 앱을 만들어 보겠습니다. 이번 실습에서는 플러터 앱에서 안드로이드의 네이티브 함수를 호출하는 부분을 완성하고 다음 실습에서 이 요청에 대한 응답을 받아서 실행할 안드로이드 네이티브 함수를 작성해 보겠습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] 먼저 native_example이라는 이름으로 새로운 프로젝트를 만듭니다. 그리고 main.dart 파일을 다음처럼 수정합니다.
[글상자] lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter/cupertino.dart';
import 'dart:io';
323
void main() => runApp(MyApp());
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
if (Platform.isIOS) {
// 운영체제가 iOS면 실행
return CupertinoApp(
home: CupertinoNativeApp(),
);
} else {
// 이외의 운영체제면 실행
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(
primarySwatch: Colors.blue,
),
home: NativeApp(),
);
}
}
}
[글상자 끝]
플러터는 Platform 객체를 이용해 이 앱이 실행 중인 운영체제를 알 수 있습니다. Platform 객체를 사용하려면 dart:io를 포함해야 합니다. 만약 iOS에서 실행하면 CupertinoApp을 반환하고, 안드로이드에서 실행하면 MaterialApp을 반환하도록 작성했습니다. 그리고 home에 각각 CupertinoNativeApp과 NativeApp 클래스를 실행하도록 했습니다.
[2단계] 앱을 실행한 운영체제가 안드로이드일 때 실행할 NativeApp 클래스를 작성하고, iOS일 때 실행할 CupertinoNativeApp 클래스도 작성합니다[각주*]. 이 절에서는 안드로이드와 통신하는 기능을 만들 것이므로 NativeApp 클래스에서 반환하는 _NativeApp 클래스를 작성합니다.
[각주*] iOS와 통신하는 기능은 이 장의 마지막에 별도의 URL로 제공합니다.[각주 끝]
324
[글상자] lib/main.dart
import 'package:flutter/services.dart';
(...생략...)
class CupertinoNativeApp extends StatefulWidget {
@override
State<StatefulWidget> createState() {
return null;
}
}
class NativeApp extends StatefulWidget {
@override
State<StatefulWidget> createState() => _NativeApp();
}
class _NativeApp extends State<NativeApp> {
static const platform = const MethodChannel('com.flutter.dev/info');
String _deviceInfo = 'Unknown info';
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Natvie 통신 예제'),
),
body: Container(
child: Center(
child: Text(
_deviceInfo,
style: TextStyle(fontSize: 30),
),
),
),
floatingActionButton: FloatingActionButton(
onPressed: () {
_getDeviceInfo();
},
325
child: Icon(Icons.get_app),
),
);
}
}
[글상자 끝]
_NativeApp 클래스에서는 안드로이드와의 통신 채널로 사용할 MethodChannel을 platform이라는 이름의 상수로 선언합니다. 메서드 채널을 이용하려면 플러터의 services 라이브러리를 포함해야 합니다. MethodChannel 괄호 안의 문자열은 어떤 통신을 할 것인지를 구분하는 키값입니다. 이 값을 통해서 플러터 앱과 안드로이드 간의 메시지를 주고받을 수 있습니다.
이어서 선언한 문자열 변수 _deviceInfo는 안드로이드에서 전달받은 기기 정보를 저장하는데 사용할 것입니다. 플로팅 버튼을 누르면 기기 정보를 가져올 _getDeviceInfo() 함수를 호출하고 스캐폴드를 이용해 이를 받아 화면에 표시합니다.
[3단계] _NativeApp 클래스에 기기 정보를 가져오는 _getDeviceInfo() 함수를 만듭니다. 이 함수는 안드로이드와 통신하는 함수여서 상황에 따라 지연이 발생할 수 있으므로 비동기로 선언합니다.
[글상자] lib/main.dart
(...생략...)
Future<void> _getDeviceInfo() async {
String deviceInfo;
try {
final String result = await platform.invokeMethod('getDeviceInfo');
deviceInfo = 'Device info : $result';
} on PlatformException catch (e) {
deviceInfo = 'Failed to get Device info: '${e.message}'.';
}
setState(() {
_deviceInfo = deviceInfo;
});
}
(...생략...)
[글상자 끝]
326
[그림] 실행 결과


Native 통신 예제 - Unknown info
[그림 끝]
platform.invokeMethod() 함수는 메서드 채널로 연결된 안드로이드에서 네이티브 API를 호출해 줍니다. 이 함수의 인자로 전달한 'getDeviceInfo'는 안드로이드 네이티브 소스에서 호출할 함수 이름입니다. 이렇게 가져온 기기 정보를 deviceInfo 변수에 넣고 setState() 함수에서 _deviceInfo에 저장합니다.
여기까지 작성한 후 앱을 빌드 후 실행하면 다음과 같은 화면을 볼 수 있습니다. 아직 기기의 정보를 받아올 수 없어서 _deviceInfo 변수의 초깃값인 ‘Unknown info’가 출력됩니다.
[Do it! 실습] 네이티브 소스 수정하기
앞의 실습에서 기기 정보를 받아오는 플러터 코드는 모두 작성했지만 ‘Unknown info’만 출력된 것을 확인했습니다. 이 결과는 플러터 앱에서 안드로이드 함수를 호출했지만 안드로이드가 응답하지 않았다는 이야기입니다. 이번 실습에서는 안드로이드의 네이티브 소스를 수정해 플러터의 요청에 응답하도록 만들어 보겠습니다.
[1단계] 안드로이드의 네이티브 소스를 수정하려면 현재의 플러터 개발 환경을 안드로이드 개발 환경으로 바꿔 주어야 합니다. 안드로이드 스튜디오에서 [File → Open]을 선택하고 native_example 프로젝트 아래에 있는 android 폴더를 선택한 다음 <OK>를 누릅니다.
[그림 12-3] 안드로이드 프로젝트 열기


android - [OK]
[그림 끝]
327
다음과 같은 팝업 창이 나오면 <New Window>를 클릭해 새 창에서 프로젝트를 엽니다.
[그림 12-4] 새 창에서 열기


New Window
[그림 끝]
그래들(Gradle)[각주*]이 빌드 구성을 완료하면 탐색 창에 Android라는 이름으로 프로젝트 구성이 보입니다. 이 상태로 프로젝트를 빌드하고 실행해도 앞에서 플러터로 개발한 앱과 똑같은 앱이 실행됩니다.
[각주*] 안드로이드가 사용하는 빌드 자동화 시스템입니다.[각주 끝]
[그림 12-5] 안드로이드 프로젝트 구성 완료


Android
[그림 끝]
[아하!] 그래들 시스템의 빌드 구성
안드로이드 스튜디오에서 안드로이드 프로젝트를 열면 왼쪽 아래 상태 표시줄에 그래들이 동기화를 마쳤다는 메시지가 나올 때까지 기다려야 합니다.
[그림 12-6] 그래들 동기화 완료


TODO, Terminal, Build, Logcat
Gradle sync finish in 2 m 12 s 506 ㎳ (5 minutes ago)
[그림 끝]
이 작업은 안드로이드의 그래들 시스템이 프로젝트에 필요한 패키지를 내려받아 빌드할 수 있게 구성하는 것입니다. 이 작업은 컴퓨터의 성능이나 네트워크 상태에 따라 오래 걸릴 수도 있습니다.
[아하! 끝]
[2단계] 프로젝트 탐색 창에서 app > java > com.rollcake.native_example > MainActivity 파일을 선택합니다. 이 파일은 확장자가 .kt인 코틀린 소스 파일입니다.
328
[그림 12-7] 안드로이드의 MainActivity 파일 열기


MainActivity
[그림 끝]
[아하!] 자바 파일이 아닌 코틀린 파일인 이유
플러터의 main.dart처럼 안드로이드는 MainActivity로부터 시작합니다. MainActivity는 플러터 프로젝트를 만들 때 플랫폼 채널의 언어 선택 단계에서 <Include Kotlin support for Android code> 옵션을 체크하면 코틀린 파일로 만들어집니다. 만약 이 옵션을 해제하면 자바 파일로 만들어지지만 구글에서는 코틀린 파일로 만들기를 추천하고 있어서 이 옵션이 기본으로 체크되어 있습니다.
[그림 12-8] 코틀린 지원 선택


? Include Kotlin support for Android code
[그림 끝]
[아하! 끝]
[3단계] MainActivity.kt 파일을 열고 플러터 앱의 요청에 응답하는 부분을 작성해 보겠습니다. 먼저 이 파일에서 사용할 라이브러리를 불러오는 코드를 작성합니다.
329
[글상자] MainActivity.kt(안드로이드 프로젝트)
package com.rollcake.native_example
import android.os.Build
import androidx.annotation.NonNull
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel
[글상자 끝]
package 문은 이 프로젝트의 패키지 이름을 선언한 것입니다. import 문에서 Build와 NonNull은 안드로이드에서 제공하는 기능을 사용하기 위한 것이고, 나머지 세 패키지는 플러터 프레임워크가 제공하는 기능을 사용하기 위한 것입니다.
[4단계] 이어서 MainActivity 클래스를 다음처럼 수정합니다.
[글상자] MainActivity.kt(안드로이드 프로젝트)
class MainActivity : FlutterActivity() {
private val CHANNEL = "com.flutter.dev/info"
override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
super.configureFlutterEngine(flutterEngine)
MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL)
.setMethodCallHandler { call, result ->
if (call.method == "getDeviceInfo") {
val deviceInfo = getDeviceInfo()
result.success(deviceInfo)
}
}
}
}
[글상자 끝]
CHANNEL 변수를 선언하고 플러터 프로젝트에서 작성했던 메서드 채널의 키값으로 초기화합니다.
330
[글상자] 플러터 프로젝트에 작성한 메서드 채널의 키값과 요청 코드
static const platform = const MethodChannel('com.flutter.dev/info');
(...생략...)
platform.invokeMethod('getDeviceInfo');
[글상자 끝]
그리고 configureFlutterEngine()이라는 함수를 재정의해서 메서드 채널로 들어오는 요청에 응답하는 코드를 작성합니다. 여기서는 'getDeviceInfo'라는 요청을 받으면 기기의 정보를 받아오는 getDeviceInfo() 함수를 호출하고 그 반환값을 result.success를 이용해 플러터 앱에 전달합니다. 만약 중간에 오류가 발생할 때를 대비해 result.error(String msg)를 이용해 오류 메시지를 전달할 수도 있습니다.
[5단계] 이어서 MainActivity 클래스에 기기 정보를 반환하는 getDeviceInfo() 함수를 추가합니다. 이 함수는 현재 앱이 실행 중인 안드로이드 기기의 정보를 가져와서 반환합니다.
[글상자] MainActivity.kt(안드로이드 프로젝트)
(...생략...)
private fun getDeviceInfo(): String {
val sb = StringBuffer()
sb.append(Build.DEVICE + "\n")
sb.append(Build.BRAND + "\n")
sb.append(Build.MODEL + "\n")
return sb.toString()
}
[글상자 끝]
[그림] 실행 결과


Native 통신 예제
Device info:
Generic_x86_arm
google
sdk_gphone_x86
[그림 끝]
이제 플러터 프로젝트로 돌아와서 앱을 다시 빌드한 후 실행합니다. 앱이 실행되고 플로팅 버튼을 누르면 현재 실행 중인 기기의 정보가 표시되는 것을 확인할 수 있습니다.
331
12-2 안드로이드 네이티브와 데이터 주고받기
앞 절에서는 플러터와 안드로이드가 어떻게 통신하는지 살펴보았습니다. 이번에는 이러한 통신 방식을 이용해 플러터 앱에서 데이터를 보내고 이 데이터를 네이티브 소스에서 받아서 처리 후 반환하는 앱을 만들어 보겠습니다.
[Do it! 실습] 네이티브 소스로 인코딩/디코딩 구현하기
인코딩(encoding)이란 데이터의 형식을 보안이나 처리 속도, 공간 절약 등을 위해서 다른 형식으로 변환하는 것을 의미합니다. 그리고 인코딩된 데이터를 다시 원래 데이터로 되돌리는 것을 디코딩(decoding)이라고 합니다.
시스템 간의 동영상이나 이미지, 텍스트 등을 주고받을 때 이러한 인코딩/디코딩 기술을 이용합니다. 그중 Base64는 64개의 안전한 출력 문자만 사용해 서로 다른 시스템 간에 똑같은 데이터를 주고받을 수 있는 인코딩 방식입니다.
이번 실습에서는 플러터에서 문자열을 보내면 안드로이드에서 Base64로 인코딩이나 디코딩한 후 반환하는 기능을 구현해 보겠습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] 먼저 lib 폴더에 sendDataExample.dart라는 이름으로 새로운 파일을 만듭니다.
_SendDataExample 클래스에는 텍스필드 위젯을 이용해 사용자로부터 입려받은 값을 안드로이드 네이티브 소스에 전달하고 그 결괏값을 받아서 텍스트 위젯으로 보여주는 화면을 만들겠습니다.
[글상자] lib/sendDataExample.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
class SendDataExample extends StatefulWidget {
@override
State<StatefulWidget> createState() => _SendDataExample();
}
332
class _SendDataExample extends State<SendDataExample> {
static const platform = const MethodChannel('com.flutter.dev/encrypto');
TextEditingController controller = new TextEditingController();
String _changeText = 'Nothing';
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Send Data Example'),
),
body: Container(
child: Center(
child: Column(
children: <Widget>[
TextField(
controller: controller,
keyboardType: TextInputType.text,
),
SizedBox(
height: 20,
),
Text(
_changeText,
style: TextStyle(fontSize: 20),
)
],
mainAxisAlignment: MainAxisAlignment.center,
),),),
floatingActionButton: FloatingActionButton(
onPressed: () {
_sendData(controller.value.text);
},
child: Text('변환'),
),
);
}
333
Future<void> _sendData(String text) async {
final String result = await platform.invokeMethod('getEncrypto', text);
print(result);
setState(() {
_changeText = result;
});
}
}

text → 네이티브 소스에 전달할 데이터
[글상자 끝]
이번에는 메서드 채널 이름을 'com.flutter.dev/encrypto'로 지정했습니다. 그리고 해당 채널에서 'getEncrypto'라는 이름으로 메서드를 호출하도로 작성했습니다. 네이티브 소스에 데이터를 보낼 때는 invokeMethod() 함수의 두 번째 인자로 전달합니다.
[아하!] 여러 개의 값을 전달하고 반환받는 방법
만약 전달할 데이터가 여러 개라면 invokeMethod() 함수의 두 번째 인자를 ['text1', 'text2']와 같은 형태로 대괄호로 묶어 줍니다. 또한, 네이티브 소스로부터 여러 개의 반환값을 받으려면 invokeMethod()가 아닌 invokeListMethod() 또는 invokeMapMethod() 함수를 이용합니다. 각각 List와 Map 형태로 여러 값을 반환받을 수 있습니다. 이때는 네이티브 소스에서도 List나 Map 형태로 반환해야 합니다.
[아하! 끝]
[2단계] 플러터 코드를 작성했으니 이번에는 안드로이드 프로젝트를 열어서 MainActivity.kt 파일을 수정해 보겠습니다. 앞의 실습에서 작성했던 코드에 이어서 CHANNEL2 변수를 선언합니다.
[글상자] MainActivity.kt(안드로이드 프로젝트)
import android.util.Base64 // Base64 인코딩을 사용하기 위한 라이브러리
(...생략...)
class MainActivity : FlutterActivity() {
private val CHANNEL = "com.flutter.dev/info"
private val CHANNEL2 = "com.flutter.dev/encrypto"
(...생략...)

"com.flutter.dev/encrypto" → 플러터 프로젝트에 작성한 메서드 채널의 키값과 일치
[글상자 끝]
334
그리고 configureFlutterEngine() 함수 안에 MethodChannel을 이용해 플러터에서 요청한 getEncrypto 메서드 핸들러를 작성합니다.
[글상자] MainActivity.kt(안드로이드 프로젝트)
(...생략...)
MethodChannel(flutterEngine.dartExecutor.binaryMessenger,
CHANNEL2).setMethodCallHandler { call, result ->
if (call.method == "getEncrypto") {
val data = call.arguments.toString().toByteArray();
val changeText = Base64.encodeToString(data, Base64.DEFAULT)
result.success(changeText)
}
}
(...생략...)

call.arguments → 플러터에서 보낸 데이터
Base64.encodeToString(data, Base64.DEFAULT) → 데이터를 Base64로 인코딩하기
[글상자 끝]
플러터가 전달한 데이터는 call.arguments로 사용할 수 있습니다. 그런데 arguments는 모든 형태의 데이터를 전달받을 수 있도록 Any 객체로 되어 있습니다. 그래서 arguments에 toString().toByteArray() 함수를 호출해서 문자열을 바이트 배열로 변환했습니다. 이 값을 data 변수에 저장하고 Base64.encodeToString() 함수를 이용해 인코딩합니다. 그리고 인코딩한 값을 result.success() 함수로 플러터에 전달합니다.
[3단계] 다시 플러터 프로젝트에서 main.dart 파일을 열고 MyApp 클래스에서 MaterialApp의 home을 SendDataExample()로 바꿉니다.
[글상자] main.dart
import 'sendDataExample.dart';
(...생략...)
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
if (Platform.isIOS) {
(...생략...)
} else {
return MaterialApp(
335
(...생략...)
home: SendDataExample(),
);
(...생략...)
[글상자 끝]
이제 앱을 빌드하고 실행합니다. 텍스트필드에 문자열을 입력하고 <변환> 버튼을 누르면 텍스트 필드 아래 Base64로 인코딩된 문자열이 표시됩니다.
[그림] 실행 결과


Send Data Example - Nothing, (변환)
Send Data Example - 안녕하세요 flutter, 7JWI64WV7ZWY7IS47JqUIGZsdXR0ZXI=, (변환)
[그림 끝]
[4단계] Base64로 인코딩된 문자열을 다시 디코딩하는 기능도 추가해 봅시다. sendDataExample.dart 파일을 열고 build() 함수에 위젯을 추가합니다.
[글상자] lib/sendDataExample.dart
(...생략...)
class _SendDataExample extends State<SendDataExample> {
static const platform = const MethodChannel('com.flutter.dev/encrypto');
TextEditingController controller = new TextEditingController();
String _changeText = 'Nothing';
336
String _reChangedText = 'Nothing';
(...생략...)
body: Container(
child: Center(
child: Column(
children: <Widget>[
TextField( ...생략... ),
SizedBox( ...생략... ),
Text( ...생략... ),
SizedBox(
height: 20,
),
RaisedButton(
onPressed: () {
_decodeText(_changeText);
},
child: Text('디코딩하기'),
),
SizedBox(
height: 20,
),
Text(
_reChangedText,
style: TextStyle(fontSize: 20),
),
],
mainAxisAlignment: MainAxisAlignment.center,
),),),
(...생략...)
[글상자 끝]
[5단계] <디코딩하기> 버튼을 눌렀을 때 실행할 _decodeText() 함수를 _SendDataExample 클래스 안에 작성합니다.
337
[글상자] lib/sendDataExample.dart
(...생략...)
void _decodeText(String changeText) async {
final String result = await platform.invokeMethod('getDecode', changeText);
setState(() {
_reChangedText = result;
});
}
(...생략...)
[글상자 끝]
네이티브 소스에 전달할 메서드 이름을 'getDecode'라고 하고 인코딩된 문자열이 담긴 changeText를 전달합니다. 그리고 네이티브 소스에서 전달받은 데이터는 최종적으로 _reChangedText에 넣습니다.
[6단계] 안드로이드 프로젝트에서 MainActivity.kt 파일을 열고 'getDecode' 호출에 대응하는 코드를 추가합니다.
[글상자] MainActivity.kt(안드로이드 프로젝트)
(...생략...)
MethodChannel(flutterEngine.dartExecutor.binaryMessenger,
CHANNEL2).setMethodCallHandler { call, result ->
if (call.method == "getEncrypto") {
val data = call.arguments.toString().toByteArray();
val changeText = Base64.encodeToString(data, Base64.DEFAULT)
result.success(changeText)
} else if (call.method == "getDecode") {
val changedText = Base64.decode(call.arguments.toString(), Base64.DEFAULT)
result.success(String(changedText))
}
}
(...생략...)

Base64.encodeToString(data, Base64.DEFAULT) → Base64 데이터를 디코딩하기
[글상자 끝]
338
call.method값이 'getDecode'일 때 문자열을 디코딩하고 이 값을 result.success() 함수로 플러터 앱에 전달하는 코드를 추가했습니다.
이제 앱을 빌드 후 실행합니다. 텍스트필드에 문자열을 입력하고 <변환> 버튼을 눌러 Base64로 인코딩된 값이 표시되면 <디코딩하기> 버튼을 누릅니다. 그러면 버튼 아래 원본 데이터가 출력되는 것을 확인할 수 있습니다.
[그림] 실행 결과


안녕하세요 flutter, (변환) → 7JWI64WV7ZWY7IS47JqUIGZsdXR0ZXI=, [디코딩 하기] → 안녕하세요 flutter
[그림 끝]
[Do it! 실습] 안드로이드 알림 창 출력하기
이번 실습에서는 안드로이드의 네이티브 UI를 이용해 간단한 알림 창을 출력해 보겠습니다.
[1단계] main.dart 파일을 열고 _NativeApp 클래스에 비동기로 동작하는 _showDialog() 함수를 추가합니다. 이 함수는 'com.flutter.dev/dialog'라는 메서드 채널로 'showDialog'를 호출합니다.
[QR 코드] 소스 보기


[QR 코드 끝]
339
[글상자] lib/main.dart
(...생략...)
class _NativeApp extends State<NativeApp> {
String _deviceInfo = 'Unknown info';
static const platform = const MethodChannel('com.flutter.dev/info');
static const platform3 = const MethodChannel('com.flutter.dev/dialog');
(...생략...)
Future<void> _showDialog() async {
try {
await platform3.invokeMethod('showDialog');
} on PlatformException catch (e) {}
}
(...생략...)
[글상자 끝]
[2단계] 이어서 build() 함수의 body에 Column 위젯으로 버튼을 추가하고, 눌렀을 때 _showDialog() 함수를 호출하는 코드를 작성합니다.
[글상자] lib/main.dart
(...생략...)
body: Container(
child: Center(
child: Column(
children: [
Text(
_deviceInfo,
style: TextStyle(fontSize: 30),
),
FlatButton(
onPressed: () {
_showDialog();
},
child: Text('네이티브 창 열기'))
],
),),),
(...생략...)
[글상자 끝]
340
[3단계] 안드로이드 프로젝트에서 MainActivity.kt 파일을 열고 플러터 앱의 호출에 응답하는 코드를 작성합니다.
[글상자] MainActivity.kt(안드로이드 프로젝트)
package com.rollcake.native_example
import android.app.AlertDialog
(...생략...)
class MainActivity : FlutterActivity() {
private val CHANNEL = "com.flutter.dev/info"
private val CHANNEL2 = "com.flutter.dev/encrypto"
private val CHANNEL3 = "com.flutter.dev/dialog"
override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
(...생략...)
MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL3)
.setMethodCallHandler { call, result ->
if (call.method == "showDialog") {
AlertDialog.Builder(this) // 안드로이드 알림 창을 띄우기
.setTitle("Flutter") // 안드로이드 알림 창을 띄우기
.setMessage("네이티브에서 출력하는 창입니다") // 안드로이드 알림 창을 띄우기
.show() // 안드로이드 알림 창을 띄우기
}
}
}
(...생략...)
}
[글상자 끝]
앞의 실습과 같은 패턴으로 채널을 만들고 'showDialog' 호출에 응답하는 코드를 작성합니다. 여기서는 AlertDialog라고 하는 안드로이드 API를 이용해 알림 창을 만들었습니다.
[4단계] 마지막으로 MyApp 클래스의 build() 함수에서 home값을 NativeApp()으로 바꾸고 앱을 빌드합니다.
341
[글상자] lib/main.dart
(...생략...)
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
if (Platform.isIOS) {
(....생략...)
} else {
return MaterialApp(
(...생략...)
home: NativeApp(),
);
(...생략...)
[글상자 끝]
[그림] 실행 결과


Flutter - 네이티브에서 출력하는 창입니다
[그림 끝]
앱을 실행한 후 <네이티브 창 열기>를 클릭하면 안드로이드 네이티브 소스로 작성한 알림 창이 나타나는 것을 확인할 수 있습니다.
지금까지 플러터와 네이티브 소스가 어떻게 통신해 데이터를 주고받는지 살펴봤습니다. 다트 언어를 사용하는 플러터에서 네이티브 언어로 된 API를 사용하려면 서로 데이터를 주고받을 수 있는 연결자가 필요한데 그 역할을 메서드 채널이 해준다고 생각하면 됩니다. 우리는 메서드 채널에 서로를 구분할 수 있는 채널의 키값과 메서드 호출명, 주고 받을 데이터 등만 입력하면 됩니다. 이러한 네이티브와 통신 기능은 플러터 패키지에서 찾는 기능이 없을 때, 기존의 네이티브 소스를 재활용해 개발 시간을 줄이고자 할 때 사용할 수 있습니다.
342
[아하!] iOS 네이티브와 통신하기
플러터와 iOS 네이티브와의 통신도 안드로이드처럼 메서드 채널을 이용하므로 크게 다르지 않습니다. 이 책에서는 지면상 iOS 앱 개발 부분은 다루지 않지만, 이 부분은 기존 iOS 개발자에게 도움이 될 수 있어 별도로 소스를 제공하려고 합니다.
오른쪽 QR코드에 접속하면 플러터에서 두 개의 변수를 보내고 iOS 네이티브에서 두 수를 더해 반환하는 예제의 전체 소스를 확인할 수 있습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[그림] 실행 결과


[그림 끝]
[아하! 끝]
343
13 파이어베이스와 광고 수입 얻기
플러터는 구글에서 만든 프레임워크인 만큼 구글의 다양한 서비스와 쉽게 연동해서 사용할 수 있습니다. 특히 모바일 앱이나 웹 애플리케이션을 개발할 때 데이터베이스나 서버 스토리지, 사용자 인증, 푸시 알림 등 여러 가지 서비스를 간편하게 이용할 수 있도록 구글은 파이어베이스(Firebase)라는 클라우드 플랫폼을 제공합니다.
이번 장에서는 파이어베이스를 이용해 서버 없이 데이터를 저장하고 불러오는 방법, 그리고 앱에 구글의 광고를 달아서 수익화하는 방법까지 알아보겠습니다.
13-1 파이어베이스 설정하기
13-2 애널리틱스 사용하기
13-3 데이터베이스를 이용한 메모장 앱 만들기
13-4 푸시 알림 보내기
13-5 앱에 광고를 넣어 수익화하기
344
13-1 파이어베이스 설정하기
파이어베이스는 모바일 앱이나 웹 애플리케이션을 개발하고 운용할 때 사용할 수 있는 여러 가지 서비스를 제공하는 클라우드 플랫폼입니다. 파이어베이스를 이용하면 서버리스(severless)[각주*] 앱을 개발하고 운용할 수 있습니다. 또한 일정 용량까지는 무료[각주**]로 이용할 수 있어서 학습용으로도 좋습니다.
[각주*] 자체 서버 없이 데이터 센터나 클라우드를 이용해 필요한 기능을 함수 형태로 구현해서 사용하는 것을 의미합니다.[각주 끝]
[각주**] 파이어베이스의 자세한 가격 정책은 firebase.google.com/pricing 사이트를 참고하세요.[각주 끝]
파이어베이스를 이용하려면 먼저 파이어베이스 프로젝트를 만들고 앱 개발 프로젝트와 연동해야 합니다. 이번 절에서는 이러한 과정을 살펴보겠습니다.
[아하!] 파이어베이스를 이용할 때 주의할 점
이번 장에서는 파이어베이스가 제공하는 여러 서비스를 사용합니다. 그런데 파이어베이스는 계속 업데이트되므로 일부 화면이나 메뉴명이 달라질 수 있습니다. 혹시 실습을 진행하면서 일부 내용이 책의 내용과 다르더라도 당황하지 말고 웹 사이트의 안내를 잘 살펴보기 바랍니다. 대부분은 미세한 변경으로 실습을 따라 하는 데는 무리가 없을 것입니다. 혹시 크게 달라지는 부분이 있으면 책에서 안내하는 질의응답 사이트에 올려두겠습니다.
또한, 구글이 제공하는 개발 관련 서비스를 이용해 본 적이 있는 계정으로 파이어베이스를 시작하면 일부 설정이 이 책의 내용과 다를 수 있습니다. 따라서 될 수 있으면 새로운 구글 계정을 만들어서 실습을 진행하기 바랍니다.
[아하! 끝]
[Do it! 실습] 파이어베이스 프로젝트 만들기
파이어베이스가 제공하는 다양한 서비스를 이용하려면 먼저 파이어베이스에 프로젝트를 만들어야 합니다. 파이어베이스 프로젝트는 파이어베이스 웹 사이트에서 만들고 관리할 수 있습니다. 이렇게 만든 파이어베이스 프로젝트를 플러터 프로젝트와 연동해서 사용합니다.
345
[1단계] 파이어베이스에 새로운 프로젝트를 만들어 보겠습니다. 구글 계정으로 로그인한 후 firebase.google.com에 접속해서 메인 화면에 있는 <시작하기>를 클릭합니다. 그러면 프로젝트를 추가하고 관리할 수 있는 콘솔 화면으로 이동하는데 여기서 <프로젝트 만들기>를 클릭합니다.
[그림 13-1] 파이어베이스 프로젝트 만들기


[시작하기], [프로젝트 만들기]
[그림 끝]
[2단계] 프로젝트 만들기가 시작되면 제일 처음 프로젝트 이름을 설정합니다. 여기서는 googleExample이라고 입력했습니다. 입력 후 <계속>을 클릭합니다.
[그림 13-2] 파이어베이스 프로젝트 이름 입력


(1) googleExample
(2) [계속]
[그림 끝]
346
[3단계] 이어서 사용자 분석 도구인 구글 애널리틱스를 사용할 것인지 설정합니다. 사용한다고 설정하고 <계속>을 클릭합니다.
[그림 13-3] 구글 애널리틱스 사용 설정


(1) 이 프로젝트에서 Google 애널리틱스 사용 설정: 권장
(2) [계속]
[그림 끝]
[4단계] 애널리틱스 구성 화면이 나타나면 애널리틱스 위치를 대한민국으로 선택한 후 데이터 공유 설정과 애널리틱스 약관에 모두 체크하고 <프로젝트 만들기>를 클릭합니다.
[그림 13-4] 구글 애널리틱스 구성


(1) 대한민국
(2) ?, ?, ?
(3) [프로젝트 만들기]
[그림 끝]
347
[5단계] 잠시 후 새 프로젝트가 준비되었다는 메시지가 표시되면 <계속>을 클릭해 파이어베이스 프로젝트 만들기를 완료합니다.
[그림 13-5] 파이어베이스 프로젝트 준비 완료


[계속]
[그림 끝]
[Do it! 실습] 파이어베이스에 안드로이드 앱 추가하기
다음 순서로 파이어베이스를 사용할 앱을 프로젝트에 등록해야 합니다. 파이어베이스 프로젝트에는 iOS나 안드로이드 앱, 웹, 유니티(Unity)로 개발한 게임 앱 등을 등록할 수 있지만, 이 책은 윈도우 환경에서 앱 개발을 실습하므로 여기서는 안드로이드 앱을 추가해 보겠습니다.
[1단계] 먼저 안드로이드 스튜디오에서 firebase_example이라는 이름으로 새로운 플러터 프로젝트를 만듭니다. 이때 패키지 이름은 com.rollcake.firebase_example로 정했습니다. 이 패키지 이름은 잠시 후 파이어베이스에 앱을 등록할 때 필요합니다. <Finish>를 눌러 플러터 프로젝트 생성을 마칩니다.
[그림 13-6] 플러터 프로젝트 생성


(1) com.rollcake.firebase_example
(2) [Finish]
[그림 끝]
348
[2단계] 다시 파이어베이스 콘솔로 이동합니다. 왼쪽 메뉴에서 [프로젝트 개요]를 클릭해 콘솔 홈 화면으로 이동합니다[각주*]. 그리고 프로젝트 이름 아래 안드로이드 모양의 아이콘( )을 클릭해 안드로이드용 앱을 추가합니다.
[각주*] 웹 브라우저의 너비에 따라 왼쪽의 메뉴가 닫힐 수 있으며 이때는 왼쪽 위의 햄버거 아이콘(≡)을 눌러서 열면 됩니다.[각주 끝]
[그림 13-7] 안드로이드 앱 추가하기


프로젝트 개요
[그림 끝]
[3단계] 앱 등록 화면이 나타나면 패키지 이름을 적는 곳에 플러터 프로젝트를 생성할 때 작성한 패키지 이름 com.rollcake.firebase_example을 입력하고 <앱 등록>을 클릭합니다.
[그림 13-8] 앱 등록하기


(1) com.rollcake.firebase_example
(2) [앱 등록]
[그림 끝]
349
[4단계] 구성 파일을 내려받는 단계에서는 <google-services.json 다운로드>를 클릭해 JSON 파일을 내려받고 <다음>을 클릭합니다. 내려받은 google-services.json 파일은 안드로이드 스튜디오의 플러터 프로젝트 탐색 창의 android/app 폴더에 넣습니다.
[그림 13-9] 구성 파일 내려받아서 안드로이드 프로젝트에 넣기


(1) google-services-json 다운로드
(2) google-services-json
(3) [다음]
[그림 끝]
[5단계] 그다음은 안드로이드 그래들 파일에 파이어베이스 SDK를 어떻게 추가하는지 안내가 나옵니다. 이 과정은 바로 다음 단계에서 진행할 것이므로 간략하게 확인하고 <다음>을 눌러 파이어베이스에 안드로이드 앱 추가하기를 완료합니다. 마지막 화면에서 <콘솔로 이동>을 누릅니다.
[그림 13-10] 파이어베이스 SDK 추가 완료하기


[다음], [콘솔로 이동]
[그림 끝]
350
[6단계] 안드로이드 스튜디오에서 [File → Open]을 눌러 firebase_example 프로젝트 아래에 있는 android 폴더를 새 창에서 엽니다. 잠시 후 안드로이드 스튜디오가 그래들 구성을 마치면 탐색 창에서 Gradle Scripts 카테고리 아래에 있는 build.gradle(Project android) 파일을 열고 클래스 경로를 설정하는 코드를 추가합니다.
[글상자] 안드로이드 프로젝트 build.gradle (Project: android)
(...생략...)
dependencies {
classpath 'com.android.tools.build:gradle:4.1.0'
classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
classpath 'com.google.gms:google-services:4.3.4'
}
(...생략...)
[글상자 끝]
이어서 build.gradle (Module: app) 파일을 열고 맨 아래쪽에 플러그인을 추가하는 코드를 작성합니다.
[글상자] 안드로이드 프로젝트 build.gradle (Module: android.app)
(...생략...)
dependencies {
implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
}
apply plugin: 'com.google.gms.google-services'
[글상자 끝]
그래들 파일을 수정했으므로 동기화 메뉴가 나타납니다. 편집창 위에 노란 줄에서 <Sync Now>를 클릭합니다. 여기까지 하면 파이어베이스를 사용할 준비가 끝납니다.
[그림 13-11] 그래들 동기화


Sync now
[그림 끝]
351
13-2 애널리틱스 사용하기
앞에서 파이어베이스를 사용할 준비를 마쳤으니 파이어베이스의 기본 기능인 애널리틱스를 사용해 보겠습니다. 애널리틱스(analytics)는 앱의 사용자를 분석해 주는 도구입니다. 애널리틱스를 이용하면 얼마나 많은 사용자가 어떤 기능을 주로 이용하는지 등을 분석해 앱을 운영하는 데 필요한 자료를 얻을 수 있습니다.
[Do it! 실습] 애널리틱스에 이벤트 보내기
이번 실습에서는 앱에서 애널리틱스로 이벤트를 전달하는 방법을 살펴보겠습니다. 앱의 특정 페이지나 버튼 등에 이벤트를 등록해 두면 사용자가 이를 이용할 때 해당 이벤트로 전달된 여러 데이터를 기록해 앱의 사용 현황을 분석할 수 있습니다. 즉, 애널리틱스가 앱을 사용하는 사람들의 행동을 기록할 수 있게 하는 방법입니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] 앞의 실습에서 만든 플러터 프로젝트(firebase_example)에서 pubspec.yaml 파일을 열고 dependencies 항목에 파이어베이스 코어와 애널리틱스 패키지를 추가합니다.
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
firebase_core: ^0.5.3 # 파이어베이스 기본 패키지
firebase_analytics: ^6.3.0 # 파이어베이스 애널리틱스 패키지
(...생략...)
[글상자 끝]
352
[2단계] main.dart 파일을 열고 샘플 코드를 지운 후 다음과 같이 코드를 작성합니다.
[글상자] lib/main.dart
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:firebase_analytics/observer.dart';
import 'package:flutter/material.dart';
void main() => runApp(MyApp());
class MyApp extends StatelessWidget {
static FirebaseAnalytics analytics = FirebaseAnalytics();
static FirebaseAnalyticsObserver observer =
FirebaseAnalyticsObserver(analytics: analytics);
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Firebase Example',
theme: ThemeData(
primarySwatch: Colors.blue,
),
navigatorObservers: <NavigatorObserver>[observer],
home: FirebaseApp(
analytics: analytics,
observer: observer,
),
);
}
}
[글상자 끝]
MyApp 클래스에 파이어베이스 애널리틱스를 사용하기 위한 FirebaseAnalytics 객체를 선언했습니다. 그리고 앱에서 페이지 이동, 클릭 등 사용자의 행동을 관찰하는 FirebaseAnalyticsObserver 객체를 선언했습니다. 이처럼 관찰자 개념으로 사용하는 객체를 옵서버(observer)라고 부르는데 이와 관련한 내용은 다음 실습에서 자세하게 다루겠습니다.
353
[3단계] MyApp 클래스에 이어서 FirebaseApp과 _FirebaseAppState 클래스를 작성합니다.
[글상자] lib/main.dart
(...생략...)
class FirebaseApp extends StatefulWidget {
FirebaseApp({Key key, this.analytics, this.observer}) : super(key: key);
final FirebaseAnalytics analytics;
final FirebaseAnalyticsObserver observer;
@override
_FirebaseAppState createState() => _FirebaseAppState(analytics, observer);
}
class _FirebaseAppState extends State<FirebaseApp> {
_FirebaseAppState(this.analytics, this.observer);
final FirebaseAnalyticsObserver observer;
final FirebaseAnalytics analytics;
String _message = '';
void setMessage(String message) {
setState(() {
_message = message;
});
}
Future<void> _sendAnalyticsEvent() async {
// 애널리틱스의 logEvent를 호출해 test_event라는 키값으로 데이터 저장
await analytics.logEvent(
name: 'test_event',
parameters: <String, dynamic> {
'string': 'hello flutter',
'int': 100,
},
);
setMessage('Analytics 보내기 성공');
}
354
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('Firebase Example'),
),
body: Center(
child: Column(
children: <Widget>[
RaisedButton(
child: Text('테스트'),
onPressed: _sendAnalyticsEvent,
),
Text(_message, style: const TextStyle(color: Colors.blueAccent)),
],
mainAxisAlignment: MainAxisAlignment.center,
),
),
floatingActionButton:
FloatingActionButton(child: const Icon(Icons.tab), onPressed: () {}),
);
}
}
[글상자 끝]
_FirebaseAppState 클래스에서는 버튼을 하나 만들고 이 버튼을 클릭하면 _sendAnalyticsEvent() 함수를 호출해 애널리틱스에 이벤트를 보내도록 했습니다. 애널리틱스에 이벤트를 보낼 때는 analytics.logEnvent() 함수를 이용합니다.
[글상자]
await analytics.logEvent(
name: 'test_event',
parameters: <String, dynamic> {
'string': 'hello flutter',
'int': 100,
},
);
[글상자 끝]
355
이때 name에 이벤트 이름을 전달하고 parameters에 데이터를 Map 형태로 전달합니다. 애널리틱스는 이렇게 전달받은 이벤트를 기록해 분석 데이터로 활용할 수 있게 합니다.
[4단계] 앱을 실행하고 <테스트> 버튼을 누르면 test_event라는 이름의 이벤트를 애널리틱스에 전달합니다.
[그림] 실행 결과


Firebase Example - 테스트: Analytics 보내기 성공
[그림 끝]
[5단계] 애널리틱스가 기록한 이벤트는 파이어베이스 콘솔의 [애널리틱스 → Events] 메뉴에서 확인할 수 있습니다. 그런데 아쉽게도 기록이 실시간으로 보이지는 않고 24시간 이내에 보인다는 안내가 나타납니다.
[그림 13-12] 24시간 이내 표시 안내


Events
[그림 끝]
356
이후 24시간 이내에 test_event라는 이름의 이벤트가 기록된 것을 확인할 수 있습니다.
[그림 13-13] 이벤트 기록 안내


test_event
[그림 끝]
파이어베이스 콘솔의 [애널리틱스 → Dashboard] 메뉴에서 앱의 전체적인 사용 현황을 그래프로 볼 수도 있습니다. 다음은 대시보드 화면의 예입니다.
[그림 13-14] 대시보드 화면 예


[그림 끝]
[Do it! 실습] 옵서버 사용하기
이번 실습에서는 탭이 있는 새로운 페이지를 만들고 파이어베이스 애널리틱스의 옵서버를 이용해 사용자의 행동을 기록해 보겠습니다. FirebaseAnalyticsObserver는 사용자가 어떤 화면을 보고 있는지, 어떤 화면을 클릭했는지 등을 알고 싶을 때 사용합니다.
[1단계] 먼저 tabsPage.dart 파일을 새로 생성하고 TabsPage 클래스를 다음처럼 작성합니다.
357
[글상자] lib/tabsPage.dart
import 'package:flutter/material.dart';
import 'package:firebase_analytics/observer.dart';
class TabsPage extends StatefulWidget {
TabsPage(this.observer);
final FirebaseAnalyticsObserver observer;
@override
State<StatefulWidget> createState() => _TabsPage(observer);
}
[글상자 끝]
[2단계] 이제 State를 상속받는 _TabsPage 클래스를 작성합니다. 이 페이지는 앱바를 이용해 탭을 만들고 탭을 눌렀을 때 페이지를 이동하도록 합니다.
[글상자] lib/tabsPage.dart
(...생략...)
class _TabsPage extends State<TabsPage>
with SingleTickerProviderStateMixin, RouteAware {
_TabsPage(this.observer);
final FirebaseAnalyticsObserver observer;
TabController _controller;
int selectedIndex = 0;
final List<Tab> tabs = <Tab>[
const Tab(
text: '1번',
icon: Icon(Icons.looks_one),
),
const Tab(
text: '2번',
icon: Icon(Icons.looks_two),
),
];
358
@override
void initState() {
super.initState();
_controller = TabController(
vsync: this,
length: tabs.length,
initialIndex: selectedIndex,
);
_controller.addListener(() {
setState(() {
if (selectedIndex != _controller.index) {
selectedIndex = _controller.index;
_sendCurrentTab();
}
});
});
}
}
[글상자 끝]
먼저 탭 목록을 만든 다음 initState() 함수에서 TabController를 초기화합니다. 그리고 탭을 클릭했을 때 발생하는 이벤트를 addListener() 함수로 처리합니다. 탭을 클릭하면 탭 포커스가 변경되면서 다음 단계에서 작성할 _sendCurrentTab() 함수를 호출합니다.
[3단계] 앱바에서 탭을 클릭하면 실행할 _sendCurrentTab() 함수를 다음처럼 작성합니다.
[글상자] lib/tabsPage.dart
(...생략...)
void _sendCurrentTab() {
observer.analytics.setCurrentScreen(
screenName: 'tab/$selectedIndex',
);
}
(...생략...)
[글상자 끝]
359
_sendCurrentTab() 함수는 현재 화면 이름을 파이어베이스 애널리틱스에 보냅니다. 이로써 사용자가 어떤 화면에 더 많이 접근했는지 알 수 있습니다. 이후 8단계에서 이를 확인해 볼 텐데 인덱스 번호는 0부터 시작하므로 화면 이름이 tab/0이면 1번 탭을 의미하고, tab/1이면 2번 탭을 의미합니다.
[4단계] 옵서버를 이용하려면 FirebaseAnalyticsObserver를 사용한다고 앱에 알려 주어야 합니다. 이를 구독(subscribe)이라고 합니다. 스테이트의 생명주기에서 didChangeDependencies()는 initState() 함수 다음에 상태에 변화가 생겼을 때 호출되는 함수입니다. didChangeDependencies() 함수는 dispose() 함수가 호출되기 전에도 호출됩니다. 따라서 옵서버는 didChangeDependencies() 함수를 재정의해서 구독하고 dispose() 함수를 재정의해서 구독을 해지합니다.
[글상자] lib/tabsPage.dart
(...생략...)
@override
void didChangeDependencies() {
super.didChangeDependencies();
observer.subscribe(this, ModalRoute.of(context));
}
@override
void dispose() {
observer.unsubscribe(this);
super.dispose();
}
(...생략...)
[글상자 끝]
[5단계] 마지막으로 build() 함수를 만들어서 화면을 구성할 위젯을 배치합니다.
[글상자] lib/tabsPage.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
360
bottom: TabBar(
controller: _controller,
tabs: tabs,
),
),
body: TabBarView(
controller: _controller,
children: tabs.map((Tab tab) {
return Center(child: Text(tab.text));
}).toList(),
),
);
}
(...생략...)
[글상자 끝]
[6단계] 이제 main.dart 파일을 열고 플로팅 버튼을 눌렀을 때 라우트 기능을 이용해 tabsPage로 이동하는 코드를 추가합니다.
[글상자] lib/main.dart
import 'tabsPage.dart';
(...생략...)
floatingActionButton: FloatingActionButton(
child: const Icon(Icons.tab),
onPressed: () {
Navigator.of(context).push(MaterialPageRoute<TabsPage>(
settings: RouteSettings(name: '/tab'),
builder: (BuildContext context) {
return TabsPage(observer);
}));
}),
(...생략...)
[글상자 끝]
그런데 소스를 보면 08장에서 사용한 라우트 기능과는 조금 다릅니다. 기존처럼 pushNamed(), pushReplacementNamed() 함수 등을 사용하지 않고 push() 함수를 사용해 페이지를 이동합니다. push() 함수의 settings에는 라우트를 설정하는 RouteSettings() 함수를 이용해 라우트
361
이름(name)과 해당 페이지에 전달할 인자(arguments) 등을 지정할 수 있습니다. 이렇게 하면 기존처럼 MaterialApp의 routes 옵션에 라우트 경로를 등록하지 않아도 됩니다. 앱에서 자주 사용하지 않는 페이지의 라우트는 이처럼 간단하게 처리할 수도 있습니다.
[7단계] 이제 앱을 빌드하고 실행 후 플로팅 버튼을 누르면 탭바가 있는 화면으로 이동합니다. 이 화면에서 1번과 2번 탭을 번갈아 클릭해 보면서 애널리틱스에 사용 기록이 전달되도록 합니다.
[그림] 실행 결과


1번
[그림 끝]
[8단계] 이제 파이어베이스 콘솔의 [애널리틱스 → Events] 메뉴에서 screen_view라는 이름의 이벤트를 클릭합니다.
[그림 13-15] 이벤트 선택 화면


Events → screen_view
[그림 끝]
362
그리고 이벤트 분석 화면에서 여러 섹션 중 사용자 참여도에서 항목을 화면 이름으로 바꿉니다. 그러면 다음처럼 사용자 중 몇 퍼센트가 어떤 페이지에 얼마나 오래 머물렀는지를 알 수 있습니다.
[그림 13-16] 사용자의 참여도 분석


(1) 화면 이름
(2) tab/0
[그림 끝]
그림에서 tab/0이라는 화면 이름은 앞서 3단계에서 애널리틱스에 전달한 'tab/$selected Index' 코드에 의한 것입니다.
[글상자] 애널리틱스에 화면 이름 보내기
observer.analytics.setCurrentScreen(
screenName: 'tab/$selectedIndex',
);
[글상자 끝]
이것으로 페이지별 사용자의 참여도를 알 수 있습니다. 지금은 데이터가 적어서 숫자가 적지만 사용자가 많아지면 유의미한 데이터들이 모이고 이러한 데이터를 바탕으로 앱을 업데이트하거나 프로모션 등을 고민할 수 있습니다. 필자가 만든 앱의 파이어베이스 콘솔의 경우 다음과 같은 데이터가 표시되는 것을 확인할 수 있습니다.
[그림 13-17] 데이터가 쌓인 파이어베이스 애널리틱스


[그림 끝]
363
13-3 데이터베이스를 이용한 메모장 앱 만들기
10장에서 데이터베이스를 배웠지만 파이어베이스를 이용하면 실시간 데이터베이스(Realtime Database)를 좀 더 쉽게 구현하고 관리할 수 있습니다. 이번 절에서는 파이어베이스가 제공하는 실시간 데이터베이스를 이용해 메모장 앱을 만들어 보겠습니다.
[Do it! 실습] 파이어베이스에 실시간 데이터베이스 만들기
[1단계] 먼저 파이어베이스에 실시간 데이터베이스를 만듭니다. 파이어베이스 콘솔에 접속한 후 왼쪽 메뉴에서 [빌드 → Realtime Database]를 클릭하고 [데이터베이스 만들기]를 클릭합니다.
[그림 13-18] 실시간 데이터베이스 만들기


(1) Realtime Database
(2) 데이터베이스 만들기
[그림 끝]
[2단계] 실시간 데이터베이스 위치를 설정하는 화면에서 [미국]을 선택하고 <다음>을 클릭합니다. 여기서 말하는 위치는 데이터베이스가 저장되는 실제 서버의 위치입니다.
[그림 13-19] 데이터베이스 위치 설정


(1) 미국(us-central1)
(2) [다음]
[그림 끝]
364
[3단계] 보안 규칙을 설정하는 화면에서 [테스트 모드에서 시작][각주*]을 선택하고 <사용 설정>을 클릭하면 데이터베이스가 생성됩니다.
[각주*] 테스트 모드로 설정하면 30일간 읽기/쓰기가 가능하지만 이후 보안 규칙을 수정하면 계속 사용할 수 있습니다.[각주 끝]
[그림 13-20] 보안 규칙 설정


(1) 테스트 모드에서 시작: 데이터베이스에 대한 모든 읽기 및 쓰기를 허용하여 빠르게 설정합니다. 보안 규칙이 업데이트되지 않으면 30일 후 클라이언트 읽기/쓰기 엑세스가 거부됩니다.
(2) [사용 설정]
[그림 끝]
[4단계] 빈 데이터베이스가 보이고 앱에서 이 데이터베이스에 접근할 수 있는 주소가 보입니다. 다음 실습에서 이 주소를 사용하기 위해 별도로 복사해 두도록 합니다. 이제 두 번째 탭인 [규칙]을 클릭합니다.
[그림 13-21] 빈 데이터베이스 생성 완료


규칙, 주소 복사해 두기
[그림 끝]
[5단계] 데이터베이스의 규칙을 정하는 코드가 보입니다. 앞서 테스트 모드로 만들어서 읽기(.read)와 쓰기(.write) 권한이 오늘부터 30일만 허용하도록 제한되어 있습니다. 이를 다음처럼 각각 true로 수정해 계속해서 아무나 읽고 쓰기가 가능하도록 변경합니다. 그리고 <게시>를 클릭해 적용합니다. 그러면 파이어베이스의 실시간 데이터베이스 생성과 설정이 끝납니다.
[그림 13-22] 규칙 수정하기


[게시]
".read": true,
:.write": true,
[그림 끝]
365
[Do it! 실습] 메모장 앱 만들기
이번 실습에서는 앞에서 만든 실시간 데이터베이스를 이용해 메모장 앱을 만들고 CRUD 기능을 완성해 보겠습니다. 앞 절에서 만든 firebase_example 프로젝트에 이어서 진행하겠습니다.
[QR 코드] 소스 보기


[QR 코드 끝]
[1단계] 먼저 pubspec.yaml 파일을 열고 dependencies 항목에 파이어베이스 데이터베이스 패키지를 추가합니다.
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
firebase_core: ^0.5.3 # 파이어베이스 기본 패키지
firebase_analytics: ^6.3.0 # 파이어베이스 애널리틱스 패키지
firebase_database: ^4.2.0 # 파이어베이스 데이터베이스 패키지
(...생략...)
[글상자 끝]
[2단계] lib 폴더에 memo.dart 파일을 만들고 다음처럼 Memo라는 클래스에 데이터 구조를 정의합니다.
[글상자] lib/memo.dart
import 'package:firebase_database/firebase_database.dart';
class Memo {
String key;
String title;
String content;
String createTime;
Memo(this.title, this.content, this.createTime);
Memo.fromSnapshot(DataSnapshot snapshot)
: key = snapshot.key,
366
title = snapshot.value['title'],
content = snapshot.value['content'],
createTime = snapshot.value['createTime'];
toJson() {
return {
'title': title,
'content': content,
'createTime': createTime,
};
}
}
[글상자 끝]
fromSnapshot() 함수는 데이터베이스에서 데이터를 가져올 때 Memo 클래스의 변수에 넣어줍니다. 그리고 데이터를 JSON 형태로 반환하는 toJson() 함수도 만들었습니다.
[3단계] lib 폴더에 memoPage.dart 파일을 만들고 StatefulWidget을 상속받는 MemoPage 클래스를 생성합니다. 그리고 import 문으로 파이어베이스 데이터베이스 패키지와 앞으로 만들 파일도 미리 추가해 둡니다.
[글상자] lib/memoPage.dart
import 'package:flutter/material.dart';
import 'package:firebase_database/firebase_database.dart';
import 'memo.dart';
import 'memoAdd.dart';
import 'memoDetail.dart';
class MemoPage extends StatefulWidget {
@override
State<StatefulWidget> createState() => _MemoPage();
}
(...생략...)
[글상자 끝]
367
[4단계] 이어서 State를 상속받는 _MemoPage 클래스를 다음처럼 작성합니다. _databaseURL 변수에는 앞의 실습에서 확인한 파이어베이스 데이터베이스의 URL을 넣습니다.
[글상자] lib/memoPage.dart
(...생략...)
class _MemoPage extends State<MemoPage> {
FirebaseDatabase _database;
DatabaseReference reference;
String _databaseURL = '### 데이터베이스 URL 넣기 ###';
List<Memo> memos = List();
@override
void initState() {
super.initState();
_database = FirebaseDatabase(databaseURL: _databaseURL);
reference = _database.reference().child('memo');
reference.onChildAdded.listen((event) {
print(event.snapshot.value.toString());
setState(() {
memos.add(Memo.fromSnapshot(event.snapshot));
});
});
}
}

'### 데이터베이스 URL 넣기 ###'; → 데이터베이스 주소를 여기에 넣으세요.
[글상자 끝]
파이어베이스 데이터베이스를 다룰 때 사용하는 FirebaseDatabase와 DatabaseReference 객체를 선언하고 initState() 함수에서 초기화합니다. 그리고 메모 목록을 나타낼 리스트도 하나 선언합니다.
child('memo')는 데이터베이스에 memo라는 컬렉션을 만드는 코드입니다. 이 컬렉션 안에 데이터를 쓰거나 읽어올 예정입니다. onChildAdded.listen은 데이터베이스에 데이터가 추가되면 자동으로 실행됩니다. 여기에 데이터베이스에 추가된 데이터를 가져오는 코드를 작성했습니다. 따라서 앱을 처음 실행하면 데이터베이스에 저장된 데이터를 차례로 가져와서 memos 리스트에 추가합니다. 이때 Memo.fromSnapshot() 함수를 이용해 데이터를 간단하게 추가할 수 있습니다.
368
[5단계] _MemoPage 클래스에 build() 함수를 추가해 메모 페이지를 완성합니다. 여기서는 그리드뷰(GridView) 위젯으로 화면을 2열로 표시합니다.
[글상자] lib/memoPage.dart
(...생략...)
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('메모 앱'),
),
body: Container(
child: Center(
child: memos.length == 0
? CircularProgressIndicator()
: GridView.builder(
gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
crossAxisCount: 2),
itemBuilder: (context, index) {
return Card(
child: GridTile(
child: Container(
padding: EdgeInsets.only(top: 20, bottom: 20),
child: SizedBox(
child: GestureDetector(
onTap: () {
// 여기에 메모 상세보기 화면으로 이동 추가 예정
},
onLongPress: () {
// 여기에 길게 클릭 시 메모 삭제 기능 추가 예정
},
child: Text(memos[index].content),
),),),
header: Text(memos[index].title),
footer: Text(memos[index].createTime.substring(0, 10)),
),);
},
itemCount: memos.length,
369
),),),
floatingActionButton: FloatingActionButton(
onPressed: () {
Navigator.of(context).push(
MaterialPageRoute(builder: (context) => MemoAddPage(reference)));
},
child: Icon(Icons.add),),
);
}
(...생략...)
[글상자 끝]
데이터베이스에서 불러온 데이터가 없으면 CircularProgressIndicator를 이용해 프로그레스를 표시하고 데이터가 있으면 GridView.builder를 이용해 그리드뷰를 만듭니다. 그리드뷰는 gridDelegate를 설정해야 하는데, 보통 정형화된 그리드뷰를 생성할 때는 SliverGridDelegateWithFixedCrossAxisCount를 사용합니다.
이때 crossAxisCount에는 열 개수로 2를 입력하고 itemBuilder에는 앞에서 여러 번 실습한 ListView.builder와 같이 입력하면 됩니다. 이어서 카드 위젯에 GridTile을 설정하고 데이터를 넣어서 화면에 출력합니다.
마지막으로 플로팅 버튼을 클릭하면 메모를 추가하는 페이지(MemoAddPage)로 이동하는 코드도 작성합니다. 각 아이템을 클릭하면 메모 상세보기 화면으로 이동하고 길게 클릭하면 알림 창을 띄위 메모를 삭제하는 코드는 다음 실습에서 완성하겠습니다. 지금은 주석으로 표기해 두었으니 다음 실습에서 이곳에 코드를 작성하면 됩니다.
[6단계] lib 폴더에 memoAdd.dart 파일을 만들고 메모를 추가하는 화면을 만듭니다.
[글상자] lib/memoAdd.dart
import 'package:flutter/material.dart';
import 'package:firebase_database/firebase_database.dart';
import 'memo.dart';
class MemoAddPage extends StatefulWidget {
final DatabaseReference reference;
MemoAddPage(this.reference);
370
@override
State<StatefulWidget> createState() => _MemoAddPage();
}
class _MemoAddPage extends State<MemoAddPage> {
TextEditingController titleController;
TextEditingController contentController;
@override
void initState() {
super.initState();
titleController = TextEditingController();
contentController = TextEditingController();
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('메모 추가'),
),
body: Container(
padding: EdgeInsets.all(20),
child: Center(
child: Column(
children: <Widget>[
TextField(
controller: titleController,
decoration: InputDecoration(
labelText: '제목', fillColor: Colors.blueAccent),
),
Expanded(
child: TextField(
controller: contentController,
keyboardType: TextInputType.multiline,
maxLines: 100,
decoration: InputDecoration(labelText: '내용'),
)),
371
FlatButton(
onPressed: () {
widget.reference
.push()
.set(Memo(
titleController.value.text,
contentController.value.text,
DateTime.now().toIso8601String())
.toJson())
.then((_) {
Navigator.of(context).pop();
});
},
child: Text('저장하기'),
shape:
OutlineInputBorder(borderRadius: BorderRadius.circular(1)),
)],),),),);
}
}
[글상자 끝]
텍스트필드를 이용해 사용자로부터 제목과 글을 입력받고 <저장하기> 버튼을 누르면 reference.push().set() 함수를 이용해 데이터베이스에 데이터를 저장합니다. push() 함수는 데이터베이스에 데이터를 저장할 때 사용하고 set() 함수는 어떤 테이터를 넣을지 정의합니다. 여기에 사용자가 입력한 데이터를 Memo 객체로 만들어서 넣습니다. then()은 데이터를 처리 후 어떤 동작을 할지 정의하는 함수로, 여기서는 pop() 함수로 페이지를 종료합니다. 즉, 메인 화면으로 이동합니다.
[7단계] 마지막으로 main.dart 파일을 열고 MyApp 클래스에서 build() 함수의 home에서 MemoPage를 호출하도록 수정합니다.
[글상자] lib/main.dart
(...생략...)
import 'memoPage.dart';
void main() => runApp(MyApp());
372
class MyApp extends StatelessWidget {
(...생략...)
@override
Widget build(BuildContext context) {
return MaterialApp(
(...생략...)
home: MemoPage(),
(...생략...)
[글상자 끝]
[8단계] 이제 앱을 빌드한 후 실행합니다. 처음 화면은 아직 데이터베이스에 데이터를 저장하기 전이므로 메모가 보이지 않고 원형 프로그레스만 돌아갑니다. 플로팅 버튼을 누르면 메모를 저장하는 화면으로 이동하고 이곳에 제목과 내용을 입력 후 <저장하기> 버튼을 누르면 저장한 메모가 보이는 메인 화면으로 돌아갑니다.
[그림] 실행 결과


(+) → 제목: 스파게티, 내용: 스파게티(이탈리아어: spaghetti, 문화어: 스빠게띠)는 길고 가는 원통형(cylindrical) 파스타의 일종이다. 이탈리아 요리의 대명사로 꼽히며, 보통 토마토 소스를 바탕으로 한 소스를 끼얹어 먹는다. 스파게티는 소금을 조금 넣은 끓는 물에서 8~12분 충분히 삶아야 하고 찬물에 헹구지 않으며, 뜨거운 채로 건져 약간 움푹한 그릇에 담아 토마토 퓌레나 토마토 소스를 끼얹고 취향에 따라 가루 치즈를 뿌려 따뜻할 때 먹는다.
[저장하기] → ‘메모 앱 화면’, 스파게티: 스파게티(이탈리아어: spaghetti, 문화어: 스빠게띠)는 길고 가는 원통형(cylindrical) 파스타의 일종이다. 이탈리아 요리의 대명사로 꼽히며, 보통 토마토 소스를 바탕으로 한 소스를 끼얹어 먹는다. 스파게티는 소금을 조…, 2020-12-16
[그림 끝]
[9단계] 파이어베이스 콘솔에서 [빌드 → Realtime Database] 메뉴를 클릭해 데이터베이스를 살펴보면 앱에서 등록한 데이터가 memo라는 컬렉션 아래 저장된 것을 확인할 수 있습니다.
373
[그림 13-23] 저장된 데이터 확인


Realtime Database
[그림 끝]
[Do it! 실습] 데이터 수정과 삭제 기능 추가
이제 메인 화면에서 메모를 클릭했을 때 데이터를 수정하는 페이지를 만들겠습니다. 그리고 앞에서 생략한 삭제 기능도 추가해 보겠습니다.
[1단계] 메모 목록에서 메모를 클릭하면 수정하는 페이지로 이동하도록 그리드뷰의 아이템을 onTap하면 MemoDetailPage를 호출했습니다. 이때 보일 메모 상세보기 화면을 만들어 보겠습니다.
lib 폴더에 memoDetail.dart 파일을 만들고 다음과 같은 코드를 작성합니다. 전체적인 위젯의 구조는 앞의 실습에서 메모를 추가할 때(memoAdd.dart) 사용했던 방법과 비슷하지만, 메모 데이터를 가져와 화면에 미리 표시해 두는 로직이 조금 다릅니다.
[글상자] lib/memoDetail.dart
import 'package:flutter/material.dart';
import 'package:firebase_database/firebase_database.dart';
import 'memo.dart';
class MemoDetailPage extends StatefulWidget {
final DatabaseReference reference;
final Memo memo;
MemoDetailPage(this.reference, this.memo);
@override
State<StatefulWidget> createState() => _MemoDetailPage();
}
374
class _MemoDetailPage extends State<MemoDetailPage> {
TextEditingController titleController;
TextEditingController contentController;
@override
void initState() {
super.initState();
titleController = TextEditingController(text: widget.memo.title);
contentController = TextEditingController(text: widget.memo.content);
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text(widget.memo.title),
),
body: Container(
padding: EdgeInsets.all(20),
child: Center(
child: Column(
children: <Widget>[
TextField(
controller: titleController,
decoration: InputDecoration(
labelText: '제목', fillColor: Colors.blueAccent),
),
Expanded(
child: TextField(
controller: contentController,
keyboardType: TextInputType.multiline,
maxLines: 100,
decoration: InputDecoration(labelText: '내용'),
)),
FlatButton(
onPressed: () {
Memo memo = Memo(titleController.value.text,
contentController.value.text, widget.memo.createTime);
375
widget.reference
.child(widget.memo.key)
.set(memo.toJson())
.then((_) {
Navigator.of(context).pop(memo);
});
},
child: Text('수정하기'),
shape:
OutlineInputBorder(borderRadius: BorderRadius.circular(1)),
)],),),),
);
}
}
[글상자 끝]
메모 상세보기 화면에서 데이터를 수정한 후 <수정하기> 버튼을 누르면 새로운 Memo 클래스를 만든 후 reference에서 메모의 key값을 가져와서 같은 key에 해당하는 데이터를 수정합니다. 데이터를 수정한 후에는 데이터를 추가했을 때와 같이 pop() 함수를 호출해 이전 화면으로 이동합니다.
[2단계] 방금 만든 메모 상세보기 화면으로 이동하는 코드를 작성해 보겠습니다. memoPage.dart 파일을 열고 메모를 클릭했을 때 발생하는 MemoPage 클래스의 onTap 이벤트 처리 함수를 다음처럼 수정합니다.
[글상자] memoPage.dart
(...생략...)
import 'memoDetail.dart';
(...생략...)
onTap: () async {
Memo memo = await Navigator.of(context).push(
MaterialPageRoute<Memo>(
builder: (BuildContext context) =>
MemoDetailPage(reference, memos[index])));
if (memo != null) {
setState(() {
376
memos[index].title = memo.title;
memos[index].content = memo.content;
});
}
},
(...생략...)
[글상자 끝]
[3단계] 다음은 삭제 기능을 추가해 보겠습니다. memoPage.dart 파일을 열고 메모를 길게 클릭했을 때 발생하는 MemoPage 클래스의 onLongPress 이벤트 처리 함수에 다음과 같은 코드를 작성합니다.
[글상자] memoPage.dart
(...생략...)
showDialog(
context: context,
builder: (context) {
return AlertDialog(
title: Text(memos[index].title),
content: Text('삭제하시겠습니까?'),
actions: <Widget>[
FlatButton(
onPressed: () {
reference
.child(memos[index].key)
.remove()
.then((_) {
setState(() {
memos.removeAt(index);
Navigator.of(context).pop();
});
});
},
child: Text('예')),
FlatButton(
onPressed: () {
Navigator.of(context).pop();
377
},
child: Text('아니요')),
],
);
});
(...생략...)
[글상자 끝]
알림 창을 띄운 후 <예>를 클릭하면 선택한 아이템의 key값을 가져와서 그 안에 있는 데이터를 remove() 함수 호출로 삭제합니다.
앱을 다시 빌드하고 실행한 다음 메모 목록에서 메모를 클릭하거나 길게 클릭하면 각각 수정과 삭제 기능을 시험해 볼 수 있습니다. 그리고 파이어베이스 콘솔에서 실시간 데이터베이스의 데이터가 어떻게 변하는지도 확인해 보세요.
[그림] 실행 결과


스파게티 - 제목: 스파게티(제목 수정 예), 내용: 스파게티(이탈리아어: spaghetti, 문화어: 스빠게띠)는 길고 가는 원통형(cylindrical) 파스타의 일종이다. 이탈리아 요리의 대명사로 꼽히며, 보통 토마토 소스를 바탕으로 한 소스를 끼얹어 먹는다. 스파게티는 소금을 조금 넣은 끓는 물에서 8~12분 충분히 삶아야 하고 찬물에 헹구지 않으며, 뜨거운 채로 건져 약간 움푹한 그릇에 담아 토마토 퓌레나 토마토 소스를 끼얹고 취향에 따라 가루 치즈를 뿌려 따뜻할 때 먹는다.
스파게티: 삭제하시겠습니까?, 예 / 아니요
[그림 끝]
이처럼 파이어베이스의 데이터베이스를 이용하면 실시간으로 변하는 데이터를 주고받으며 화면에 표시할 수 있습니다. 이를 이용해 서버 없이 간단한 채팅 앱을 만들 거나 실시간으로 데이터가 변하는 앱을 만드는 등 여러 방면으로 활용할 수 있습니다.
378
13-4 푸시 알림 보내기
사용자에게 이메일 도착을 알리기 위해 처음 시작된 푸시 알림(push notification)은 이제는 정보 제공의 기능을 넘어 강력한 마케팅 도구로 주목받고 있습니다. 푸시 알림은 이벤트, 쿠폰, 신상품, 메시지 등 앱의 새로운 소식을 사용자에게 실시간으로 알리고 싶을 때 사용합니다. 푸시 알림을 사용하면 내가 만든 앱이 사용자의 스마트폰에 설치된 많은 앱 중에서 존재감을 드러내 매출이나 참여율을 높일 수 있습니다.
파이어베이스는 이러한 푸시 알림 서비스인 FCM(Firebase cloud messaging)을 제공합니다. FCM의 SDK를 이용해 앱에서 푸시 알림을 받을 수 있게 구현해 놓고 파이어베이스에 푸시 알림을 등록하면 앱을 설치한 사용자의 기기에 전송합니다. 이번 절에서는 이러한 과정을 실습해 보겠습니다.
[Do it! 실습] 파이어베이스 푸시 알림 받기
먼저 파이어베이스에서 보내는 푸시 알림을 앱에서 받아 표시하는 기능을 구현해 보겠습니다. 앞 절에서 만든 firebase_example 프로젝트에 이어서 진행하겠습니다.
[1단계] pubspec.yaml 파일을 열고 dependencies 항목에 파이어베이스 메시징 패키지를 추가합니다.
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
firebase_core: ^0.5.3 # 파이어베이스 기본 패키지
firebase_analytics: ^6.3.0 # 파이어베이스 애널리틱스 패키지
firebase_database: ^4.2.0 # 파이어베이스 데이터베이스 패키지
firebase_messaging: ^7.0.3 # 파이어베이스 메시징 패키지
(...생략...)
[글상자 끝]
379
[2단계] 이어서 memoPage.dart 파일을 열고 FirebaseMessaging 객체를 추가합니다. 그리고 알림을 받으면 이를 어떻게 처리할 것인지를 configure() 함수를 이용해 정의합니다.
[글상자] memoPage.dart
(...생략...)
import 'package:firebase_messaging/firebase_messaging.dart';
class MemoPage extends StatefulWidget { ...생략... }
class _MemoPage extends State<MemoPage> {
(...생략...)
final FirebaseMessaging _firebaseMessaging = FirebaseMessaging();
@override
void initState() {
(...생략...)
_firebaseMessaging.getToken().then((value) {
print(value); // 토큰을 가져와 출력
});
_firebaseMessaging.configure(
onMessage: (Map<String, dynamic> message) async {
print('onMessage: $message');
showDialog(
context: context,
builder: (context) => AlertDialog(
content: ListTile(
title: Text(message['notification']['title']),
subtitle: Text(message['notification']['body']),
),
actions: <Widget>[
FlatButton(
child: Text('Ok'),
onPressed: () => Navigator.of(context).pop(),
),
],
),
);
},
onLaunch: (Map<String, dynamic> message) async {},
onResume: (Map<String, dynamic> message) async {},
);
(...생략...)
[글상자 끝]
380
initState() 함수에서 _firebaseMessaging 객체의 getToken() 함수를 호출해 가져온 토큰은 FCM이 앱을 처음 시작할 때 생성하는 특별한 문자열입니다. 이 값은 사용자를 특정해서 메시지를 보낼 때 활용합니다. 예를 들어 뒤에서 살펴볼 테스트 메시지 전송 등에 사용할 수 있습니다.
_firebaseMessaging.configure()는 푸시 알림이 도착했을 때 처리하는 함수입니다. 이 함수에는 onMessage, onLaunch, onResume 등 3개의 이벤트 핸들러를 설정할 수 있는데, 각 함수는 알림이 도착했을 때 앱의 상태에 따라 실행됩니다. 지금은 앱이 전면(foreground)에 실행 중일 때만 알림 창을 띄워 전달받은 알림을 표시하도록 onMessage를 구현했습니다.
만약 앱이 전면에 실행 중이지 않으면 알림은 시스템 트레이에 전달됩니다. 이 알림을 클릭하면 해당 앱으로 이동하는데, 이때 앱이 후면(background)[각주*]에서 실행 중인지 아예 종료되었는지에 따라서 각각 onResume, onLaunch를 호출합니다.
[각주*] 앱이 전면에 표시되고 있지는 않지만 메모리에 상주하고 있을 때를 의미합니다.[각주 끝]
[그림 13-24] 시스템 트레이에 전달된 푸시 알림


firebase_example ? 11시간
안녕하세요
플러터 예제입니다.
관리 / 모두 지우기
[그림 끝]
이처럼 onResume이나 onLaunch를 이용하려면 파이어베이스에서 알림 메시지를 보낼 때 메시지의 click_action 속성을 FLUTTER_NOTIFICATION_CLICK으로 설정해야 합니다. 그렇지 않으면 사용자가 시스템 트레이에서 알림을 클릭할 때 앱으로 알림을 전달할 수 없습니다.
[Do it! 실습] 파이어베이스에서 푸시 알림 보내고 앱에서 확인하기
이번에는 파이어베이스 콘솔에서 푸시 알림을 보내는 실습을 진행해 보겠습니다. 앞의 실습에서 만든 앱을 설치한 기기(또는 에뮬레이터)에서 파이어베이스에서 보낸 푸시 알림이 제대로 도착하는지 확인해 봅시다.
[1단계] 파이어베이스 콘솔에서 [참여 → Cloud Messaging] 메뉴를 클릭하고 <Send your first message>를 클릭합니다.
381
[그림 13-25] 클라우드 메시징


(1) Cloud Messaging
(2) Send your first message
[그림 끝]
[2단계] 메시지 작성기가 나오면 알림 제목과 알림 텍스트를 입력합니다. 입력 후 <다음>을 클릭합니다.
[그림 13-26] 알림 메시지 만들기


(1) 안녕하세요
(2) 플러터 예제입니다.
(3) [다음]
[그림 끝]
[아하!] 테스트 메시지 전송
메시지를 작성할 때 오른쪽 기기 미리보기에 있는 <테스트 메시지 전송>을 누르면 내가 테스트하고 있는 특정 기기에만 메시지를 보낼 수 있습니다. 이때 앞의 실습에서 언급한 토큰을 이용합니다. 이번 실습의 실행 결과에서 콘솔에 토큰 문자열을 출력하는데, 이 값을 등록하고 <테스트>를 클릭하면 내가 테스트하고 있는 기기에만 알림이 전송됩니다.
[그림 13-27] 토큰을 이용해 테스트 메시지 전송


기기에서 테스트
아래 개발 기기의 _FCM 등록 토큰_을 입력하거나 선택하면 이 캠페인을 테스트할 수 있습니다.
FCM 등록 토큰 추가
최근에 사용한 항목 (?)
? fpsJXWf6Q7irDW2CDICBqy:APA91bFYw8dI9bY6GjX37Qm4s-ktjHIwk…
[테스트]
[그림 끝]
[아하! 끝]
382
[3단계] 알림을 누구에게 보낼지를 설정합니다. 여기서는 파이어베이스에 등록한 앱을 선택하고 <다음>을 클릭합니다[각주*].
[각주*] 앱의 패키지명 오른쪽에 <및>을 클릭하면 버전이나 언어, 국가/지역 등 대상을 좀 더 세밀하게 설정할 수 있습니다.[각주 끝]
[그림 13-28] 대상 설정


(1) com.rollcake.firebase_example
(2) [다음]
[그림 끝]
[4단계] 알림을 언제 보낼지 설정합니다. 예약 시간도 설정할 수 있지만 바로 확인하고자 [지금]을 선택하고 <다음>을 클릭합니다.
[그림 13-29] 예약 발송 설정


(1) 지금
(2) [다음]
[그림 끝]
[5단계] 전환 이벤트는 사용자가 알림을 클릭했을 때 발생하는 이벤트를 말합니다. 여기에 애널리틱스의 이벤트와 연동해 분석 자료로 활용할 수 있습니다. 선택 사항이므로 지금은 사용하지 않고 <다음>을 클릭합니다.
[그림 13-30] 전환 이벤트 설정


[다음]
[그림 끝]
[6단계] 추가 옵션에는 알림과 함께 전송할 데이터를 설정합니다. 맞춤 데이터에 키/값의 구조로 데이터를 입력해 놓으면 앱에 JSON 형태로 전달됩니다. 이때 키에 click_action을 입력하고 값에 FLUTTER_NOTIFICATION_CLICK을 입력합니다. 그래야지만 앞의 실습에서 코드를 구현할 때 언급한 것처럼 onResume, onLaunch 함수를 이용할 수 있습니다. 모두 입력했으면 <검토>를 클릭합니다.
383
[그림 13-31] 추가 옵션 설정


(1) click_action
(2) FLUTTER_NOTIFICATION_CLICK
(3) [검토]
[그림 끝]
[7단계] 알림을 보내기 전에 검토 창이 나옵니다. 내용을 검토 후 <게시>를 클릭하면 푸시 알림을 전송합니다.
[그림 13-32] 메시지 검토 후 게시


메시지 검토
알림 콘텐츠: 플러터 예제입니다.
대상: 티켓팅 기준 1개와 일치하는 사용자 세그먼트
예약: 지금 보내기
[게시]
[그림 끝]
앱이 전면에 실행 중이었다면 다음 그림에서 왼쪽처럼 알림 창과 함께 메시지가 표시되고 후면에서 실행 중이거나 종료되었다면 가운데처럼 시스템 트레이에 아이콘이 표시됩니다. 그리고 시스템 트레이를 열어서 알림을 확인한 후 클릭하면 앱이 열립니다.
384
[그림] 실행 결과


안녕하세요, 플러터 예제입니다. OK / 시스템 트레이에 표시된 알림
firebase_example ? 지금
안녕하세요
플러터 예제입니다.
[그림 끝]
그리고 안드로이드 스튜디오의 [실행] 창을 확인해 보면 다음처럼 FCM 토큰과 수신한 메시지를 확인할 수 있습니다.
[글상자]
I/flutter ( 2820): fpsJXWf6Q7irDW2CDlCBqy:APA9...생략...
(...생략...)
I/flutter ( 2820): onMessage: {notification: {title: 안녕하세요, body: 플러터 예제입니다.}, data: {click_action: FLUTTER_NOTIFICATION_CLICK}}

fpsJXWf6Q7irDW2CDlCBqy:APA9...생략... → FCM 토큰
[글상자 끝]
385
13-5 앱에 광고를 넣어 수익화하기
앱을 사용하다 보면 각종 배너나 동영상, 전면 광고까지 다양한 형태의 광고를 봅니다. 구글은 앱 개발자들이 이러한 광고를 앱에 넣어서 수익을 얻을 수 있도록 애드몹(AdMob)이라는 광고 플랫폼을 제공합니다. 이번 절에서는 애드몹을 활용해 앱에 광고를 넣어서 수익화하는 방법을 살펴보겠습니다.
[Do it! 실습] 애드몹에 가입하고 앱 등록하기
[1단계] 애드몹을 이용하려면 우선 가입을 해야 합니다. 파이어베이스 콘솔에 접속한 후 왼쪽 메뉴에서 [참여→ AdMob]을 클릭하고 <AdMob 가입>을 클릭합니다.
[그림 13-33] 애드몹 가입하기


(1) AdMob
(2) AdMob 가입
[그림 끝]
[2단계] 애드몹 가입 화면[각주*]에서 국가, 시간대, 통화, 약관 동의 등 기본 정보를 설정 후 <ADMOB 계정 만들기>를 클릭합니다.
[각주*] 애드몹 가입 화면은 구글 애드센스와 구글 애드워즈에 가입 상태에 따라 달라질 수 있습니다. 이 책에서는 두 서비스에 가입하지 않은 상태를 전제로 합니다.[각주 끝]
386
[그림 13-34] 애드몹 계정 만들기


(1) 대한민국
(2) (UTC+09:00) 서울
(3) 대한민국 원(KRW ￦)
(4) ? 애드센스 이용약관을 읽었으며 약관 준수에 동의합니다.
(5) ADMOB 계정 만들기
[그림 끝]
애드몹에 가입할 때 한 가지 주의할 점은 로그인한 구글 계정에 생년월일 정보가 빠져 있으면 가입할 수 없다는 것입니다. 이때는 중간에 생년월일을 입력하는 과정을 거친 후 다시 시도하면 됩니다.
[3단계] 가입 완료 안내를 확인하고 이메일 수신 여부를 설정한 후 <계속해서 ADMOB 사용>을 클릭합니다.
[그림 13-35] 애드몹 계정 만들기 완료


(1) ? 아니요, ? 아니요, ? 아니요, ? 아니요, ? 아니요
(2) 계속해서 ADMOB 사용
[그림 끝]
[4단계] 이제 애드몹에 새로운 앱을 등록해야 합니다. 홈 화면에서 <시작하기>를 클릭합니다.
387
[그림 13-36] 애드몹 시작하기


[시작하기]
[그림 끝]
[5단계] 새 앱을 설정하는 화면이 나오면 플랫폼과 현재 앱 스토어에 등록되었는지를 설정합니다. 여기서는 [Android]와 [아니오]를 선택하고 <계속>을 클릭합니다.
[그림 13-37] 새 앱 설정 1


(1) ? Android
(2) ? 아니요
(3) [계속]
[그림 끝]
[6단계] 다음으로 앱 이름과 사용자 측정 항목을 설정합니다. 「13-3」 절에서 만든 메모장 앱에 광고를 넣을 것이므로 앱 이름에 Memo App을 입력하고 사용자 측정 항목은 해제한 채 <앱 추가>를 클릭합니다.
[그림 13-38] 새 앱 설정 2


(1) Mome App
(2) ?
(3) [앱 추가]
[그림 끝]
388
[7단계] 애드몹에 앱이 추가되었다는 안내 화면이 나타나면 <완료>를 누릅니다.
[그림 13-39] 새 앱 설정 완료


[완료]
[그림 끝]
[8단계] 앱을 만들었으면 이제 광고를 만들 차례지만, 그전에 앱에서 애드몹 광고를 연결할 때 필요한 앱 ID를 확인해 보겠습니다. 왼쪽 메뉴에서 <앱 설정>을 클릭합니다.
[그림 13-40] 앱 개요


앱 설정
[그림 끝]
[9단계] 앱 설정 화면에서 앱 ID를 확인하고 별도로 기록해 둡니다. 잠시 후 앱에 광고를 넣을 때 사용할 것입니다.
[그림 13-41] 앱 ID 확인


[그림 끝]
389
[Do it! 실습] 배너 광고 만들기
현재 애드몹이 제공하는 광고 형식은 배너, 전면, 리워드, 네이티브 고급 광고, 앱 열기(베타) 등 총 5가지이며 앞으로 계속 늘어날 것입니다. 이 중에서 가장 흔한 배너 광고를 만들어 보겠습니다.
[1단계] 애드몹 메뉴에서 [앱 → 광고 단위]를 누릅니다. 광고 단위가 없으면 <시작하기>가 보입니다. 이 버튼을 클릭합니다.
[그림 13-42] 광고 단위 만들기


(1) 광고 단위
(2) [시작하기]
[그림 끝]
[2단계] 광고 형식을 선택하는 화면이 나오면 [배너]를 클릭합니다. 다른 광고 형식에는 어떤 것이 있는지 훑어보는 것도 좋습니다.
[그림 13-43] 광고 형식 선택


선택
[그림 끝]
390
[3단계] 광고 단위 설정 화면에서는 광고 단위 이름을 하단 배너 등으로 설정한 후 <광고 단위 만들기>를 클릭합니다.
[그림 13-44] 광고 단위 설정


(1) 하단 배너
(2) [광고 단위 만들기]
[그림 끝]
[4단계] 광고 만들기를 완료하면 광고 단위 ID가 생성됩니다. <완료>를 클릭하면 현재 앱에 어떤 광고가 만들어졌는지 확인할 수 있습니다.
[그림 13-45] 광고 단위 확인


? 하단 배너: 배너, 0개 운영중, 0개 사용 설정됨, 적용 불가
[그림 끝]
[Do it! 실습] 앱에 광고 넣기
이제 애드몹 설정을 마쳤으니 앱에 광고를 넣어 보겠습니다. 그런데 아쉽게도 앱에 광고를 넣어도 광고가 바로 노출되지는 않습니다. 애드몹에서 광고를 심의하고 기타 내부 처리를 진행하는 데 1~2일 정도 소요되기 때문입니다[각주*]. 그때까지는 앱에 설정한 광고 영역에 빈칸이 노출됩니다. 다만, 이번 실습에서는 구글에서 제공하는 테스트 아이디와 테스트 광고를 이용해 광고를 바로 확인할 수 있도록 하겠습니다.
[각주*] 상황에 따라 더 많은 시간이 걸릴 수도 있습니다.[각주 끝]
391
[1단계] 안드로이드 스튜디오에서 지금까지 만든 firebase_example 프로젝트를 엽니다. pubspec.yaml 파일을 열고 파이어베이스 애드몹 패키지를 추가합니다.
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
firebase_core: ^0.5.3 # 파이어베이스 기본 패키지
firebase_analytics: ^6.3.0 # 파이어베이스 애널리틱스 패키지
firebase_database: ^4.2.0 # 파이어베이스 데이터베이스 패키지
firebase_messaging: ^7.0.3 # 파이어베이스 메시징 패키지
firebase_admob: ^0.10.3 # 파이어베이스 애드몹 패키지
(...생략...)
[글상자 끝]
[2단계] 안드로이드 스튜디오에서 [File → Open]을 눌러 firebase_example 프로젝트 아래에 있는 android 폴더를 새 창에서 엽니다. 잠시 후 안드로이드 스튜디오가 그래들 구성을 마치면 탐색 창에서 manifests 폴더 아래에 있는 AndroidManifest.xml 파일을 열고 다음 코드를 추가합니다. 이때 앞에서 발급받은 애드몹의 앱 ID(광고 단위 ID 아님)를 입력합니다. 이후 안드로이드 프로젝트는 닫아도 됩니다.
[글상자] manifests/AndroidManifest.xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.rollcake.firebase_example">
<application
android:name="io.flutter.app.FlutterApplication"
android:label="firebase_example"
android:icon="@mipmap/ic_launcher">
<activity
(...생략...)
</activity>
<meta-data
android:name="flutterEmbedding"
android:value="2" />
<meta-data
android:name="com.google.android.gms.ads.APPLICATION_ID"
392
android:value="### 애드몹 앱 ID ###"/>
</application>
</manifest>

### 애드몹 앱 ID ### → 애드몹 앱 ID 넣기
[글상자 끝]
[3단계] 이제 플러터 프로젝트로 와서 애드몹의 광고를 표시하는 코드를 작성합니다. memoPage.dart 파일을 열고 상단에 애드몹 패키지를 import합니다. 그리고 _MemoPage 클래스에 있는 initState() 함수에 애드몹 초기화 함수를 호출합니다. 이때도 애드몹의 앱 ID가 필요합니다.
[글상자] lib/memoPage.dart
(...생략...)
import 'package:firebase_admob/firebase_admob.dart';
class MemoPage extends StatefulWidget { ...생략... }
class _MemoPage extends State<MemoPage> {
(...생략...)
BannerAd bannerAd = BannerAd(
adUnitId: BannerAd.testAdUnitId, // 실전에서는 발급받은 광고 단위 ID를 넣어야 함
size: AdSize.banner,
listener: (MobileAdEvent event) {
print('$event');
},
);
@override
void initState() {
super.initState();
FirebaseAdMob.instance.initialize(appId: '### 애드몹 앱 ID ###');
(...생략...)
_firebaseMessaging.getToken().then((value) { ...생략... });
_firebaseMessaging.configure( ...생략... );
bannerAd
..load()
..show(
393
anchorOffset: 0,
anchorType: AnchorType.bottom,
);
reference.onChildAdded.listen((event) { ...생략... });
}
(...생략...)
[글상자 끝]
_MemoPage 클래스에 배너 광고를 전역 변수로 만들어 어디에서나 접근할 수 있도록 합니다. 이때 adUnitId에는 애드몹에서 광고를 생성할 때 만든 광고 아이디를 넣어야 합니다. 그런데 지금은 곧바로 광고가 노출되는 것을 확인하고자 BannerAd.testAdUnitId를 입력해 구글이 제공하는 테스트 아이디를 넣었습니다.
adSize는 광고 크기를 의미하고 listener는 애드몹에서 광고를 호출할 때 받아오는 데이터입니다. 만약 네트워크에 연결되어 있지 않거나 현재 표시할 수 있는 광고가 없으면 이벤트를 통해 알려주도록 했습니다.
initState() 함수에는 배너를 호출하는 코드를 추가했습니다. 여기서 사용한 .. 구문은 캐스케이드(cascade)라고 합니다. 다트에서 객체에 값을 입력하거나 함수를 호출할 때 캐스케이드를 이용하면 임시 변수를 만들지 않아도 된다는 장점이 있습니다. 다만, 캐스케이드 구문은 반드시 객체를 반환하는 함수만 호출할 수 있습니다.
[4단계] 이 상태로 앱을 실행하면 배너가 보이기는 하지만 플로팅 버튼과 겹칩니다. 이처럼 버튼을 가려 사용자의 행동을 방해하는 앱은 구글에서 애드몹 계정을 정지시키기도 합니다. 광고를 넣을 때는 반드시 사용성을 고려해야 한다는 점을 기억하기 바랍니다.
[그림 13-46] 배너가 버튼을 가리는 예


Nice job! [Test AD] This is a 320×50 test ad.
[그림 끝]
394
[5단계] 버튼이 가려지는 것을 수정하려면 플로팅 버튼에 다음처럼 패딩값을 줍니다.
[글상자] lib/momoPage.dart
(...생략...)
floatingActionButton: Padding(
padding: EdgeInsets.only(bottom: 40),
child: FloatingActionButton(
onPressed: () { ...생략... },
child: Icon(Icons.add),
),
),
(...생략...)
[글상자 끝]
[그림] 실행 결과


Nice job! [Test AD] This is a 320×50 test ad.
[그림 끝]
[Do it! 실습] 전면 광고 만들기
이번에는 전면 광고를 생성하는 코드를 작성해 보겠습니다. 전면 광고는 광고 효과는 좋지만 자주 노출되면 사용자에게 피로감을 주기 때문에 횟수와 시점을 적절하게 고려해야 합니다. 전면 광고 역시 앞의 배너 광고와 마찬가지로 애드몹에서 광고를 만들고 아이디를 발급받아 넣어야 하지만, 실습용으로 바로 노출되는 모습을 보이고자 구글이 제공하는 테스트 광고용 아이디를 이용하겠습니다.
[1단계] 메모를 작성하고 저장하는 순간에 광고가 나오도록 만들어 보겠습니다. memoAdd.dart 파일을 열고 _MemoAddPage 클래스에 전면 광고 객체를 초기화하는 코드를 추가합니다.
[글상자] lib/memoAdd.dart
import 'package:firebase_admob/firebase_admob.dart';
(...생략...)
class _MemoAddPage extends State<MemoAddPage> {
TextEditingController titleController;
TextEditingController contentController;
395
InterstitialAd fullPageAdvertise = InterstitialAd(
adUnitId: InterstitialAd.testAdUnitId, // 실전에서는 발급받은 광고 단위 ID를 넣어야 함
listener: (MobileAdEvent event) {
print('$event');
},
);
@override
void initState() {
(...생략...)
[글상자 끝]
[2단계] 이어서 <저장하기> 버튼을 누르면 메모를 서버에 저장 후 전면 광고가 호출되도록 build() 함수의 FlatButton 위젯에 다음 코드를 추가합니다.
[글상자] lib/memoAdd.dart
(...생략...)
FlatButton(
onPressed: () {
(...생략...)
});
fullPageAdvertise
..load()
..show(
anchorType: AnchorType.bottom,
anchorOffset: 0.0,
);
},
child: Text('저장하기'),
shape: OutlineInputBorder(borderRadius: BorderRadius.circular(1)),
)
(...생략...)
[글상자 끝]
이제 앱을 다시 빌드 후 실행하고 플로팅 버튼을 눌러 메모 작성 페이지로 이동합니다. 제목과 내용을 입력 후 <저장하기> 버튼을 클릭하면 메모가 저장되면서 다음 실행 결과처럼 테스
396
트용 전면 광고가 노출됩니다. 전면 광고 왼쪽 위의 <X> 버튼을 누르면 다시 메인 화면으로 돌아옵니다.
[그림] 실행 결과


메모 추가 - 제목: 광고 테스트, 내용: 광고 테스트, [저장하기]
Nice job!, This is an interstitial test ad., Google AdMob
[그림 끝]
앱에 광고를 넣어 수익화하는 방법을 살펴봤습니다. 구글은 검색을 비롯한 여러 서비스를 운영하면서 얻은 사용자 정보를 이용한 맞춤 광고를 제공합니다. 따라서 애드몹에 광고를 등록하고 앱에 노출하기만 하면 각 사용자가 좋아할 만한 광고를 알아서 노출해 줍니다. 그리고 사용자가 광고를 클릭해 광고주가 설정한 목표(앱 다운로드나 물건 구매 등)를 달성하면 수익을 얻을 수 있으며 이 수익이 쌓여 100달러 이상이 되면 출금할 수 있습니다.
지금까지 파이어베이스의 긴 여정을 마쳤습니다. 파이어베이스는 기능도 많고 자주 업데이트되므로 지속적으로 관심을 기울여야 합니다. 그래도 파이어베이스 덕분에 서버를 따로 구축하지 않고도 앱을 운영하는 백엔드 기술을 손쉽게 이용할 수 있습니다.
397
넷째마당 플러터 앱 만들고 출시하기
지금까지 다트 언어를 시작으로 플러터의 핵심 기능과 파이어베이스 활용법까지 살펴봤습니다.
넷째마당에서는 지금까지 배운 내용을 바탕으로 상용 앱 수준의 플러터 앱을 만들고 광고를 붙여서 안드로이드 공식 앱 스토어인 구글 플레이(Google Play)에 출시하는 전체 과정을 실습합니다.
14 오픈 API를 활용한 여행 정보 앱 만들기
15 여행 정보 앱 완성하고 출시하기
398
14 오픈 API를 활용한 여행 정보 앱 만들기
앱을 기획할 때 중요한 요소 중 하나는 앱을 통해 서비스할 데이터입니다. 따라서 사용자에게 서비스할 데이터를 어떻게 모으고 어떻게 가공해서 보여줄 것인지를 고민해야 합니다. 좋은 데이터는 그 자체로 앱의 경쟁력이 되기 때문입니다.
이번 장에서는 앱에서 오픈 API를 사용해 양질의 데이터를 무료로 이용하는 방법을 살펴봅니다. 그리고 오픈 API를 활용한 여행 정보 앱을 만들어 보겠습니다. 이번 장에서는 로그인 기능 등을 만들고 15장에서 전체를 완성해 보겠습니다.
14-1 오픈 API 이용하기
14-2 여행 정보 앱 스케치하기
14-3 여행 정보 앱 프로젝트 시작하기
399
14-1 오픈 API 이용하기
기업에서는 저마다 좋은 데이터를 얻으려고 많은 돈을 씁니다. 그러나 돈을 들이지 않고도 양질의 데이터를 얻는 방법이 있습니다. 정부기관이나 몇몇 기업은 자신들이 가진 데이터를 누구나 쓸 수 있도록 무료로 공개하는데, 이를 오픈 API라고 부릅니다.
한국관광공사는 TourAPI라는 별도의 웹 사이트(api.visitkorea.or.kr)에서 관광 정보를 제공합니다. 매년 공모전을 개최할 만큼 충실히 운영되고 있습니다. 여기서는 공공데이터포털을 통해 제공하는 오픈 API를 다루는 방법을 실습할 예정입니다. 대부분 오픈 API 활용법은 큰 차이가 없으므로 이번에 제대로 배워 두면 다른 기관이나 회사가 제공하는 오픈 API도 문제없이 활용할 수 있을 것입니다.
[그림 14-1] TourAPI 소개


[그림 끝]
[Do it! 실습] 관광 정보 API 신청하기
공공데이터포털(www.data.go.kr)은 여러 공공기관이 생성 또는 취득한 정보를 한 곳에서 제공하는 통합 사이트입니다. 이곳에서 교육, 보건, 교통, 환경, 법률 등 다양한 종류의 데이터에 접근할 수 있습니다.
400
[1단계] 먼저 공공데이터포털 사이트 www.data.go.kr에 접속해 일반 회원으로 가입 후 로그인합니다. 그다음 메인 화면 검색란에 ‘국문 관광정보 서비스’라 입력 후 검색합니다.
[그림 14-2] 공공데이터포털에서 오픈 API 검색


(1) 국문 관광정보 서비스
(2) 2. 미세먼지
[그림 끝]
[2단계] 화면에 검색 결과가 나오면 위쪽 분류에서 [오픈 API]를 선택하고 아래 오픈 API 검색 결과에서 [국문 관광 정보 서비스]를 클릭합니다.
[그림 14-3] 국문 관광정보 서비스 오픈 API


(1) 오픈 API(4,328개)
(2) [문화관광][공공기관], [XML] 국문 관광정보 서비스, 수정일 2020-04-15, 조회수 15616, 활용신청 10985
[그림 끝]
[3단계] 국문 관광정보 서비스의 상세 정보가 열리면 <활용신청>을 클릭합니다
[그림 14-4] 국문 관광정보 서비스 활용 신청


[활용신청]
[그림 끝]
401
[4단계] 오픈 API 개발계정 신청 화면이 나오면 활용 목적을 [앱개발]로 선택하고 적당한 목적을 작성합니다. 시스템 유형은 기본으로 [일반]이 체크되어 있습니다.
[그림 14-5] 오픈 API 신청


(1) ? 앱개발 (모바일, 솔루션 등)
(2) 이지스퍼블리싱 출판사의 『Do it! 플러터 앱 프로그래밍』 책의 오픈 API 활용 실습
(3) ? 일반
[그림 끝]
상세 기능은 모두 선택하고 마지막 라이선스 표시의 [동의합니다]에 체크한 후 <활용신청>을 클릭합니다.
[그림 14-6] 라이선스에 동의 후 활용 신청


(4) ? 모양 13개
(5) ? 동의합니다.
(6) [활용신청]
[그림 끝]
402
신청을 완료하면 다음처럼 1~2시간 후 API를 호출할 수 있다는 알림 창이 나옵니다.
[그림 14-7] API 호출 안내


www.data.go.kr 내용:
신청이 완료되었습니다. 신청된 API는 1~2시간 후 호출 가능합니다.
※ 일부 API에서 24시간 후 인증이 가능한 API가 있습니다.
빠른 시일내에 모든 API가 1시간 이내 인증 가능하도록 개선하겠습니다.
[확인]
[그림 끝]
[Do it! 실습] 관광 정보 데이터 확인하기
앞에서 신청한 관광 정보 오픈 API가 제공하는 데이터를 확인해 보겠습니다. 이 실습은 서비스 활용 신청 후 1~2시간 후에 진행해야 합니다. 신청이 승인되었더라도 데이터베이스 관련 작업 등으로 일정 시간이 지나야 사용할 수 있기 때문입니다.
[1단계] 공공데이터포털에 로그인한 후 [마이페이지 > 오픈 API > 개발계정]에서 승인된 [국문 관광정보 서비스]를 클릭합니다.
[그림 14-8] 승인된 오픈 API


[문화관광][한국관광공사]
[활용신청][승인] 국문 관광정보 서비스
신청일 2020-12-10, 만료예정일 2022-12-10
[그림 끝]
개발계정 상세보기 화면을 보면 일반 인증키가 보입니다. 이 인증키가 내 계정에 할당된 관광정보 API 키입니다. 이후에 앱을 개발할 때 API 인증키를 넣는 곳에 필요하므로 따로 복사해 두어도 좋습니다. 다만, 내 계정에 할당된 인증키이므로 유출되지 않도록 합니다.
[그림 14-9] 인증키 표시 화면


[그림 끝]
403
[2단계] 아래쪽에 보이는 상세 기능 정보에서 [지역기반 관광정보조회]를 찾아서 <확인>을 클릭하면 요청 변수가 열립니다.
[그림 14-10] 지역기반 관광정보조회


[확인], [미리보기]
[그림 끝]
요청 변수는 데이터를 어떤 형태로 볼 것인지를 지정하는 것으로, 각 변숫값을 어떻게 설정하느냐에 따라 요청 URL이 결정되고 그에 맞게 서버에서 데이터를 불러옵니다. 우선 기본으로 둔 채 <미리보기>를 클릭합니다. 그러면 다음처럼 XML 형태로 데이터가 나타납니다.
[그림 14-11] 데이터를 요청한 결과


[그림 끝]
404
그런데 신청 후 곧바로 접속하면 다음처럼 오류가 발생합니다. 이때는 활용 신청 완료 때 보았던 알림 메시지처럼 1~2시간 후에 다시 시도해 보기 바랍니다.
[그림 14-12] 데이터 불러오기 오류


This XML file does not appear to have any style information associated with it. The document tree is shown below.
[그림 끝]
[3단계] 데이터를 제대로 가져오기 시작하면 웹 브라우저 주소창의 요청 URL 마지막에 &_type=json을 추가한 후 [Enter]를 눌러보세요. 그러면 데이터가 JSON 형태로 바뀝니다. 이번 앱에서는 JSON 형태로 데이터를 불러와서 이용할 것입니다.
[그림 14-13] JSON 데이터로 불러 온 관광 정보


[그림 끝]
공공데이터포털에서는 모든 데이터를 이러한 방법으로 사용할 수 있습니다. 일반 기업의 데이터 역시 구체적인 방법은 조금 달라도 인증키를 바탕으로 API를 요청하는 전체 흐름은 비슷합니다. 이제 데이터를 준비했으니 본격적으로 앱을 만들어 보겠습니다.
405
14-2 여행 정보 앱 스케치하기
여기서 만들 앱은 ‘모두의 여행’입니다. 이름에서 알 수 있듯이 이 앱은 누구나 이용할 수 있는 여행 정보를 제공합니다. 모두의 여행이 제공하는 주요 화면은 다음과 같습니다. 본격적으로 앱을 개발하기 전에 각 화면에서 어떤 기능을 구현할 것인지 미리 살펴보겠습니다.
[글상자]
- 인트로와 로그인 화면
- 메인 화면
- 상세보기 화면
- 설정 화면
[글상자 끝]
인트로와 로그인 화면
인트로 화면이 등장한 후 로그인 화면으로 넘어갑니다. 여기서는 사용자가 아이디와 비밀번호를 입력해 로그인하거나 회원가입을 할 수 있습니다. 애니메이션, 파이어베이스의 실시간 데이터베이스 등을 이용해 기능을 구현할 것입니다.
[그림 14-14] 인트로와 로그인 화면


모두의 여행, 아이디, 비밀번호, 회원가입, 로그인
[그림 끝]
406
메인 화면
로그인한 다음에는 메인 화면을 띄웁니다. 메인 화면 아래쪽에는 탭바를 만들어서 탭별로 [검색], [즐겨찾기], [설정] 등 3가지 기능을 넣겠습니다. 여행지 목록을 누르면 상세 페이지로 넘어가는 기능도 구현하겠습니다. 여기서는 애니메이션, 구글 지도, 네이티브 API 통신, 파이어베이스, 애드몹, SQLite 데이터베이스 등을 이용할 것입니다.
[그림 14-15] 메인 화면


검색하기 - 강남구 / 관광지 [검색하기]
강남 시티투어 - 트롤리버스
주소: 서울특별시 강남구 압구정로 161
능인선원
주소: 서울특별시 강남구 양재대로 340
대모산공원
주소: 서울특별시 강남구 광평로10길 50
도산공원
주소: 서울특별시 강남구 도산대로45길
봉은사(서울)
[그림 끝]
상세보기 화면
관광 장소에 별점을 매기거나 장애인이 이용할 수 있는 편의시설 정보를 저장할 수 있도록 만듭니다. 이러한 데이터는 서버에 저장해야 합니다. 따라서 파이어베이스의 실시간 데이터베이스를 이용하겠습니다.
[그림 14-16] 상세보기 화면


신사동 가로수길
서울특별시 강남구 신사동
지체 장애 이용 점수 : 4
시각 장애 이용 점수 : 5
작성자 : easys
[새로 작성하기]
후기
[그림 끝]
407
설정 화면
푸시 알림, 로그아웃, 회원 탈퇴 등 기본적인 설정 화면을 만들어 보겠습니다. 그리고 13장에서 다룬 애드몹을 이용해 배너 광고도 추가해 보겠습니다.
[그림 14-17] 설정 화면


푸시 메시지, [로그아웃], [회원 탈퇴]
[그림 끝]
이렇게 4가지 주요 화면으로 구성된 모두의 여행 앱의 전체 흐름도는 오른쪽 그림과 같습니다.
[그림 14-18] 모두의 여행 전체 흐름도


- 인트로/로그인
1. 검색
(1) 상세 페이
1) 장애인 이용 정보
2) 후기
2. 즐겨찾기
3. 설정
[그림 끝]
모두의 여행 앱은 이 책의 대미를 장식할 프로젝트입니다. 보통의 실습용 프로젝트보다는 규모가 큰 편이어서 소스가 많은 지면을 차지합니다. 따라서 전체 소스는 온라인을 통해 제공하겠지만 될 수 있으면 책에도 담아서 독자가 쉽게 따라 할 수 있도록 할 예정입니다.
또한, 앱을 개발하면서 플러터와 안드로이드 프로젝트를 왔다 갔다 하고 여러 API를 연동하는 등 지금까지 해온 실습보다는 조금 복잡합니다. 따라서 코드 설명을 중복하기보다는 실습 진행에 집중하면서 완전한 앱을 만드는 전체 과정을 살펴보겠습니다. 지금까지 배운 내용을 기억하면서 한 단계씩 차근차근 만들어 보기 바랍니다.
408
14-3 여행 정보 앱 프로젝트 시작하기
이제 본격적으로 모두의 여행 앱을 만들어 보겠습니다. 제일 처음 만들 부분은 인트로와 로그인 화면입니다. 사용자가 처음 접하는 화면인 만큼 적당한 애니메이션으로 꾸미고 로그인과 회원가입 기능을 구현합니다.
프로젝트 만들기
안드로이드 스튜디오를 실행하고 [File → New Flutter Project]를 클릭해 새 프로젝트를 만듭니다. 필자는 프로젝트 이름을 modu_tour라고 정했습니다. 그런데 프로젝트 만들기 2번째 단계에서 패키지 이름을 정할 때는 주의를 기울여야 합니다. 왜냐하면 앞 장에서 만들었던 것처럼 example이라는 단어를 사용하면 구글 플레이에 앱을 등록할 때 거부될 수 있기 때문입니다.
패키지 이름은 구글 플레이에서 고유합니다. 따라서 기존에 등록된 패키지명과 중복되면 앱을 등록할 수 없습니다. 또한, 한 번 정하면 앱 출시 후 변경할 수 없으므로 신중하게 정해야 합니다. 따라서 보통은 다음과 같은 형식으로 짓습니다.
[글상자]
com.회사명(또는 본인 닉네임).프로젝트명
[글상자 끝]
필자는 com.easyspub.modu_tour라고 입력했지만 구글 플레이에 앱을 등록할 계획이 있는 독자는 다른 패키지명을 입력하기 바랍니다. 그리고 이후 패키지명을 입력하는 부분에는 자신의 고유한 패키지명을 사용하기 바랍니다.
[그림 14-19] 패키지 이름 설정


New Flutter Application
set the package name
Application and plugins need to generate platform-specific code
Package name: com.easyspub.modu_tour
Platform channel language
? Include Kotlin support for Android code
? Include Swift support for iOS code
[Finish]
[그림 끝]
409
파이어베이스 설정하기
프로젝트를 만들었으면 13장에서 다뤘던 것처럼 파이어베이스 설정을 진행합니다. 여기서 모든 과정을 다시 설명하려면 많은 지면이 필요하므로 간략하게 요약만 하겠습니다. 단계별 자세한 내용은 13장을 참고하기 바랍니다.
1. 파이어베이스 콘솔에서 moduTour라는 이름으로 새 프로젝트 만들기
2. moduTour 프로젝트에 안드로이드 앱 추가하기
→ 플러터 프로젝트 생성 시 지정했던 패키지 이름 사용
→ google-services.json 파일 내려받아서 안드로이드 프로젝트의 app 폴더에 넣기
3. 안드로이드 프로젝트에서 build.gradle(Project: android) 파일에 클래스 경로 추가하기
→ classpath 'com.google.gms:google-services:4.3.4'
4. 안드로이드 프로젝트에서 build.gradle(Module: android.app) 파일에 구글 서비스 플러그인 추가하기
→ apply plugin: 'com.google.gms.google-services'
5. 실시간 데이터베이스 추가하기
→ 읽기(.read)와 쓰기(.write) 규칙 true로 수정하기
→ 데이터베이스 URL 복사해 놓기
6. 애드몹에 안드로이드 앱 추가하기
→ 앱 ID 복사해 놓기
→ 안드로이드 프로젝트에서 AndroidManifest.xml 파일에 메타 데이터 추가하기(앱 ID 이용)
[Do it! 실습] 인트로와 로그인 화면 만들기
인트로와 로그인 화면은 11장에서 다룬 애니메이션과 13장에서 다룬 실시간 데이터베이스를 이용해서 구현하겠습니다. 로그인은 회원가입을 전제로 사용자가 아이디와 비밀번호를 입력하고 <로그인> 버튼을 눌렀을 때 데이터베이스에 있는 정보와 일치하는지 확인해서 회원인지를 판단합니다. 이때 데이터베이스는 파이어베이스의 실시간 데이터베이스를 사용합니다.
[QR 코드] 소스 보기


[QR 코드 끝]
410
[1단계] 플러터 프로젝트에서 pubspec.yaml 파일을 열고 다음처럼 이 앱에 필요한 패키지를 등록합니다. 그리고 플러터 명령줄에서 <Pub get>을 눌러 패키지를 내려받습니다.
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
cupertino_icons: ^1.0.0
firebase_core: ^0.5.1
firebase_analytics: ^6.1.0
firebase_database: ^4.2.0
firebase_messaging: ^7.0.3
firebase_admob: ^0.10.2
http: ^0.12.2
sqflite: ^1.3.2
path: ^1.7.0
shared_preferences: ^0.5.12
crypto: ^2.1.5
(...생략...)
[글상자 끝]
참고로 독자가 이 실습을 진행할 때는 각 패키지가 업데이트되었을 수 있습니다. 그러나 여기서는 예상치 못한 오류를 방지하고자 필자가 테스트를 완료한 버전으로 진행하기를 추천합니다.
[아하!] 패키지 버전을 생략하면 최신 버전으로 내려받아요
패키지 이름 다음에 버전을 생략하면 가장 최신 버전으로 내려받습니다. 그러나 버전을 명시하는 것을 추천합니다. 늘 최신 버전으로 사용하면 API가 변경되었을 때 대응하기 어렵고 아직 안정화되지 않아서 버그가 있기도 합니다. 따라서 검증된 버전을 명시해서 사용하고 이상이 없으면 버전을 올리면서 테스트하는 것이 좋습니다.
[아하! 끝]
411
[2단계] 로그인은 회원가입을 전제로 하므로 데이터베이스를 이용합니다. 10장에서 데이터베이스를 다룰 때 살펴본 것처럼 데이터베이스와 연동해서 데이터를 다룰 때는 데이터 구조를 클래스로 만들어서 사용하면 편리합니다.
lib 폴더에 data라는 폴더를 만듭니다. 그 안에 user.dart 파일을 새로 만들고 회원 정보를 담을 User라는 이름의 클래스를 작성합니다.
[글상자] lib/data/user.dart
import 'package:firebase_database/firebase_database.dart';
class User {
String key;
String id;
String pw;
String createTime;
User(this.id, this.pw, this.createTime);
User.fromSnapshot(DataSnapshot snapshot)
: key = snapshot.key,
id = snapshot.value['id'],
pw = snapshot.value['pw'],
createTime = snapshot.value['createTime'];
toJson() {
return {
'id': id,
'pw': pw,
'createTime': createTime,
};
}
}
[글상자 끝]
[3단계] 그다음 lib 폴더 아래 login.dart 파일을 만들고 다음 코드를 작성해 로그인 화면을 만듭니다. 소스가 길어서 두 부분으로 나누어 작성합니다.
412
[글상자] lib/login.dart
import 'dart:async';
import 'dart:convert';
import 'dart:math';
import 'package:crypto/crypto.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/material.dart';
import 'package:modu_tour/data/user.dart';
import 'package:firebase_admob/firebase_admob.dart';
class LoginPage extends StatefulWidget {
@override
State<StatefulWidget> createState() => _LoginPage();
}
class _LoginPage extends State<LoginPage> with SingleTickerProviderStateMixin {
FirebaseDatabase _database;
DatabaseReference reference;
String _databaseURL = '###파이어베이스 실시간 데이터베이스 URL 넣기###';
double opacity = 0;
AnimationController _animationController;
Animation _animation;
TextEditingController _idTextController;
TextEditingController _pwTextController;
@override
void initState() {
super.initState();
_idTextController = TextEditingController();
_pwTextController = TextEditingController();
_animationController = AnimationController(duration: Duration(seconds: 3),
vsync: this);
_animation = Tween<double>(begin: 0, end: pi * 2)
.animate(_animationController);

'###파이어베이스 실시간 데이터베이스 URL 넣기###' → 파이어베이스에서 발급받은 실시간 데이터베이스 URL을 이곳에 입력하세요.
413
_animationController.repeat();
Timer(Duration(seconds: 2), () { // 페이지 생성 후 2초 후 타이머 시작
setState(() {
opacity = 1;
});
});
_database = FirebaseDatabase(databaseURL: _databaseURL);
reference = _database.reference().child('user');
}
@override
void dispose() {
_animationController.dispose();
super.dispose();
}
@override
Widget build(BuildContext context) {
return Scaffold(
body: Container(
child: Center(
child: Column(
children: <Widget>[
AnimatedBuilder(
animation: _animationController,
builder: (context, widget) {
return Transform.rotate(
angle: _animation.value,
child: widget,);
},
child: Icon(
Icons.airplanemode_active,
color: Colors.deepOrangeAccent,
size: 80,),),
SizedBox(
height: 100,
child: Center(
414
child: Text(
'모두의 여행',
style: TextStyle(fontSize: 30),),),),
AnimatedOpacity(
opacity: opacity,
duration: Duration(seconds: 1),
child: Column(
children: <Widget>[
SizedBox(
width: 200,
child: TextField(
controller: _idTextController,
maxLines: 1,
decoration: InputDecoration(labelText: '아이디',
border: OutlineInputBorder()),),),
SizedBox(
height: 20,),
SizedBox(
width: 200,
child: TextField(
controller: _pwTextController,
obscureText: true,
maxLines: 1,
decoration:
InputDecoration(labelText: '비밀번호',
border: OutlineInputBorder()),),),
(...생략...)
],),)],
mainAxisAlignment: MainAxisAlignment.center,
),),),);
}
void makeDialog(String text) {
showDialog(
context: context,
builder: (context) {
415
return AlertDialog(
content: Text(text),
);
});
}
}
[글상자 끝]
이어서 아이디와 비밀번호를 입력하는 SizedBox 위젯 다음에 Row 위젯으로 회원가입과 로그인 버튼을 나란히 만들고 각 버튼을 눌렀을 때 이동할 경로를 등록합니다.
[글상자] lib/login.dart
(...생략...)
Row(
children: <Widget>[
FlatButton(
onPressed: () {
Navigator.of(context).pushNamed('/sign');
},
child: Text('회원가입')),
FlatButton(
onPressed: () {
if (_idTextController.value.text.length == 0 ||
_pwTextController.value.text.length == 0) {
makeDialog('빈칸이 있습니다');
} else {
reference
.child(_idTextController.value.text)
.onValue
.listen((event) {
if (event.snapshot.value == null) {
makeDialog('아이디가 없습니다');
} else {
reference
.child(_idTextController.value.text)
.onChildAdded
.listen((event) {
416
User user = User.fromSnapshot(event.snapshot);
var bytes = utf8.encode(_pwTextController.value.text);
var digest = sha1.convert(bytes);
if (user.pw == digest.toString()) {
Navigator.of(context).pushReplacementNamed('/main',
arguments: _idTextController.value.text);
} else {
makeDialog('비밀번호가 틀립니다');
}});}});}
},
child: Text('로그인'))
],
mainAxisAlignment: MainAxisAlignment.center,
)
(...생략...)
[글상자 끝]
사용자가 입력한 아이디/비밀번호와 데이터베이스에서 가져온 아이디/비밀번호를 비교해서 일치하면 로그인 후 메인 화면(/main)으로 이동하고 그렇지 않으면 알림 창으로 로그인을 거부한 이유를 알려줍니다.
그런데 코드 중 다음 두 줄이 낯설게 느껴집니다.
[글상자]
var bytes = utf8.encode(_pwTextController.value.text);
var digest = sha1.convert(bytes);
[글상자 끝]
이 코드는 사용자가 입력한 비밀번호를 utf8로 인코딩한 후 sha1으로 변경합니다. SHA-1은 해시 알고리즘(hash algorithm)을 이용해 특정 단어를 무작위 텍스트로 바꿔주는 함수입니다. 해시 알고리즘을 사용하면 문자열을 짧은 길이의 키로 변환하고 고속으로 검색할 수 있게 해줄 뿐만 아니라 서버에 암호를 저장할 때 원문을 저장하지 않기 때문에 보안에도 좋습니다.
[4단계] 각 페이지를 이동할 때는 라우트 기능을 이용하기 위해 main.dart 파일을 다음처럼 수정합니다. 앱이 시작되면 처음에 LoginPage가 열리게 합니다. 그리고 새 페이지를 만들 때마다 routes에 경로와 함께 추가해서 페이지 이동을 편리하게 관리하겠습니다.
417
[글상자] lib/main.dart
import 'package:firebase_admob/firebase_admob.dart';
import 'package:flutter/material.dart';
import 'package:modu_tour/signPage.dart';
import 'login.dart';
void main() => runApp(MyApp());
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
FirebaseAdMob.instance.initialize(appId: '##애드몹 앱 ID 넣기##');
return MaterialApp(
title: '모두의 여행',
theme: ThemeData(
primarySwatch: Colors.blue,
),
initialRoute: '/',
routes: {
'/': (context) => LoginPage(),
'/sign': (context) => SignPage(),
},);}
}

'##애드몹 앱 ID 넣기##'); → 애드몹에서 발급받은 앱 ID 넣기
[글상자 끝]
[5단계] 앞에서 만든 로그인 화면에서 <회원가입>을 누르면 이동할 회원가입 페이지를 만들어 보겠습니다. 로그인을 하려면 먼저 데이터베이스에 사용자의 정보가 등록되어 있어야 하므로 회원가입 페이지에서 사용자의 아이디와 비밀번호를 데이터베이스에 등록합니다. lib 폴더에 signPage.dart 파일을 생성한 후 SingPage 클래스를 만듭니다.
[글상자] lib/signPage.dart
import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/material.dart';
418
import 'package:modu_tour/data/user.dart';
class SignPage extends StatefulWidget {
@override
State<StatefulWidget> createState() => _SignPage();
}
class _SignPage extends State<SignPage> {
FirebaseDatabase _database;
DatabaseReference reference;
String _databaseURL = '###파이어베이스 실시간 데이터베이스 URL 넣기###';
TextEditingController _idTextController;
TextEditingController _pwTextController;
TextEditingController _pwCheckTextController;
@override
void initState() {
super.initState();
_idTextController = TextEditingController();
_pwTextController = TextEditingController();
_pwCheckTextController = TextEditingController();
_database = FirebaseDatabase(databaseURL: _databaseURL);
reference = _database.reference().child('user');
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('회원가입'),
),
body: Container(
child: Center(
child: Column(
children: <Widget>[
SizedBox(
419
width: 200,
child: TextField(
controller: _idTextController,
maxLines: 1,
decoration: InputDecoration(
hintText: '4자 이상 입력해주세요',
labelText: '아이디', border: OutlineInputBorder()),),),
SizedBox(
height: 20,),
SizedBox(
width: 200,
child: TextField(
controller: _pwTextController,
obscureText: true,
maxLines: 1,
decoration: InputDecoration(
hintText: '6자 이상 입력해주세요',
labelText: '비밀번호', border: OutlineInputBorder()),),),
SizedBox(
height: 20,),
SizedBox(
width: 200,
child: TextField(
controller: _pwCheckTextController,
obscureText: true,
maxLines: 1,
decoration: InputDecoration(labelText: '비밀번호확인',
border: OutlineInputBorder()),),),
SizedBox(
height: 20,),
FlatButton(
onPressed: () {
if (_idTextController.value.text.length >= 4 &&
_pwTextController.value.text.length >= 6) {
if (_pwTextController.value.text ==
_pwCheckTextController.value.text) {
var bytes = utf8.encode(_pwTextController.value.text);
var digest = sha1.convert(bytes);
420
reference
.child(_idTextController.value.text)
.push()
.set(User(_idTextController.value.text,
digest.toString(), DateTime.now().toIso8601String())
.toJson())
.then((_) {
Navigator.of(context).pop();
});
} else {
makeDialog('비밀번호가 틀립니다');
}
} else {
makeDialog('길이가 짧습니다');
}
},
child: Text(
'회원가입',
style: TextStyle(color: Colors.white),),
color: Colors.blueAccent,)],
mainAxisAlignment: MainAxisAlignment.center,),
),),);
}
void makeDialog(String text) {
showDialog(
context: context,
builder: (context) {
return AlertDialog(
content: Text(text),
);
});
}
}
[글상자 끝]
421
회원가입 페이지에는 아이디, 비밀번호, 비밀번호 확인을 입력하는 텍스트필드를 만든 후 회원가입 버튼을 누르면 데이터베이스에 회원 정보를 등록하고 pop() 함수를 호출해 다시 로그인 페이지로 이동하도록 했습니다. 그리고 문자열을 입력받아서 AlertDialog로 알림 창을 표시해 주는 makeDialog() 함수도 만들었습니다. 알림 창처럼 자주 이용하는 코드는 이렇게 별도의 함수로 만들어 사용하면 편리합니다.
[6단계] 로그인과 회원가입 기능이 있는 인트로와 로그인 화면을 완성했습니다. 앱을 빌드 후 실행하면 비행기 아이콘이 빙글빙글 돌아가는 인트로 화면이 포함된 로그인 화면을 볼 수 있습니다.
[그림] 실행 결과


[회원가입] → 회원 가입: 아이디 easys, 비밀번호 ******, 비밀번호확인 ******, [회원 가입]
[회원 가입] → 모두의 여행: 아이디, 비밀번호, 회원가입, 로그인
[그림 끝]
로그인 화면에서 <회원가입> 버튼을 눌러 회원 정보를 등록해 보세요. 다시 로그인 화면으로 돌아오면 등록한 아이디와 비밀번호를 입력 후 <로그인> 버튼을 누르면 로그인이 됩니다. 아직 메인 화면을 만들지 않았으므로 로그인 후 화면 변화는 없습니다.
[7단계] 그럼 회원가입이 제대로 됐는지 어떻게 확인할 수 있을까요? 파이어베이스 콘솔에서 실시간 데이터베이스를 확인하면 됩니다. 회원가입을 마쳤으면 웹 브라우저로 파이어베이스
422
콘솔에 접속 후 왼쪽 메뉴에서 [Realtime Database]를 클릭합니다. 그러면 데이터 탭에 다음과 같은 형태로 회원 정보가 등록된 것을 확인할 수 있습니다. pw 항목의 알 수 없는 문자열은 SHA-1 알고리즘으로 저장된 비밀번호입니다.
[그림 14-20] 데이터베이스에 저장된 회원 정보


easys
MOAiTo1onAm_wQVwjIM
createTime: "2020-12-10T17:17:24.745774"
id: "easys"
pw: "7c4a8d09ca3762af61e59520943dc26494f8941b"
[그림 끝]
그런데 사용자 정보는 주의해서 다뤄야 하므로 상용 앱에서는 이렇게 데이터베이스에서 직접 가져와서 비교하는 코드를 작성하지는 않습니다. 일반적으로 아이디와 비밀번호처럼 민감한 데이터는 보안이 강화된 별도의 서버에 보관해서 확인하고 그 결괏값만 전달받는 식으로 구현합니다.
[아하!] 간편 로그인 기능
요즘은 페이스북이나 구글 등 유명한 서비스에 가입된 계정으로 로그인할 수 있는 기능을 많이 이용합니다. 파이어베이스는 이러한 간편 로그인이나 이메일 회원가입도 지원합니다. 플러터에서 이러한 기능을 구현하려면 firebase_auth 패키지(pub.dev/packages/firebase_auth)를 이용합니다.
[아하! 끝]
423
15 여행 정보 앱 완성하고 출시하기
이번 장은 14장에서 만든 ‘모두의 여행’ 앱의 나머지 부분을 완성합니다. 특히 관광 정보 오픈 API와 구글 지도 등 외부 라이브러리를 활용하는 법을 자세하게 다룹니다. 그리고 완성한 앱을 안드로이드 앱 마켓인 구글 플레이에 출시하는 과정까지 진행해 보겠습니다.
15-1 메인 화면 만들기
15-2 상세보기 화면 만들기
15-3 즐겨찾기 화면 만들기
15-4 설정 화면 만들기
15-5 구글 플레이에 앱 출시하기
424
15-1 메인 화면 만들기
이번 절에서는 14장에서 만든 modu_tour 프로젝트에 이어서 로그인에 성공했을 때 보여줄 메인 화면을 만들어 보겠습니다. 메인 화면은 관광 정보 목록과 즐겨찾기, 설정 페이지가 통합된 형태입니다. 따라서 3개의 서브 페이지를 먼저 만들고 마지막에 메인 화면에서 이를 통합하는 식으로 진행하겠습니다.
‘모두의 여행’ 앱의 전체 파일 구조는 다음과 같습니다. lib 폴더 아래 data와 main 폴더가 있고 각 폴더에는 데이터와 화면 구성 파일이 있습니다. 이번 장을 모두 마치면 다음과 같은 파일 구조로 ‘모두의 여행’ 앱이 완성됩니다.
? pubspec.yaml: 플러터 환경 설정 파일. 주로 외부 라이브러리를 등록할 때 사용
? lib/data/disableInfo.dart: 장애인 이용 정보 데이터 구성
? lib/data/listData.dart: 관광지 지역과 종류 데이터 구성
? lib/data/reviews.dart: 후기 데이터 구성
? lib/data/tour.dart: 관광지 데이터 구성
? lib/data/user.dart: 회원(사용자) 데이터 구성
? lib/main/favoritePage.dart: 즐겨찾기 화면
? lib/main/mapPage.dart: 메인 화면에서 관광지 목록 구성(관광 정보 오픈 API 연동)
? lib/main/settingPage.dart: 설정 화면
? lib/main/tourDetailPage.dart: 관광지 상세보기 화면(구글 맵 API 연동)
? lib/login.dart: 로그인 화면
? lib/main.dart: 프로그램 진입점
? lib/mainPage.dart: 메인 화면
? lib/signPage.dart: 회원가입 화면
? repo/images/map_location.png: 관광지 사진이 없을 때 표시할 기본 사진
[Do it! 실습] 메인 화면 기본 골격 만들기
[1단계] lib 폴더에 main이라는 폴더를 생성한 후 mapPage.dart, favoritePage.dart, settingPage.dart 파일을 생성합니다. 각 파일에는 StatefulWidget을 상속받는 클래스를 생성합니다.
[QR 코드] 소스 보기


[QR 코드 끝]
425
[글상자] lib/main/mapPage.dart
import 'package:flutter/material.dart';
class MapPage extends StatefulWidget {
@override
State<StatefulWidget> createState() {
return _MapPage();
}
}
class _MapPage extends State<MapPage> {
@override
Widget build(BuildContext context) {
return Scaffold();
}
}
[글상자 끝]
[글상자] lib/main/favoritePage.dart
import 'package:flutter/material.dart';
class FavoritePage extends StatefulWidget {
@override
State<StatefulWidget> createState() {
return _FavoritePage();
}
}
class _FavoritePage extends State<FavoritePage> {
@override
Widget build(BuildContext context) {
return Scaffold();
}
}
[글상자 끝]
[글상자] lib/main/settingPage.dart
import 'package:flutter/material.dart';
class SettingPage extends StatefulWidget {
426
@override
State<StatefulWidget> createState() {
return _SettingPage();
}
}
class _SettingPage extends State<SettingPage> {
@override
Widget build(BuildContext context) {
return Scaffold();
}
}
[글상자 끝]
[2단계] lib 폴더에 mainPage.dart 파일을 생성하고 앞에서 작성한 3개의 서브 페이지를 통합합니다. 하단에 탭이 3개인 내비게이션바를 만들고 각 탭을 클릭 시 해당 페이지로 이동하도록 구현합니다. _databaseURL 변수에는 각자 파이어베이스에서 생성한 실시간 데이터베이스 URL을 넣어야 합니다.
[글상자] lib/mainPage.dart
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/material.dart';
import 'main/favoritePage.dart';
import 'main/settingPage.dart';
import 'main/mapPage.dart';
class MainPage extends StatefulWidget {
@override
State<StatefulWidget> createState() => _MainPage();
}
class _MainPage extends State<MainPage> with SingleTickerProviderStateMixin {
TabController controller;
FirebaseDatabase _database;
DatabaseReference reference;
String _databaseURL = '### 데이터베이스 URL 넣기 ###';
427
String id;
@override
void initState() {
super.initState();
controller = TabController(length: 3, vsync: this);
_database = FirebaseDatabase(databaseURL: _databaseURL);
reference = _database.reference()
}
@override
void dispose() {
controller.dispose();
super.dispose();
}
@override
Widget build(BuildContext context) {
id = ModalRoute.of(context).settings.arguments;
return Scaffold(
body: TabBarView(
children: <Widget>[
// TabBarView에 채울 위젯들
MapPage(),
FavoritePage(),
SettingPage()
],
controller: controller,
),
bottomNavigationBar: TabBar(
tabs: <Tab>[
Tab(
icon: Icon(Icons.map),
),
Tab(
icon: Icon(Icons.star),
),
Tab(
icon: Icon(Icons.settings),
428
)
],
labelColor: Colors.amber,
indicatorColor: Colors.deepOrangeAccent,
controller: controller,
));
}
}
[글상자 끝]
05장에서 배운 BottomNavigationBar를 이용해 메인 페이지를 만들었습니다. 그리고 TabBarView를 이용해 관광 정보가 표시되는 MapPage, 즐겨찾기 페이지인 FavoritePage, 설정 페이지인 SettingPage를 등록했습니다.
id 변수에는 ModalRoute.of(context).settings.arguments 코드를 이용해 로그인할 때 전달받은 아이디값을 저장합니다. 각 페이지로 이동할 때마다 이 값을 전달합니다.
[3단계] 14장에서 login.dart 파일을 작성할 때 로그인에 성공하면 다음과 같은 코드가 실행되도록 했습니다.
[글상자] 로그인 성공 시 메인 화면으로 이동하는 코드
Navigator.of(context).pushReplacementNamed('/main',
arguments: _idTextController.value.text);
[글상자 끝]
따라서 main.dart 파일에 '/main'이라는 경로를 설정해줘야 합니다. main.dart 파일을 열고 메인 화면을 정의한 mainPage.dart 파일을 import한 후 라우트 목록에 경로가 '/main'일 때 메인 화면으로 이동하도록 등록합니다.
[글상자] lib/main.dart
import 'mainPage.dart';
(...생략...)
routes: {
'/': (context) => LoginPage(),
'/sign': (context) => SignPage(),
'/main': (context) => MainPage(),
},
(...생략...)
[글상자 끝]
429
[4단계] 이제 빌드 후 앱을 실행합니다. 회원가입한 아이디와 비밀번호로 로그인하면 메인 페이지로 이동하는 것을 확인할 수 있습니다. 아직 아무런 내용도 나오지 않지만 아래 내비게이션바에서 탭을 클릭하면 각 화면으로 이동할 수는 있습니다.
[그림] 실행 결과


[그림 끝]
[Do it! 실습] 관광 정보 API를 이용해 데이터 불러오기
메인 화면에서 지역과 관광지 종류를 선택한 후 <검색하기> 버튼을 누르면 오픈 API에서 해당 지역의 관광 정보를 가져와 목록으로 표시하는 기능을 구현해 보겠습니다.
[1단계] 오픈 API에서 받아온 관광 정보는 다양한 데이터를 포함하고 있습니다. 이 중에서 필요한 데이터만 모아 하나의 클래스로 만들어서 활용하겠습니다. lib/data 폴더에 tour.dart 파일을 생성하고 다음처럼 TourData 클래스를 작성합니다.
[글상자] lib/data/tour.dart
class TourData {
String title;
String tel;
String zipcode;
String address;
var id;
var mapx;
430
var mapy;
var imagePath;
TourData(
{this.id,
this.title,
this.tel,
this.zipcode,
this.address,
this.mapx,
this.mapy,
this.imagePath});
TourData.fromJson(Map data)
: id = data['contentid'],
title = data['title'],
tel = data['tel'],
zipcode = data['zipcode'],
address = data['addr1'],
mapx = data['mapx'],
mapy = data['mapy'],
imagePath = data['firstimage'];
Map<String, dynamic> toMap() {
return {
'id': id,
'title': title,
'tel': tel,
'zipcode': zipcode,
'address': address,
'mapx': mapx,
'mapy': mapy,
'imagePath': imagePath,
};
}
}
[글상자 끝]
431
[2단계] 앞에서 기본 골격만 만들어 둔 mapPage.dart 파일을 열고 다음과 같이 코드를 추가합니다. authKey 변수에는 14장의 내용 중 공공데이터포털에서 각자 발급받은 오픈 API 인증키를 입력합니다.
[글상자] lib/main/mapPage.dart
import 'package:flutter/material.dart';
import 'dart:convert';
import 'package:firebase_database/firebase_database.dart';
import 'package:http/http.dart' as http;
import 'package:modu_tour/data/tour.dart';
import 'package:modu_tour/data/listData.dart';
import 'package:sqflite/sqflite.dart';
class MapPage extends StatefulWidget {
final DatabaseReference databaseReference; // 실시간 데이터베이스 변수
final Future<Database> db; // 내부에 저장되는 데이터베이스
final String id; // 로그인한 아이디
MapPage({this.databaseReference, this.db, this.id});
@override
State<StatefulWidget> createState() => _MapPage();
}
class _MapPage extends State<MapPage> {
List<DropdownMenuItem> list = List();
List<DropdownMenuItem> sublist = List();
List<TourData> tourData = List();
ScrollController _scrollController;
String authKey ='### 오픈 API 키(일반 인증키) ###';
Item area;
Item kind;
int page = 1;
@override
432
void initState() {
super.initState();
list = Area().seoulArea;
sublist = Kind().kinds;
area = list[0].value;
kind = sublist[0].value;
_scrollController = new ScrollController();
_scrollController.addListener(() {
if (_scrollController.offset >=
_scrollController.position.maxScrollExtent &&
!_scrollController.position.outOfRange) {
page++;
getAreaList(area: area.value, contentTypeId: kind.value, page: page);
}
});
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('검색하기'),
),
body: Container(
child: Center(
child: Column(
children: <Widget>[
Row(
children: <Widget>[
DropdownButton(
items: list,
onChanged: (value) {
Item selectedItem = value;
setState(() {
area = selectedItem;
});
},
433
value: area,
),
SizedBox(
width: 10,
),
DropdownButton(
items: sublist,
onChanged: (value) {
Item selectedItem = value;
setState(() {
kind = selectedItem;
});
},
value: kind,
),
SizedBox(
width: 10,
),
RaisedButton(
onPressed: () {
page = 1;
tourData.clear();
getAreaList(
area: area.value,
contentTypeId: kind.value,
page: page);
},
child: Text(
'검색하기',
style: TextStyle(color: Colors.white),
),
color: Colors.blueAccent,
)
],
mainAxisAlignment: MainAxisAlignment.spaceAround,
),
Expanded(
child: ListView.builder(
itemBuilder: (context, index) {
434
return Card(
child: InkWell(
child: Row(
children: <Widget>[
Hero(
tag: 'tourinfo$index',
child: Container(
margin: EdgeInsets.all(10),
width: 100.0,
height: 100.0,
decoration: BoxDecoration(
shape: BoxShape.circle,
border: Border.all(
color: Colors.black, width: 1),
image: DecorationImage(
fit: BoxFit.fill,
image: tourData[index].imagePath !=
null
? NetworkImage(
tourData[index].imagePath)
: AssetImage(
'repo/images/map_location.png'
))))),
SizedBox(
width: 20,
),
Container(
child: Column(
children: <Widget>[
Text(
tourData[index].title,
style: TextStyle(
fontSize: 20,
fontWeight: FontWeight.bold),
),
Text('주소 : ${tourData[index].address}'),
tourData[index].tel != null
? Text('전화 번호 : ${tourData[index].tel}')
: Container(),
435
],
mainAxisAlignment: MainAxisAlignment.spaceEvenly,
),
width: MediaQuery.of(context).size.width - 150,
)
],
),
onTap: () {},
),
);
},
itemCount: tourData.length,
controller: _scrollController,
))
],
mainAxisAlignment: MainAxisAlignment.start,
),),),
);
}
void getAreaList({int area, int contentTypeId, int page}) async {
var url ='http://api.visitkorea.or.kr/openapi/service/rest/KorService/'
'areaBasedList?ServiceKey=$authKey&MobileOS=AND&MobileApp=ModuTour&'
'_type=json&areaCode=1&sigunguCode=$area&pageNo=$page';
if (contentTypeId != 0) {
url = url + '&contentTypeId=$contentTypeId';
}
var response = await http.get(url);
String body = utf8.decode(response.bodyBytes);
print(body);
var json = jsonDecode(body);
if (json['response']['header']['resultCode'] == "0000") {
if (json['response']['body']['items'] == '') {
showDialog(
context: context,
builder: (context) {
return AlertDialog(
content: Text('마지막 데이터 입니다'),
);
436
});
} else {
List jsonArray = json['response']['body']['items']['item'];
for (var s in jsonArray) {
setState(() {
tourData.add(TourData.fromJson(s));
});
}
}
} else {
print('error');
}
}
}
[글상자 끝]
07장에서 배운 HTTP 통신을 활용해 관광 정보 API의 데이터를 받아옵니다. 이 데이터를 JSON 형태로 변환해서 리스트에 넣고 리스트뷰를 만듭니다. 그리고 Container 함수에서 decoration은 위젯을 어떻게 꾸밀지 결정합니다. 여기에 사용한 BoxDecoration에서는 모양(shape)을 원형으로 지정하고 검은색 테두리를 넣었습니다.
Hero 위젯을 이용해 이미지를 감싼 것도 볼 수 있습니다. 이 이미지는 리스트에서 아이템을 클릭했을 때 애니메이션 효과로 이어지면서 관광지 상세보기 페이지로 넘어갑니다.
initState() 함수에서 지역 목록은 list에 저장하고 관광지 종류는 sublist에 저장하는데, 각각 Area와 Kind 클래스를 이용합니다. 두 클래스는 다음 단계에서 작성합니다.
[3단계] 사용자가 지역과 관광지 종류를 선택할 수 있도록 펼침 메뉴에 표시할 데이터를 준비합니다. data 폴더에 listData.dart 파일을 생성한 후 다음과 같이 코드를 작성합니다. 다만, 똑같은 패턴으로 지역과 관광지 종류를 입력하므로 지면상 일부 소스는 생략했습니다. 전체 소스는 이 책에서 소개하는 소스 자료실에서 확인할 수 있습니다.
[글상자] lib/data/listData.dart
import 'package:flutter/material.dart';
class Item {
String title;
int value;
437
Item(this.title, this.value);
}
class Area {
List<DropdownMenuItem> seoulArea = List();
Area() {
seoulArea.add(DropdownMenuItem(
child: Text('강남구'),
value: Item('강남구', 1),
));
(...생략...)
}
}
class Kind {
List<DropdownMenuItem> kinds = List();
Kind() {
kinds.add(DropdownMenuItem(
child: Text('관광지'),
value: Item('관광지', 12),
));
(...생략...)
}
}
[글상자 끝]
원래는 도시 코드를 가져오는 API를 호출하고 이 데이터를 바탕으로 펼침 메뉴(DropdownMenuItem)를 만들어야 하지만, 이렇게 하면 코드가 너무 길어져서 여기서는 데이터를 직접 입력하여 클래스를 만들었습니다. API를 호출할 때마다 어느 정도 시간이 걸리기 때문에 변하지 않는 데이터라면 이런 방법도 좋습니다.
438
[4단계] 이제 앱을 빌드하고 실행합니다. 로그인 후 메인 화면에서 지역과 관광지 종류를 선택하고 <검색하기> 버튼을 클릭하면 오픈 API에서 가져온 데이터를 목록으로 표시합니다.
[그림] 실행 결과


(1) 강남구, (2) 관광지, (3) [검색하기] → 여러 관광지 상세 화면
[그림 끝]
439
15-2 상세보기 화면 만들기 - 구글 지도 넣기
이번 절에서는 메인 화면에서 특정 관광지를 선택했을 때 지도에 위치를 표시하고 장애인 이용 정보와 댓글 등 해당 관광지의 상세 정보를 보여주는 화면을 만들어 보겠습니다. 여기서는 구글 맵 API를 이용해 지도를 표시했습니다.
[Do it! 실습] 구글 맵 API 키 얻기
구글 맵은 구글이 제공하는 지도 서비스입니다. 구글 맵도 다른 오픈 API처럼 인증키를 발급 받아 호출하는 방식으로 이용합니다. 구글 맵 서비스는 구글 클라우드 플랫폼이라는 사이트에서 관리합니다.
[1단계] 웹 브라우저를 열고 cloud.google.com/maps-platform에 접속한 후 <시작하기>를 클릭합니다. 이때 로그인이 되어 있지 않으면 구글 아이디로 로그인합니다. 그러면 구글 맵 플랫폼을 설정하는 단계가 시작됩니다.
[그림 15-1] 구글 맵 플랫폼 시작하기


Google Maps Platform에 오신 것을 환영합니다
[그림 끝]
440
[2단계] 첫 번째 단계에서는 국가와 서비스 약관에 동의한다고 체크하고 <계속>을 클릭합니다.
[그림 15-2] 사용자 설정 1단계


(1) 대한민국
(2) ? Google Cloud Platform 무료 평가판 서비스 약관을 읽었으며 이에 동의합니다. 계속 진행하시려면 체크박스를 선택하세요.
(3) [계속]
[그림 끝]
[3단계] 두 번째 단계에서는 고객 정보를 입력합니다. 입력 후 <계속>을 클릭하고 이어서 결제 옵션을 입력합니다. 휴대폰 인증을 진행하고 카드[각주*]를 등록한 다음 <무료 평가판 시작하기>를 클릭합니다.
[각주*] 결제가 아닌 인증 수단으로 등록하는 것이므로 비용이 결제되지는 않습니다.[각주 끝]
[그림 15-3] 사용자 설정 2단계


[그림 끝]
441
[4단계] 환영 메시지가 나오면 사용할 제품을 선택합니다. 여기서 [지도]에 체크한 후 <사용 설정>을 클릭합니다.
[그림 15-4] 구글 맵 플랫폼 제품 선택 화면


(1) ? 지도
(2) [사용 설정]
[그림 끝]
[5단계] 모든 설정을 마쳤으면 다음처럼 API 키가 발급됩니다. 잠시 후 이 키를 앱에 넣어서 지도를 표시할 것입니다. API 키는 유출되지 않도록 주의합니다. <완료>를 클릭해 구글 맵 사용 설정을 마칩니다.
[그림 15-5] API 키 확인


(1) API 키
(2) [완료]
[그림 끝]
이후에 API 키를 다시 확인하려면 구글 클라우드 플랫폼에서 [사용자 인증 정보]를 클릭하면 됩니다.
[그림 15-6] 사용자 인증 정보


(1) 사용자 인증 정보
(2) 키
[그림 끝]
442
[아하!] 구글 맵 가격 정책
이번 실습에서 사용하는 구글 맵 서비스는 구글에서 무료로 제공하는 모바일용이므로 안심하고 사용해도 좋습니다. 기타 자세한 가격 정책은 cloud.google.com/maps-platform/pricing에서 확인할 수 있습니다.
[그림 15-7] 구글 맵 가격 정책


[그림 끝]
[아하! 끝]
[Do it! 실습] 지도 표시하기
앞서 구글 맵 플랫폼의 사용 설정을 마쳤으니 앱에 지도를 표시해 보겠습니다. 그리고 장애인 이용 정보와 댓글로 후기를 남기는 기능도 추가해 관광지 상세보기 화면을 완성해 보겠습니다.
[1단계] 먼저 pubspec.yaml 파일을 열고 구글 맵 패키지를 추가합니다.
[글상자] pubspec.yaml
(...생략...)
dependencies:
flutter:
sdk: flutter
cupertino_icons: ^1.0.0
(...생략...)
crypto: ^2.1.5
google_maps_flutter: ^0.4.0
(...생략...)
[글상자 끝]
443
[2단계] 안드로이드 스튜디오에서 [File → Open]을 눌러 modu_tour 프로젝트 아래에 있는 android 폴더를 새 창에서 엽니다. 잠시 후 안드로이드 스튜디오가 그래들 구성을 마치면 탐색 창에서 manifests 폴더 아래에 있는 AndroidManifest.xml 파일을 열고 앞에서 각자 발급 받은 구글 맵 API 키를 등록합니다. 이후 안드로이드 프로젝트는 닫아도 됩니다.
[글상자] Androidmanifest.xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.easyspub.modu_tour">
<application
android:name="io.flutter.app.FlutterApplication"
android:label="modu_tour"
android:icon="@mipmap/ic_launcher">
<activity
(...생략...)
</activity>
<meta-data
android:name="flutterEmbedding"
android:value="2" />
<meta-data
android:name="com.google.android.gms.ads.APPLICATION_ID"
android:value="### 애드몹 앱 ID ###"/>
<meta-data android:name="com.google.android.geo.API_KEY"
android:value="### 구글 맵 API 키 ###"/>
</application>
</manifest>
[글상자 끝]
[3단계] mapPage.dart 파일을 열고 관광지 목록에서 관광지를 클릭하면 상세보기 화면으로 이동하도록 Card 위젯의 onTap 이벤트 핸들러를 다음처럼 작성합니다.
[글상자] lib/main/mapPage.dart
import 'package:modu_tour/main/tourDetailPage.dart';
(...생략...)
onTap: () {
Navigator.of(context).push(MaterialPageRoute(
444
builder: (context) => TourDetailPage(
id: widget.id,
tourData: tourData[index],
index: index,
databaseReference: widget.databaseReference,
)));
},
[글상자 끝]
[4단계] 관광지 상세보기 화면에서는 장애인 이용 점수와 사용자 후기를 보여줄 것입니다. 이런 데이터를 구조적으로 관리하고자 lib/data 폴더 아래에 데이터 클래스를 만들겠습니다. 먼저 reviews.dart 파일을 만들고 다음처럼 클래스를 정의합니다.
[글상자] lib/data/reviews.dart
import 'package:firebase_database/firebase_database.dart';
class Review {
String key;
String id;
String review;
String createTime;
Review(this.id, this.review, this.createTime);
Review.fromSnapshot(DataSnapshot snapshot)
: key = snapshot.key,
id = snapshot.value['id'],
review = snapshot.value['review'],
createTime = snapshot.value['createTime'];
toJson() {
return {
'id': id,
'review': review,
'createTime': createTime,
};
}
}
[글상자 끝]
445
그다음 disableInfo.dart 파일을 만들고 다음과 같이 클래스를 정의합니다.
[글상자] lib/data/disableInfo.dart
import 'package:firebase_database/firebase_database.dart';
class DisableInfo {
String key;
int disable1;
int disable2;
String id;
String createTime;
DisableInfo(this.id, this.disable1, this.disable2, this.createTime);
DisableInfo.fromSnapshot(DataSnapshot snapshot)
: key = snapshot.key,
id = snapshot.value['id'],
disable1 = snapshot.value['disable1'],
disable2 = snapshot.value['disable2'],
createTime = snapshot.value['createTime'];
toJson() {
return {
'id': id,
'disable1': disable1,
'disable2': disable2,
'createTime': createTime,
};
}
}
[글상자 끝]
[5단계] 관광지를 클릭하면 보여줄 상세보기 화면을 만듭니다. Hero와 Sliver 위젯을 이용해 애니메이션을 적용한 페이지를 구현합니다. lib/main 폴더에 tourDetailPage.dart 파일을 생성한 후 다음과 같이 코드를 작성합니다.
446
[글상자] lib/main/tourDetailPage.dart
import 'dart:async';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/material.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:modu_tour/data/disableInfo.dart';
import 'package:modu_tour/data/reviews.dart';
import 'dart:math' as math;
import 'package:modu_tour/data/tour.dart';
class TourDetailPage extends StatefulWidget {
final TourData tourData;
final int index;
final DatabaseReference databaseReference;
final String id;
TourDetailPage({this.tourData, this.index, this.databaseReference, this.id});
@override
State<StatefulWidget> createState() => _TourDetailPage();
}
class _TourDetailPage extends State<TourDetailPage> {
Completer<GoogleMapController> _controller = Completer();
Map<MarkerId, Marker> markers = <MarkerId, Marker>{};
CameraPosition _googleMapCamera;
TextEditingController _reviewTextController;
Marker marker;
List<Review> reviews = List();
bool _disableWidget = false;
DisableInfo _disableInfo;
double disableCheck1 = 0;
double disableCheck2 = 0;
@override
void initState() {
super.initState();
447
widget.databaseReference
.child('tour')
.child(widget.tourData.id.toString())
.child('review')
.onChildAdded
.listen((event) {
if (event.snapshot.value != null) {
setState(() {
reviews.add(Review.fromSnapshot(event.snapshot));
});
}
});
_reviewTextController = TextEditingController();
_googleMapCamera = CameraPosition( // 지도에서 관광지 위치를 표시하기 위한 변수
target: LatLng(double.parse(widget.tourData.mapy.toString()), // 지도에서 관광지 위치를 표시하기 위한 변수
double.parse(widget.tourData.mapx.toString())), // 지도에서 관광지 위치를 표시하기 위한 변수
zoom: 16, // 지도에서 관광지 위치를 표시하기 위한 변수
); // 지도에서 관광지 위치를 표시하기 위한 변수
MarkerId markerId = MarkerId(widget.tourData.hashCode.toString());
marker = Marker(
position: LatLng(double.parse(widget.tourData.mapy.toString()),
double.parse(widget.tourData.mapx.toString())),
flat: true,
markerId: markerId);
markers[markerId] = marker;
getDisableInfo();
}
@override
Widget build(BuildContext context) {
return Scaffold(
body: CustomScrollView(
slivers: <Widget>[
SliverAppBar(
expandedHeight: 150,
flexibleSpace: FlexibleSpaceBar(
title: Text(
448
'${widget.tourData.title}',
style: TextStyle(color: Colors.white, fontSize: 40),
),
centerTitle: true,
titlePadding: EdgeInsets.only(top: 10),
),
pinned: true,
backgroundColor: Colors.deepOrangeAccent,
),
SliverList(
delegate: SliverChildListDelegate([
SizedBox(
height: 20,
),
Container(
child: Center(
child: Column(
children: <Widget>[
Hero(
tag: 'tourinfo${widget.index}',
child: Container(
width: 300.0,
height: 300.0,
decoration: BoxDecoration(
shape: BoxShape.circle,
border:
Border.all(color: Colors.black, width: 1),
image: DecorationImage(
fit: BoxFit.fill,
image: widget.tourData.imagePath == 'null' ||
widget.tourData.imagePath == null
? AssetImage(
'repo/images/map_location.png')
: NetworkImage(
widget.tourData.imagePath))))),
Padding(
padding: EdgeInsets.only(top: 20, bottom: 20),
child: Text(
449
widget.tourData.address,
style: TextStyle(fontSize: 20),
),
),
getGoogleMap(),
_disableWidget == false
? setDisableWidget()
: showDisableWidget(),
],
),
),
),
])),
SliverPersistentHeader(
delegate: _HeaderDelegate(
minHeight: 50,
maxHeight: 100,
child: Container(
color: Colors.lightBlueAccent,
child: Center(
child: Column(
children: <Widget>[
Text(
'후기',
style: TextStyle(fontSize: 30, color: Colors.white),
),
],
mainAxisAlignment: MainAxisAlignment.center,
),
),
)),
pinned: true,
),
SliverList(
delegate: SliverChildBuilderDelegate((context, index) {
return Card(
child: InkWell(
child: Padding(
450
padding: EdgeInsets.only(top: 10, bottom: 10, left: 10),
child: Text(
'${reviews[index].id} : ${reviews[index].review}',
style: TextStyle(fontSize: 15),
),
),
onDoubleTap: () {
if (reviews[index].id == widget.id) {
widget.databaseReference
.child('tour')
.child(widget.tourData.id.toString())
.child('review')
.child(widget.id)
.remove();
setState(() {
reviews.removeAt(index);
});
}
},
),
);
}, childCount: reviews.length)),
SliverList(
delegate: SliverChildListDelegate([
RaisedButton(
onPressed: () {
showDialog(
context: context,
builder: (context) {
return AlertDialog(
title: Text('후기 쓰기'),
content: TextField(
controller: _reviewTextController,
),
actions: <Widget>[
FlatButton(
onPressed: () {
Review review = Review(
451
widget.id,
_reviewTextController.value.text,
DateTime.now().toIso8601String());
widget.databaseReference
.child('tour')
.child(widget.tourData.id.toString())
.child('review')
.child(widget.id)
.set(review.toJson());
},
child: Text('후기 쓰기')),
FlatButton(
onPressed: () {
Navigator.of(context).pop();
},
child: Text('종료하기')),
],
);
});
},
child: Text('댓글 쓰기'),
)
]))
],
),
);
}
getDisableInfo() {
widget.databaseReference
.child('tour')
.child(widget.tourData.id.toString())
.onValue
.listen((event) {
_disableInfo = DisableInfo.fromSnapshot(event.snapshot);
if (_disableInfo.id == null) {
setState(() {
_disableWidget = false;
452
});
} else {
setState(() {
_disableWidget = true;
});
}
});
}
Widget setDisableWidget() {
return Container(
child: Center(
child: Column(
children: <Widget>[
Text('데이터가 없습니다. 추가해주세요'),
Text('시각 장애인 이용 점수 : ${disableCheck1.floor()}'),
Padding(
padding: EdgeInsets.all(20),
child: Slider(
value: disableCheck1,
min: 0,
max: 10,
onChanged: (value) {
setState(() {
disableCheck1 = value;
});
}),
),
Text('지체 장애인 이용 점수 : ${disableCheck2.floor()}'),
Padding(
padding: EdgeInsets.all(20),
child: Slider(
value: disableCheck2,
min: 0,
max: 10,
onChanged: (value) {
setState(() {
disableCheck2 = value;
453
});
}),
),
RaisedButton(
onPressed: () {
DisableInfo info = DisableInfo(widget.id, disableCheck1.floor(),
disableCheck2.floor(), DateTime.now().toIso8601String());
widget.databaseReference
.child("tour")
.child(widget.tourData.id.toString())
.set(info.toJson())
.then((value) {
setState(() {
_disableWidget = true;
});
});
},
child: Text('데이터 저장하기'),
)
],
),
),
);
}
getGoogleMap() {
return SizedBox(
height: 400,
width: MediaQuery.of(context).size.width - 50,
child: GoogleMap( // 지도를 표시하는 함수
mapType: MapType.normal, // 지도를 표시하는 함수
initialCameraPosition: _googleMapCamera, // 지도를 표시하는 함수
onMapCreated: (GoogleMapController controller) { // 지도를 표시하는 함수
_controller.complete(controller); // 지도를 표시하는 함수
}, // 지도를 표시하는 함수
markers: Set<Marker>.of(markers.values)), // 지도를 표시하는 함수
);
}
454
showDisableWidget() {
return Center(
child: Column(
children: <Widget>[
Row(
children: <Widget>[
Icon(Icons.accessible, size: 40, color: Colors.orange),
Text(
'지체 장애 이용 점수 : ${_disableInfo.disable2}',
style: TextStyle(fontSize: 20),
)
],
mainAxisAlignment: MainAxisAlignment.spaceEvenly,
),
SizedBox(
height: 20,
),
Row(
children: <Widget>[
Icon(
Icons.remove_red_eye,
size: 40,
color: Colors.orange,
),
Text('시각 장애 이용 점수 : ${_disableInfo.disable1}',
style: TextStyle(fontSize: 20))
],
mainAxisAlignment: MainAxisAlignment.spaceEvenly,
),
SizedBox(
height: 20,
),
Text('작성자 : ${_disableInfo.id}'),
SizedBox(
height: 20,
),
RaisedButton(
455
onPressed: () {
setState(() {
_disableWidget = false;
});
},
child: Text('새로 작성하기'),
)
],
),
);
}
}
class _HeaderDelegate extends SliverPersistentHeaderDelegate {
final double minHeight;
final double maxHeight;
final Widget child;
_HeaderDelegate({
@required this.minHeight,
@required this.maxHeight,
@required this.child,
});
@override
Widget build(
BuildContext context, double shrinkOffset, bool overlapsContent) {
return SizedBox.expand(child: child);
}
@override
double get maxExtent => math.max(maxHeight, minHeight);
@override
double get minExtent => minHeight;
@override
bool shouldRebuild(_HeaderDelegate oldDelegate) {
456
return maxHeight != oldDelegate.maxHeight ||
minHeight != oldDelegate.minHeight ||
child != oldDelegate.child;
}
}
[글상자 끝]
소스가 길지만 대부분은 앞에서 살펴본 내용이므로 구글 맵을 표시하는 GoogleMap() 함수 위주로 살펴보겠습니다.
[글상자] 구글 맵을 표시하는 GoogleMap() 함수
GoogleMap(
mapType: MapType.normal,
initialCameraPosition: _googleMapCamera,
onMapCreated: (GoogleMapController controller) {
_controller.complete(controller);
},
markers: Set<Marker>.of(markers.values)
),
[글상자 끝]
GoogleMap() 함수는 google_maps_flutter 패키지에 정의되어 있습니다. GoogleMap() 함수에 첫 번째 인자로 전달한 mapType은 지도의 형태를 설정합니다. mapType에 설정할 수 있는 값은 다음과 같습니다.
[표 15-1] mapType 설정값
mapType 설정값

설명

none

지도를 표시하지 않음

normal

일반적인 지도 표시

satellite

위성 지도 표시

terrain

3D 지도 표시

hybrid

위성 지도와 일반적인 지도를 함께 표시

457
두 번째 인자로 전달한 initialCameraPosition에는 지도에 표시할 위치를 설정합니다. 여기에는 앞에서 CameraPosition() 함수로 초기화한 _googleMapCamera 변수를 설정했습니다.
[글상자] 위경도를 설정하는 코드
_googleMapCamera = CameraPosition(
target: LatLng(double.parse(widget.tourData.mapy.toString()),
double.parse(widget.tourData.mapx.toString())),
zoom: 16,
);
[글상자 끝]
지도에 특정 위치를 표시하려면 위도와 경도를 알아야 합니다. _googleMapCamera 변수에 CameraPosition() 함수를 이용해 위경도를 넣고 zoom으로 확대 정도를 초기화했습니다. 관광지의 위경도는 오픈 API에서 받아온 tourData.mapy와 tourData.mapx로 구합니다.
세 번째 인자로 전달한 onMapCreated는 지도를 표시한 다음 호출되는 콜백 함수입니다. 여기에는 보통 지도를 제어하는 코드를 작성하지만 이 앱에서는 간단하게 complete() 함수를 호출하는 것으로 마무리했습니다.
마지막으로 지도에 표시할 마커를 설정하는 markers 인자에는 markers.values를 넣었습니다. 앞에서 markers 배열에는 오픈 API에서 받아온 위경도를 Maker() 함수에 넣어서 초기화한 marker 변수를 넣었습니다. 따라서 관광지의 주소를 기반으로 마커가 설정됩니다.
[글상자] 마커를 설정하는 코드
MarkerId markerId = MarkerId(widget.tourData.hashCode.toString());
marker = Marker(
position: LatLng(double.parse(widget.tourData.mapy.toString()),
double.parse(widget.tourData.mapx.toString())),
flat: true,
markerId: markerId);
markers[markerId] = marker;
[글상자 끝]
[6단계] 마지막으로 mainPage.dart 파일을 열고 MapPage() 함수를 호출하는 부분에 reference와 id값을 전달하는 코드를 추가합니다.
458
[글상자] lib/mainPage.dart
(...생략...)
body: TabBarView(
children: <Widget>[
MapPage(
databaseReference: reference,
id: id,
),
FavoritePage(),
SettingPage()
],
controller: controller,
),
(...생략...)
[글상자 끝]
[7단계] 앱을 빌드하고 실행해 봅시다. 관광지를 선택하면 지도가 포함된 상세보기 화면을 볼 수 있습니다. 이와 함께 장애인 이용 점수와 후기도 등록할 수 있습니다.
[그림] 실행 결과


신사동 가로수길: 서울특별시 강남구 신사동 [지도 그림]
신사동 가로수길: [지도 그림] 데이터가 없습니다. 추가해주세요, 시각 장애인 이용 점수: 0, 지체 장애인 이용 점수: 0, 데이터 저장하기, 후기, 댓글 쓰기
신사동 가로수길: [지도 그림] 지체 장애인 이용 점수: 7, 시각 장애인 이용 점수: 5, 작성자: easys, 새로 작성하기, 후기, 댓글 쓰기
[그림 끝]
459
[그림]


후기 쓰기, 걷기 좋아요!, 후기 쓰기, 종료하기
신사동 가로수길: [지도 그림] 지체 장애인 이용 점수: 7, 시각 장애인 이용 점수: 5, 작성자: easys, 새로 작성하기, 후기 - easys: 걷기 좋아요!, 댓글 쓰기
[그림 끝]
[8단계] 장애인 이용 점수나 후기를 등록하고 파이어베이스 콘솔에서 실시간 데이터베이스를 확인하면 다음처럼 데이터가 저장된 것을 확인할 수 있습니다.
[그림 15-8] 실시간 데이터베이스 확인


disable1: 5 // 장애인 이용 점수
disable2: 7 // 장애인 이용 점수
id: "easys" // 장애인 이용 점수
createTime: "2020-12-24T13:46:32.233475" // 후기
id: "easys" // 후기
review: "걷기 좋아요!" // 후기
[그림 끝]
460
15-3 즐겨찾기 화면 만들기
이번에는 즐겨찾기 화면을 만들어 보겠습니다. 메인 화면에서 관광지를 더블탭하면 이를 내부 데이터베이스(SQLite)에 저장해 놓고 즐겨찾기 화면에서 모아볼 수 있는 기능입니다. 즐겨찾기 화면에서 관광지를 더블탭하면 즐겨찾기를 해제하는 기능도 만들어 보겠습니다.
[Do it! 실습] 즐겨찾기 설정하고 해제하기
[1단계] main.dart 파일을 열고 MyApp 클래스에서 데이터베이스를 초기화하는 함수를 추가합니다. 이렇게 초기화한 데이터베이스를 메인 화면에 전달하는 코드도 작성합니다.
[글상자] lib/main.dart
(...생략...)
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
void main() => runApp(MyApp());
class MyApp extends StatelessWidget {
Future<Database> initDatabase() async {
return openDatabase(
join(await getDatabasesPath(), 'tour_database.db'),
onCreate: (db, version) {
return db.execute(
"CREATE TABLE place(id INTEGER PRIMARY KEY AUTOINCREMENT,
title TEXT, tel TEXT, zipcode TEXT, address TEXT, mapx Number,
mapy Number , imagePath TEXT)",
);
},
version: 1,
);
}
461
@override
Widget build(BuildContext context) {
Future<Database> database = initDatabase(); // initDatabase() 함수 호출
return MaterialApp(
(...생략...)
routes: {
'/': (context) => LoginPage(),
'/sign': (context) => SignPage(),
'/main': (context) => MainPage(database),
},
);
}
}
[글상자 끝]
[2단계] 메인 화면으로 이동할 때 데이터베이스를 전달했으므로 이를 받을 수 있도록 mainPage.dart 파일을 수정합니다. 그리고 즐겨찾기 화면으로 이동할 때 전달할 인자도 추가합니다.
[글상자] lib/mainPage.dart
import 'package:sqflite/sqflite.dart';
(...생략...)
class MainPage extends StatefulWidget {
final Future<Database> database;
MainPage(this.database);
@override
State<StatefulWidget> createState() => _MainPage();
}
class _MainPage extends State<MainPage> with SingleTickerProviderStateMixin {
(...생략...)
@override
462
Widget build(BuildContext context) {
id = ModalRoute.of(context).settings.arguments;
return Scaffold(
body: TabBarView(
children: <Widget>[
//TabBarView 에 채울 위젯들
MapPage(
databaseReference: reference,
db: widget.database,
id: id,
),
FavoritePage(
databaseReference: reference,
db: widget.database,
id: id,
),
(...생략...)
[글상자 끝]
[3단계] mapPage.dart 파일을 열고 관광지를 더블탭하면 즐겨찾기로 설정하도록 Card 위젯의 onDoubleTap 이벤트 핸들러를 추가합니다. 그리고 즐겨찾기로 설정되면 스낵바(SnackBar)[각주*]로 알려주는 기능도 넣었습니다.
[각주*] 스낵바는 화면 아래쪽에 잠시 보였다가 사라지는 메시지 창으로 사용자에게 간단한 메시지를 전달할 때 사용합니다.[각주 끝]
[글상자] lib/main/mapPage.dart
(...생략...)
onTap: () { ...생략... },
onDoubleTap: () {
insertTour(widget.db, tourData[index]);
},
(...생략...)
void insertTour(Future<Database> db, TourData info) async {
final Database database = await db;
await database
.insert('place', info.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace)
.then((value) {
463
Scaffold.of(context)
.showSnackBar(SnackBar(content: Text('즐겨찾기에 추가되었습니다')));
});
}
(...생략...)
[글상자 끝]
[4단계] favoritePage.dart 파일을 열고 즐겨찾기 화면을 만드는 다음 코드를 작성합니다. 즐겨찾기 화면에서 관광지를 더블탭하면 즐겨찾기를 해제하고 데이터베이스에서 해당 데이터를 삭제하는 코드도 작성합니다.
[글상자] lib/main/favoritePage.dart
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/material.dart';
import 'package:modu_tour/data/tour.dart';
import 'package:modu_tour/main/tourDetailPage.dart';
import 'package:sqflite/sqflite.dart';
class FavoritePage extends StatefulWidget {
final DatabaseReference databaseReference;
final Future<Database> db;
final String id;
FavoritePage({this.databaseReference, this.db, this.id});
@override
State<StatefulWidget> createState() => _FavoritePage();
}
class _FavoritePage extends State<FavoritePage> {
Future<List<TourData>> _tourList;
@override
void initState() {
super.initState();
_tourList = getTodos();
}
464
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('즐겨찾기'),
),
body: Container(
child: Center(
child: FutureBuilder(
builder: (context, snapshot) {
switch (snapshot.connectionState) {
case ConnectionState.none:
return CircularProgressIndicator();
case ConnectionState.waiting:
return CircularProgressIndicator();
case ConnectionState.active:
return CircularProgressIndicator();
case ConnectionState.done:
if (snapshot.hasData) {
return ListView.builder(
itemBuilder: (context, index) {
TourData info = snapshot.data[index];
return Card(
child: InkWell(
child: Row(
children: <Widget>[
Hero(
tag: 'tourinfo$index',
child: Container(
margin: EdgeInsets.all(10),
width: 100.0,
height: 100.0,
decoration: BoxDecoration(
shape: BoxShape.circle,
border: Border.all(
color: Colors.black, width: 1),
image: DecorationImage(
fit: BoxFit.fill,
465
image: info.imagePath != 'null'
? NetworkImage(
info.imagePath)
: AssetImage(
'repo/images/
map_location.png'))))),
SizedBox(
width: 20,
),
Container(
child: Column(
children: <Widget>[
Text(
info.title,
style: TextStyle(
fontSize: 20,
fontWeight: FontWeight.bold),
),
Text('주소 : ${info.address}'),
info.tel != 'null'
? Text('전화 번호 : ${info.tel}')
: Container(),
],
mainAxisAlignment:
MainAxisAlignment.spaceEvenly,
),
width:
MediaQuery.of(context).size.width - 150,
)
],
),
onTap: () {
Navigator.of(context).push(MaterialPageRoute(
builder: (context) => TourDetailPage(
id: widget.id,
tourData: info,
index: index,
databaseReference:
466
widget.databaseReference,
)));
},
onDoubleTap: () {
deleteTour(widget.db, info);
},
),
);
},
itemCount: snapshot.data.length,
);
} else {
return Text('No data');
}
}
return CircularProgressIndicator();
},
future: _tourList,
),),),
);
}
void deleteTour(Future<Database> db, TourData info) async {
final Database database = await db;
await database.delete('place',
where: 'title=?', whereArgs: [info.title]).then((value) {
setState(() {
_tourList = getTodos();
});
Scaffold.of(context)
.showSnackBar(SnackBar(content: Text('즐겨찾기를 해제합니다')));
});
}
Future<List<TourData>> getTodos() async {
final Database database = await widget.db;
final List<Map<String, dynamic>> maps = await database.query('place');
467
return List.generate(maps.length, (i) {
return TourData(
title: maps[i]['title'].toString(),
tel: maps[i]['tel'].toString(),
address: maps[i]['address'].toString(),
zipcode: maps[i]['zipcode'].toString(),
mapy: maps[i]['mapy'].toString(),
mapx: maps[i]['mapx'].toString(),
imagePath: maps[i]['imagePath'].toString());
});
}
}
[글상자 끝]
[5단계] 이제 빌드 후 앱을 실행합니다. 메인 화면에서 관광지를 더블탭하면 즐겨찾기에 추가되고 다시 즐겨찾기 화면에서 더블탭하면 삭제되는 것을 확인할 수 있습니다. 각 상황마다 아래쪽에는 스낵바가 표시됩니다. 그리고 즐겨찾기 화면에서 관광지를 한 번 탭하면 상세보기 화면으로 이동합니다.
[그림] 실행 결과


경복궁
주소: 서울특별시 종로구 사직로 161 → ★(즐겨찾기) → 즐겨찾기에 지워졌습니다
[그림 끝]
468
15-4 설정 화면 만들기
이제 마지막으로 설정 화면을 만들어 보겠습니다. 보통 앱의 설정 화면에는 여러 기능이 있지만 여기서는 푸시 알림을 켜거나 끄는 기능과 로그아웃, 회원 탈퇴 기능을 넣겠습니다.
[Do it! 실습] 푸시 알림 수신 여부 설정하기
[1단계] settingPage.dart 파일을 열고 다음 코드를 작성해 설정 화면을 만듭니다. 푸시 알림 수신 여부를 sharedPreferences에 저장하고 로그아웃과 회원 탈퇴 기능도 구현합니다.
[글상자] lib/main/settingPage.dart
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
class SettingPage extends StatefulWidget {
final DatabaseReference databaseReference;
final String id;
SettingPage({this.databaseReference, this.id});
@override
State<StatefulWidget> createState() => _SettingPage();
}
class _SettingPage extends State<SettingPage> {
bool pushCheck = true;
@override
void initState() {
super.initState();
_loadData();
}
469
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text('설정하기'),
),
body: Container(
child: Center(
child: Column(
children: <Widget>[
Row(
children: <Widget>[
Text(
'푸시 알림',
style: TextStyle(fontSize: 20),
),
Switch(
value: pushCheck,
onChanged: (value) {
setState(() {
pushCheck = value;
});
_setData(value);
})
],
mainAxisAlignment: MainAxisAlignment.spaceAround,
),
SizedBox(
height: 50,
),
RaisedButton(
onPressed: () {
Navigator.of(context).pushNamedAndRemoveUntil(
'/', (Route<dynamic> route) => false);
},
child: Text('로그아웃', style: TextStyle(fontSize: 20)),
),
SizedBox(
470
height: 50,
),
RaisedButton(
onPressed: () {
AlertDialog dialog = new AlertDialog(
title: Text('아이디 삭제'),
content: Text('아이디를 삭제하시겠습니까?'),
actions: <Widget>[
FlatButton(
onPressed: () {
print(widget.id);
widget.databaseReference
.child('user')
.child(widget.id)
.remove();
Navigator.of(context).pushNamedAndRemoveUntil(
'/', (Route<dynamic> route) => false);
},
child: Text('예')),
FlatButton(
onPressed: () {
Navigator.of(context).pop();
},
child: Text('아니요')),
],
);
showDialog(
context: context,
builder: (context) {
return dialog;
});
},
child: Text('회원 탈퇴', style: TextStyle(fontSize: 20)),
),
],
mainAxisAlignment: MainAxisAlignment.center,
)),
),
);
471
}
void _setData(bool value) async {
var key = "push";
SharedPreferences pref = await SharedPreferences.getInstance();
pref.setBool(key, value);
}
void _loadData() async {
var key = "push";
SharedPreferences pref = await SharedPreferences.getInstance();
setState(() {
var value = pref.getBool(key);
if (value == null) {
setState(() {
pushCheck = true;
});
} else {
setState(() {
pushCheck = value;
});
}
});
}
}
[글상자 끝]
먼저 스위치를 이용해 푸시 알림을 허용할 것인지 설정합니다. 이 설정값은 내부 SharedPreferences에 저장합니다. 로그아웃은 보통 서버와 통신하는 코드로 구현하지만 지금은 서버가 없으므로 Navigator의 스택을 모두 비우고 홈 화면('/')으로 이동하도록만 구현합니다.
[글상자] 내비게이터의 모든 스택을 지우고 홈으로 이동
Navigator.of(context).pushNamedAndRemoveUntil(
'/', (Route<dynamic> route) => false);
[글상자 끝]
그리고 회원 탈퇴는 대화 상자에서 <예>를 클릭하면 실시간 데이터베이스에 접근해 데이터를 삭제하는 식으로 구현합니다.
472
[2단계] mainPage.dart 파일을 열고 SettingPage() 함수를 호출하는 부분에 전달할 인자를 추가합니다.
[글상자] lib/mainPage.dart
(...생략...)
SettingPage(
databaseReference: reference,
id: id,
)
(...생략...)
[글상자 끝]
앱을 실행하고 내비게이션바에서 세 번째 탭으로 이동하면 지금까지 작성한 설정 화면을 확인할 수 있습니다.
[그림] 실행 결과


설정하기: 푸시 알림, 로그아웃, 회원 탈퇴
아이디 삭제 - 아이디를 삭제하시겠습니까?, 예, 아니요
[그림 끝]
473
[Do it! 실습] 푸시 알림 처리
앞서 푸시 알림 수신을 설정하는 기능을 넣었으니 파이어베이스에서 메시지를 보내면 알림으로 표시하는 기능을 추가해 보겠습니다.
[1단계] mainPage.dart 파일을 열고 푸시 알림 수신을 허용했을 때 메시지를 수신할 수 있도록 작성합니다.
[글상자] lib/mainPage.dart
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:shared_preferences/shared_preferences.dart';
(...생략...)
class MainPage extends StatefulWidget { ...생략... }
class _MainPage extends State<MainPage> with SingleTickerProviderStateMixin {
TabController controller;
FirebaseDatabase _database;
DatabaseReference reference;
String _databaseURL = 'https://modutour-571f8-default-rtdb.firebaseio.com/';
String id;
final FirebaseMessaging _firebaseMessaging = FirebaseMessaging();
bool pushCheck = true;
@override
void initState() {
super.initState();
controller = TabController(length: 3, vsync: this);
_database = FirebaseDatabase(databaseURL: _databaseURL);
reference = _database.reference();
_firebaseMessaging.configure(
onMessage: (Map<String, dynamic> message) async {
_loadData();
print(pushCheck);
if (pushCheck) {
474
showDialog(
context: context,
builder: (context) => AlertDialog(
content: ListTile(
title: Text(message['notification']['title']),
subtitle: Text(message['notification']['body']),
),
actions: <Widget>[
FlatButton(
child: Text('Ok'),
onPressed: () => Navigator.of(context).pop(),
),
],
),
);
}
},
onLaunch: (Map<String, dynamic> message) async {
_loadData();
if (pushCheck) {
Navigator.of(context).pushNamed('/');
}
},
onResume: (Map<String, dynamic> message) async {
_loadData();
if (pushCheck) {
Navigator.of(context).pushNamed('/');
}
},
);
}
(...생략...)
[글상자 끝]
[2단계] 이어서 _MainPage 클래스 안에 _loadData() 함수를 추가합니다. 이 함수는 SharedPreferences에서 푸시 알림 수신 여부를 가져와 pushCheck 변수에 넣습니다.
475
[글상자] lib/mainPage.dart
(...생략...)
void _loadData() async {
var key = "push";
SharedPreferences pref = await SharedPreferences.getInstance();
pushCheck = pref.getBool(key);
}
(...생략...)
[글상자 끝]
[3단계] 이제 앱을 빌드 후 실행합니다. 그리고 13장을 참고해 파이어베이스 콘솔에서 푸시 알림을 보냅니다. 설정 화면에서 푸시 알림 수신 여부를 허용했으면 알림이 표시되고 허용하지 않았으면 표시되지 않는 것을 확인할 수 있습니다.
[그림] 실행 결과


축하합니다
모두의 여행앱을 완성했어요
OK
[그림 끝]
476
[Do it! 실습] 배너 광고 넣기
이제 설정하기 화면에 애드몹을 이용해 배너 광고를 추가해 보겠습니다. 애드몹에 광고를 만드는 방법은 13장에서 다루었습니다. 먼저 13장을 참고해 즐겨찾기에 표시할 배너 광고를 만들고 광고 단위 ID를 발급받습니다. 단, 이번 실습에서는 바로 확인할 수 있도록 테스트 광고용 아이디(testAdUnitId)를 이용해 배너를 표시해보겠습니다.
[1단계] main.dart 파일을 열고 애드몹 객체를 초기화합니다. 이때 애드몹에서 각자 발급받은 앱 ID(광고 단위 ID 아님)를 넣습니다.
[글상자] lib/main.dart
import 'package:firebase_admob/firebase_admob.dart';
(...생략...)
void main() => runApp(MyApp());
class MyApp extends StatelessWidget { ...생략... }
@override
Widget build(BuildContext context) {
FirebaseAdMob.instance
.initialize(appId: '### 애드몹 앱 ID');
Future<Database> database = initDatabase();
return MaterialApp( ...생략... );
}
}
[글상자 끝]
[2단계] settingPage.dart 파일을 열고 배너 광고 삽입 관련 코드를 추가합니다. 이때 각자 발급받은 광고 단위 ID를 넣어야 하지만, 여기서는 일단 BannerAd.testAdUnitId를 넣어 테스트용 아이디로 진행하겠습니다. 그리고 다른 페이지에서는 광고가 표시되지 않도록 dispose() 함수에서 광고를 소멸하는 코드도 작성합니다.
477
[글상자] lib/main/settingPage.dart
import 'package:firebase_admob/firebase_admob.dart';
(...생략...)
class _SettingPage extends State<SettingPage> {
bool pushCheck = true;
BannerAd bannerAd = BannerAd(
adUnitId: BannerAd.testAdUnitId, // 광고 단위 ID 넣기
size: AdSize.banner,
listener: (MobileAdEvent event) {
print('$event');
},
);
@override
void dispose() {
super.dispose();
bannerAd..dispose();
bannerAd = null;
}
(...생략...)
@override
Widget build(BuildContext context) {
bannerAd
..load()
..show(
anchorOffset: 60,
anchorType: AnchorType.bottom,
);
return Scaffold(
(...생략...)
[글상자 끝]
478
[3단계] 앱을 빌드하고 실행하면 설정 화면에 배너 광고가 표시되는 것을 확인할 수 있습니다.
[그림] 실행 결과


Nice job!, This is an interstitial test ad.
[그림 끝]
479
15-5 구글 플레이에 앱 출시하기
이로써 ‘모두의 여행’ 앱의 모든 기능을 완성했습니다. 이제 앱의 아이콘과 이름을 변경하고 구글 플레이에 출시하는 방법을 살펴보겠습니다.
[Do it! 실습] 앱 이름 수정 및 아이콘 만들기
앱 아이콘은 앱의 정체성을 나타내는 이미지입니다. 앱을 설치한 사용자는 자신의 스마트폰에서 이 아이콘을 선택해 앱을 실행합니다. 앱 아이콘으로 사용할 이미지 파일을 가지고 있다면 프로젝트에 등록해서 사용해도 되지만 여기서는 안드로이드 스튜디오의 기능을 활용해 직접 만들어 보겠습니다.
[1단계] 안드로이드 스튜디오에서 [File → Open]을 눌러 modu_tour 프로젝트 아래에 있는 android 폴더를 새 창에서 엽니다. 잠시 후 안드로이드 스튜디오가 그래들 구성을 마치면 AndroidManifest.xml 파일을 열고 application 항목의 label값을 앱 이름으로 변경합니다. 이곳에 입력한 이름은 앱이 스마트폰에 설치됐을 때 아이콘 아래에 표시됩니다.
[글상자] AndroidManifest.xml
(...생략...)
<application
android:name="io.flutter.app.FlutterApplication"
android:label="모두의 여행" // 앱 이름
android:icon="@mipmap/ic_launcher"> // 앱 아이콘
(...생략...)
[글상자 끝]
[2단계] 이어서 앱 아이콘을 만들어 보겠습니다. 안드로이드 프로젝트의 탐색 창에서 res 폴더 아래 mipmap 폴더를 마우스 오른쪽으로 클릭한 후 [New → Image Asset]을 선택합니다.
480
[그림 15-9] 앱 아이콘 만들기


New → Image Asset
[그림 끝]
[3단계] 애셋 스튜디오에서 안드로이드 스튜디오가 제공하는 클립 아트를 이용해 아이콘을 만들어 보겠습니다. 애셋 스튜디오의 Icon Type에서 [Launcher Icons (Legacy only)]를 선택하고 Name에는 app_logo라고 입력합니다. Asset Type에서 [Clip Art]를 선택하고 그 아래 클립 아트 모양을 클릭하면 선택 창이 열립니다. 여기서 앱과 어울리는 클립 아트를 선택합니다. 그다음 적절한 색상을 선택한 후 <Next>를 클릭하고 이어지는 화면에서 <Finish>를 클릭합니다.
[그림 15-10] 클립 아트를 이용해 앱 아이콘 만들기


Launcher Icons (Legacy only), app_logo, ? Clip Art, (비행기 그림), [Next]
[그림 끝]
[4단계] 안드로이드 프로젝트에서 manifests 폴더 아래 AndroidManifest.xml 파일을 열고 앱 아이콘을 방금 만든 이름으로 변경합니다.
481
[글상자] manifests/AndroidManifest.xml
(...생략...)
<application
android:name="io.flutter.app.FlutterApplication"
android:label="모두의 여행" // 앱 이름
android:icon="@mipmap/app_logo"> // 앱 아이콘
(...생략...)
[글상자 끝]
[5단계] 앱을 빌드하고 실행하면 스마트폰(또는 에뮬레이터)에 ‘모두의 여행’이라는 이름으로 앱 아이콘이 변경된 것을 볼 수 있습니다.
[그림] 실행 결과


모두의 여행
[그림 끝]
[Do it! 실습] 배포 파일 만들기
앱을 출시하려면 프로젝트의 여러 파일을 하나의 파일로 압축해서 배포해야 합니다. 이때 키스토어를 이용해 앱을 암호화합니다. 이번 실습에서 이러한 과정을 진행해 최종 배포 파일을 만들어 보겠습니다.
[1단계] 안드로이드 스튜디오에 안드로이드 프로젝트가 열린 상태에서 [Build → Generate Signed Bundle / APK...] 메뉴를 선택합니다. 다음처럼 배포 파일 형식을 선택하는 창이 나오면 [Android App Bundle]을 선택한 후 <Next>를 클릭합니다.
[그림 15-11] 안드로이드 앱 번들 선택


(1) Android App Bundle
(2) Next
[그림 끝]
482
전통적으로 안드로이드 앱의 배포 파일은 APK(Android aPplication pacKage)였습니다. 그런데 최근에 AAB(Android App Bundle) 파일로도 앱을 출시할 수 있게 되었습니다. 안드로이드 앱 번들[각주*]은 APK 생성과 서명을 구글 플레이에 맡기는 배포 형식으로, 사용자가 더 작고 최적화된 앱을 내려받을 수 있게 합니다.
[각주*] 안드로이드 앱 번들에 관한 자세한 소개는 developer.android.com/guide/app-bundle?hl=ko를 참조하기 바랍니다.[각주 끝]
[2단계] 이제 키 스토어가 필요합니다. 키 스토어(key store)는 일종의 인증서라고 생각하면 됩니다. 키 스토어를 이용해 내가 만든 앱에 서명해야지만 앱을 출시할 수 있습니다. 키 스토어 파일을 분실하거나 비밀번호를 잊어버리면 앱을 출시한 후 업데이트할 수 없으므로 조심해서 다루어야 합니다. 다음 화면에서 [Create new]를 클릭해 새로운 키 스토어 파일을 만듭니다.
[그림 15-12] 키 스토어 생성


Create new...
[그림 끝]
[3단계] 키 스토어를 저장할 위치를 선택하고 이름을 입력한 후 <OK>를 클릭합니다.
[그림 15-13] 키 스토어 위치와 이름 설정


(1) FlutterProject
(2) flutter
(3) [OK]
[그림 끝]
483
[4단계] 이제 키 정보를 등록합니다. 별칭(alias)과 비밀번호를 적절하게 입력한 후 <OK>를 클릭하면 확장자가 .jks인 키 스토어 파일이 만들어집니다.
[그림 15-14] 키 스토어 정보 입력


(1) Password: ******, Confirm: ******
(2) Alias: tour
Password: ******, Confirm: ******
Validity (years): 25
Certificate
First and Last Name: cho
Organizational Unit:
Organization:
City or Locality:
State or Province:
Country Code (XX):
(3) [OK]
[그림 끝]
[아하!] 키 스토어의 키 생성 시 발생하는 경고 해결하기
키 스토어의 키를 생성할 때 다음과 같은 경고 메시지가 나올 수 있습니다.
[그림 15-15] 키스토어 생성 시 발생한 경고창


Error
Key was created with errors:
Warning: JKS 키 저장소는 고유 형식을 사용합니다. "keytool -importkeystore -srckeystore D:\FlutterProject\flutter.jks -destkeystore D:\FlutterProject\flutter.jks -deststoretype pkcs12"를 사용하는 산업 표준 형식인 PKCS12로 이전하는 것이 좋습니다.
[OK]
[그림 끝]
이 경고 메시지는 암호화 키를 만들 때 업계 표준으로 사용하는 pkcs # 12 형태로 만들지 않아서 발생한 것입니다. 그러나 이 경고가 발생하더라도 앱을 빌드하는 데는 전혀 지장이 없습니다. 만약 이 경고를 해결하고 싶다면 경고 메시지에서 따옴표 안에 있는 명령을 명령 프롬프트에서 실행하면 됩니다. 이 명령은 개인 키를 pkcs # 12라고 하는 공개 키의 인증서가 포함된 형태로 바꿔주는 명령입니다. 명령을 실행한 후 비밀번호를 입력하면 키의 별칭이 임포트되었다고 표시됩니다.
[그림 15-16] 명령 프롬프트에서 키 별칭 임포트하기


[그림 끝]
[아하! 끝]
484
[5단계] 방금 생성한 키 스토어 정보가 입력된 화면에서 <Next>를 클릭합니다.
[그림 15-17] 키 스토어 생성 완료


[Next]
[그림 끝]
[6단계] 다음 화면에서 release를 선택한 후 <Finish>를 클릭합니다. 그러면 잠시 후 플러터 프로젝트 폴더의 android/app 폴더 아래 release 폴더가 만들어지고 그 아래 최종 배포 파일인 app-release.aab가 생성됩니다.
[그림 15-18] 빌드 설정


(1) release
(2) [Finish]
[그림 끝]
[Do it! 실습] 구글 플레이에 앱 등록하기
이제 앱을 구글 플레이에 등록해 보겠습니다. 먼저 자신의 구글 계정을 개발자 계정으로 등록해야 합니다. 참고로 구글의 개발자 계정으로 등록하려면 25달러의 비용이 듭니다.
[1단계] 구글 플레이 콘솔(developer.android.com/distribute/console)에 접속한 후 <로그인>을 클릭합니다. 구글 계정으로 로그인하면 개발자 계정 만들기 화면으로 이동합니다.
485
[그림 15-19] 구글 플레이 콘솔


로그인
[그림 끝]
[2단계] 개발자 계정을 만들기 위해 몇 가지 필수 정보를 입력하고 <계정 생성 및 결제>를 클릭합니다.
[그림 15-20] 개발자 계정 만들기


(1) 공개 개발자 이름: [ ] Google Play에서 사용자에게 공개됩니다. 0/50
보조 연락처 이메일 주소: [ ] Google 계정에 연결된 이메일과 더불어 Google에서 연락을 드리는 데 사용할 수 있습니다. Google Play 사용자에게는 공개되지 않습니다.
연락처 전화번호: [ ] +기호, 국가 코드, 지역 번호를 포함하세요. 이 번호는 Google에서 연락을 드리는 데 사용될 수 있지만, Google Play에서 사용자에게 공개되지는 않습니다.
개발자 계약 및 서비스 약관
? Google Play 개발자 배포 계약을 읽었으며 이에 동의합니다. 또한 Google 계정을 Google Play 개발자 배포 계약과 연결하는 데도 동의하며, 본인이 만 18세 이상임을 확인합니다.
? Google Play Console 서비스 약관을 읽었으며 이에 동의합니다. 또한 Google 계정을 Google Play Console 서비스 약관과 연결하는 데도 동의합니다.
(2) [계정 생성 및 결제]
[그림 끝]
[3단계] 신용카드 정보를 입력하는 화면이 나옵니다. 개발자 계정을 만들려면 25달러를 결제해야 합니다. 한 번 결제하면 평생 사용할 수 있는 개발자 계정을 생성합니다. 개발자 계정을 만들었으면 <Play Console로 이동>을 클릭합니다.
486
[그림 15-21] 개발자 계정 등록 화면


(1) 카드 번호
__(카드 번호를 입력하세요.) MM / YY / CVC
__(카드 소유자 이름을 입력하세요.)
대한민국(KR)
우편번호
__(우편번호을(를) 입력하세요.)
(2) [구매]
(3) [Play Console로 이동]
[그림 끝]
[4단계] 플레이 콘솔에서 <앱 만들기>를 클릭합니다.
[그림 15-22] 구글 플레이 콘솔 실행 화면


[앱 만들기]
[그림 끝]
[5단계] 앱 이름, 기본 언어, 앱 또는 게임, 유료 또는 무료, 기타 약관에 동의한 후 <앱 만들기>를 클릭합니다.
[그림 15-23] 애플리케이션 만들기


(1) 모두의 여행
(2) 한국어 - ko-KR
(3) ? 앱
(4) ? 무료
(5) ?, ?
(6) [앱 만들기]
[그림 끝]
487
[6단계] 앱을 출시하려면 앱 설정을 통해 필요한 정보를 입력해야 합니다. 집필 시점에 앱 설정은 크게 앱 콘텐츠에 관한 5가지 정보와 앱 분류와 표시되는 방식에 관한 2가지 정보를 요구합니다. 각 항목의 설정을 완료하면 다음 그림처럼 왼쪽에 녹색 체크 아이콘이 표시됩니다.
[그림 15-24] 필요한 정보 목록


〔앱 엑세스 권한〕, 〔광고〕, 〔콘텐츠 등급〕, 〔티켓층〕, 〔뉴스 앱〕, 〔앱 카테고리 선택 및 연락처 세부정보 제공〕, 스토어 등록정보 설정
[그림 끝]
구글이 안내하는 절차에 따라 자신이 만든 앱에 대한 정보를 입력합니다. 각각의 정보를 입력하는 과정은 특별히 어렵지 않으므로 요약해서 표로 제공합니다. 다만, 마지막 과정인 ‘스토어 등록정보 설정’에서는 여러 가지 그림 파일이 필요하므로 요구하는 크기와 목적에 맞게 미리 준비해야 합니다.
[표 15-2] 앱 설정 항목
항목

요약

앱 액세스 권한

<특수한 액세스 권한 없이 모든 기능 이용 가능> 선택

광고

<예, 앱에 광고가 있습니다> 선택(광고를 넣지 않았으면 아니요 선택)

콘텐츠 등급

설문에 응답(문의용 이메일 주소 등록, 카테고리 설정, 설문지 등)

타겟층 및 콘텐츠

13세 이상으로 설정(13세 미만은 개인정보보호 관련 지침을 등록해야 함)

뉴스 앱

<아니요> 선택

스토어 설정

앱 카테고리, 연락처 등 설정

스토어 등록정보 설정

앱 세부 정보와 그래픽(앱 아이콘, 소개 이미지, 주요 기기별 스크린샷 등)

488
[7단계] 기본적인 앱 설정을 마치면 비로소 [Google Play에 앱 게시] 절차가 활성화됩니다. 여기서 3단계를 거치면 앱을 출시할 수 있습니다.
[그림 15-25] 구글 플레이에 앱 게시


Google Play에 앱 게시
앱을 프로덕션 트랙에 출시하여 실제 사용자를 대상으로 Google Play에 게시합니다.
할 일 숨기기
국가 및 지역 선택
버전 생성 및 출시
새 버전 만들기
버전 검토 및 출시
[그림 끝]
[국가 및 지역]은 안내에 따라 간단하게 추가할 수 있으며 [새 버전 만들기]에서는 앞의 실습에서 만든 ABB 배포 파일을 등록합니다. 그리고 버전 세부 정보를 입력하고 <저장>과 <버전 검토>를 차례로 클릭합니다.
[그림 15-26] 새 버전 만들기


[그림 끝]
489
[8단계] 모든 정보를 등록했습니다. 이제 <프로덕션 트랙으로 출시 시작> 버튼이 활성화되면 클릭합니다. 이후 심사를 거쳐 구글 플레이에 등록됩니다.
[그림 15-27] 프로덕션 출시 시작


오류, 경고 및 메시지
경고 2개(더보기)
신규 App Bundle 및 APK
파일 형식 / 버전 / API 수준 / 타겟 SDK / 화면 레이아웃 / ABI / 필수 기능
Android App Bundle / 1(1.0.0) / 16 이상 / 28 / 4 / 2 / 1 →
출시 노트: 버전 출시 전에 검토하기
버전 수정
[프로덕션 트랙으로 출시 시작]
[그림 끝]
이로써 플러터 여행 정보 앱을 직접 만들고 출시까지 해보았습니다. 지금까지 살펴본 플러터의 위젯과 기능들을 조합해 여러분이 상상하는 새로운 앱을 만들어 보세요. 놀라운 앱을 만들어 더 많은 사용자에게 다가가고 비즈니스를 성장시키는 데 도움이 되기를 소망하면서 이 책을 마칩니다. 고맙습니다.
490
찾아보기
* 제작자 주: 찾아보기 490~494쪽은 생략함.
찾아보기 면
491
찾아보기 면
492
찾아보기 면
493
찾아보기 면
494
찾아보기 면
495
? 지금 나에게 필요한 책은?
1. 개발자의 길을 가고 있어요.
1) 프로그래밍을 시작하고 싶다면? - B 기초 프로그래밍 코스
2) 모바일 앱 개발자가 되고 싶다면? - M 모바일 앱 개발자 코스
3) 웹 프로그래밍의 기초부터 배우고 싶다면? - W 웹 프로그래밍 코스
2. 직장에서 능력자가 되고 싶어요!
1) 매일 쓰는 프로그램으로 인정받고 싶다면? - 된다! 7일 실무 엑셀
2) 동영상 제작은 기본이죠! - 된다! 김메주의 유튜브 영상 만들기
496
프로그래밍을 시작하고 싶다면? - B 기초 프로그래밍 코스(Basic Programming Course)
* 제작자 주: 빨간색 한 줄~세 줄을 난이도 1~3으로 입력함.
(파이썬 분야 1위!) Do it! 점프 투 파이썬 - 전면 개정판
하루 한 시간이면 당신도 프로그램을 만들 수 있다!
초보자의 마음을 가장 잘 이해하고, 프로그래밍의 재미를 알려주는 책
난이도 1, 박응용 지음 | 18,800원
Do it! C 언어 입문
실무 20년, 현업 프로그래머가 초보자를 위해 엮었다!
난이도 1, 김성엽 지음 | 25,000원
Do it! 자바 프로그래밍 입문
개발 10년, 강의 10년! 명강사의 기초 튼튼 코딩 밥상!
난이도 1, 박은종 지음 | 25,000원
Do it! 자료구조와 함께 배우는 알고리즘 입문 - C 언어 편
263개의 도해와 114개의 예제로 자료구조와 알고리즘을 쉽게 배운다!
난이도 2, 시바타 보요 지음 | 22,000원
Do it! 자료구조와 함께 배우는 알고리즘 입문 - JAVA 편
220개의 도해와 88개의 예제로 꼼꼼한 코드 설명과 그림으로 이해하기 쉽다!
난이도 2, 시바타 보요 지음 | 22,000원
Do it! 자료구조와 함께 배우는 알고리즘 입문 - 파이썬 편
213개의 그림과 136개의 실전 예제로 빠르고 쉽게 배운다!
난이도 2, 시바타 보요 지음 | 22,000원
Do it! 파이썬 생활 프로그래밍
뼛속까지 문과생인 지리학 박사가 집필한 파이썬 생활 프로그래밍 책!
난이도 3, 김창현 지음 | 20,000원
난이도 1 - 문과생과 비전문가도 보는 책
난이도 2 / 난이도 3 - 해당 분야의 이해가 조금 필요한 책
뒷날개
함께 보면 좋은 Do it! 시리즈!
Do it! 안드로이드 앱 프로그래밍
- 전면 개정 7판
안드로이드 분야 1위 도서!
앱 개발의 모든 것을 담았다!
초급자도 중급자도 찾는 이유 있는 책!
정재곤 지음|40,000원
Do it! 스위프트로 아이폰 앱 만들기 입문
코딩 몰라도 OK!
손가락으로 짚어 주듯 하나하나 알려 준다!
송호정·이범근 지음|30,000원
Do it! 프로그레시브 웹앱 만들기
반응형 웹 개발부터
하이브리드 앱 배포까지
PWA 완정 정복!
김응석 지음|32,000원
Do it! 코틀린 프로그래밍
코틀린 기초 문법부터 안드로이드 활용까지
어제도 코드를 짠 현업 개발자가 알려 준다!
황영덕 지음|30,000원
Do it! 자바 프로그래밍 입문
개발 10년, 강의 10년 명강사의
기초 튼튼 코딩 밥상!
135개 그림으로 술술 읽고
240개 예제로 쉽게 이해한다!
박은종 지음|25,000원
뒤표지
세상의 속도를 따라잡고 싶다면
Do it! 플러터 앱 프로그래밍(Do it! Flutter Apps Programming)
관광 정보 앱이 만들어지는 플러터 실습서
실전에서 바로 써먹을 수 있는 코드로 배운다!
? 다트 언어의 핵심 문법을 빠르게 학습
? 20여 개의 실용적인 실습 예제로 익히기
? 오픈 API로 관광 정보 앱 만들고 구글 플레이 배포까지
- 기본 & 고급 위젯: 화면 구성, 핵심 로직 이해하기
- 오픈 API: 관광 정보 데이터 이용하기
- 파이어베이스: 데이터베이스, 사용자 분석, 푸시 알림
- 광고 수익: 애드몹 이용 배너, 전면 광고 넣기
- 앱 배포: 구글 플레이에 앱 출시
베타테스터의 한마디
일단 ‘소스’가 풍부해서 좋아요. 다양한 플러터 패키지를 사용해 볼 수 있고 ‘모두의 여행’이라는 관광 정보 앱의 전체 소스와 개발 및 배포 과정을 제공한다는 것만으로도 충분히 가치 있는 책입니다. - 김은숙(IT 도서 기획자)
군더더기 없는 내용으로 크로스 플랫폼 모바일 앱 개발을 빠르게 배울 수 있습니다. 오픈 API 활용이나 파이어베이스, 광고 넣기까지 다뤄 한 권의 책으로 다양하게 경험해 볼 수 있습니다. - 안동현(번역자 겸 개발자)
값 30,000원
ISBN 979-11-6303-231-1
